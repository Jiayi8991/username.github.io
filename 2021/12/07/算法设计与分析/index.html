<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi8991.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="排序算法回顾   Algorithm (worst) time (best) time (avg) time method    MergeSort O(n log n) O(n log n) O(n log n) divide &amp; conquer   QuickSort n2 O(n log n) O(n log n) divide &amp; conquer   InsertSort">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计与分析">
<meta property="og:url" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="JiayiSpace">
<meta property="og:description" content="排序算法回顾   Algorithm (worst) time (best) time (avg) time method    MergeSort O(n log n) O(n log n) O(n log n) divide &amp; conquer   QuickSort n2 O(n log n) O(n log n) divide &amp; conquer   InsertSort">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-07-16-23-32.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20211031131444192.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-07-16-21-29.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/849589-20171015231308699-356134237.gif">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/1.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/countingSort.gif">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/radixSort.gif">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/Bucket_sort_1.svg_.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/Bucket_sort_2.svg_.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/v2-ff4cdccdb1ff6b90ecdb3fc4d361f725_r.jpg">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAZCAYAAABZ5IzrAAAA90lEQVRIS+3VIUtDURiH8d8wCGITwW4aKJgsJjEMRMM+hMjQaDLJqiwPTJpWFhasfgOLn2AzGRQMMrNcOMIQ9d29MBlybj2H83/O877vuTVz9tXmjEcGiiryLwy18Ix+cNtF3OAIb5GZz/Uqhq4xwkUQspxAVvGSgb4xkA3lHvppMLp4xXkwOStpuopeGs9yys6wg2YQsose1qaFKfZVeYfW8YBNDH8Ju8UjTmYNVJx/iT000qv9NbONY2zh6S+AFnCFfXRwh3fUk5ENHOK+DEzVkk1mHOAU21hKJRokg1P/LiYPrNJDZS9dan8GinRlQ9lQZCBa/wApHTMa0RPaKgAAAABJRU5ErkJggg==">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAZCAYAAAAv3j5gAAAA2klEQVRIS+3Uv0qCURjH8Y9Liy1Cjl6AU1NeQ4SjczQFIg11Be1OLq01CtbgDXgJ0Q2IObgZDREuBnHiFSSINx7B6ZzlHDh/vud8nx+nYk+tsieODAqb3lVdFR20kMYzjPHy+0a7gE7xgAUm+EQTbYzQxWoDjILOMMRl0W8/oIEnvCOt+0qTEdAhpujh8Y+i1fCMPu6ioHNc4aQkGRe4xnEUNCh03JSAksI5DrCOqLsvDrgtASXFHzjCWwSUkvaK/4LqWGZQKktWFw5D6AePpC6DfgxkdaEgpE3f90o0Gph66HgAAAAASUVORK5CYII=">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAZCAYAAADuWXTMAAABZUlEQVQ4T93UP0iVURjH8c+VcpFK1CHcaisKHNVNByNI98YgkFoaajGIILFwbQtJEaKgyH/VUlv2d7tLtDVZo0ZBDorGE88b7325Q3CH4B544eWc53vO7/d7DqemhVFrgdVm8FEM4wg28Abb6EI3vkZWVc89uIuzWMcmjuEkpjGGT5iqwn0JPMdN/Cp14jjeYhfxv1OFX+AjbjVp3xVMppJ5xPdX9iDu4zT2KvA5zGUGB/EyrewXnmfwA7MVcACvMIH3ufYOl1Ev4Id4hGcluB8fcA2PS/MhOeqWC/gBnmA1i6Ilr/EUtytqFrEUtQV8I/1HWB2xa4ZzoUl4dZzH5wKOPkaLTuAOwuuZoiWlDYYy2KhvuCTh5RQOZbJblVN7EWFdzYMa4HGs5cKlvJYFP4J7WEhlf+YL2Z3hARcxioC/4Xv29CeuY6Wspny348JHcYwDaeFwKvjS7NFos8fgn97F/+f5NyvPRhqyABylAAAAAElFTkSuQmCC">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-08-15-28-26.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-08-15-15-25.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-086-03-05.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/20191127135310793.gif">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/20191127135244696.gif">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2019112716422925.gif">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-0815-37-08.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/399159-20151229144326901-1530781288.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/399159-20151229144340448-1796643731.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-1115-52-29.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-116-20-00.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-1115-52-29.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-124-18-54.png">
<meta property="og:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-14-19-39.png">
<meta property="article:published_time" content="2021-12-07T08:10:39.000Z">
<meta property="article:modified_time" content="2022-01-13T03:54:00.853Z">
<meta property="article:author" content="Jiayi Liang">
<meta property="article:tag" content="学习, 算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-07-16-23-32.png">

<link rel="canonical" href="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法设计与分析 | JiayiSpace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JiayiSpace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法设计与分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-07 16:10:39" itemprop="dateCreated datePublished" datetime="2021-12-07T16:10:39+08:00">2021-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-13 11:54:00" itemprop="dateModified" datetime="2022-01-13T11:54:00+08:00">2022-01-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="排序算法回顾"><a href="#排序算法回顾" class="headerlink" title="排序算法回顾"></a>排序算法回顾</h1><table>
<thead>
<tr>
<th>Algorithm</th>
<th>(worst) time</th>
<th>(best) time</th>
<th>(avg) time</th>
<th>method</th>
</tr>
</thead>
<tbody><tr>
<td>MergeSort</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>divide &amp; conquer</td>
</tr>
<tr>
<td>QuickSort</td>
<td>n<sup>2</sup></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>divide &amp; conquer</td>
</tr>
<tr>
<td>InsertSort</td>
<td>n<sup>2</sup></td>
<td>n</td>
<td>n<sup>2</sup></td>
<td>insertion</td>
</tr>
<tr>
<td>SelectSort</td>
<td>n<sup>2</sup></td>
<td>n<sup>2</sup></td>
<td>n<sup>2</sup></td>
<td>selection</td>
</tr>
<tr>
<td>BubbleSort</td>
<td>n<sup>2</sup></td>
<td>n</td>
<td>n<sup>2</sup></td>
<td>swapping</td>
</tr>
<tr>
<td>HeapSort</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>swapping</td>
</tr>
</tbody></table>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>a heap can be given by an array H[0..n-1] and an integer t. </li>
<li>The children of node H[h] are H[2h+1] and H[2h+2].</li>
<li>The parent of node H[h] is H[(h-1)/2]</li>
</ul>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-07-16-23-32.png" alt="2021-12-07-16-23-32.png">  </p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/image-20211031131444192.png" alt="image-20211031131444192.png">  </p>
<ul>
<li>The height of a heap of n nodes is ≤ log<sub>2</sub> n .<ul>
<li>  <img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-07-16-21-29.png" alt="2021-12-07-16-21-29.png"> </li>
<li>1 + 2 + 22 + 23 + ‧‧‧ + 2h-1 = 2h - 1</li>
<li>So n ≥ 2h – 1 + 1 = 2h, and h ≤ log<sub>2</sub> n </li>
</ul>
</li>
</ul>
<h4 id="FixHeap"><a href="#FixHeap" class="headerlink" title="FixHeap()"></a>FixHeap()</h4><ul>
<li>FixHeap(H, t, i) takes <strong>time O(log n).</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">FixHeap(H, t, i)</span><br><span class="line">1. h = i; </span><br><span class="line">2. if (h ≠ root &amp; h &gt; its parent) </span><br><span class="line">      while (h ≠ root &amp; h &gt; its parent) \\插入到数组最后 </span><br><span class="line">         swap h and its parent;</span><br><span class="line">    else </span><br><span class="line">      while (h ≠ leaf &amp; h &lt; its larger child)</span><br><span class="line">         swap h and its larger child.</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">FixHeap(H, t, i)</span><br><span class="line">1. h = i; </span><br><span class="line">2. if (h &gt; 0 &amp; H[h] &gt; H[⌊(h-1)/2⌋]) </span><br><span class="line">      while (h &gt; 0 &amp; H[h] &gt; H[⌊(h-1)/2⌋]) </span><br><span class="line">         H[h] ↔ H[⌊(h-1)/2⌋];</span><br><span class="line">         h = ⌊(h-1)/2⌋</span><br><span class="line">    else</span><br><span class="line">      while (2h+1 ≤ t)</span><br><span class="line">         H[g] = max&#123;H[2h+1], H[2h+2]&#125;;</span><br><span class="line">         if (H[h] &lt; H[g])</span><br><span class="line">            H[h] ↔ H[g];</span><br><span class="line">            h = g; </span><br><span class="line">         else h = t.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// In HeapSort, only FixHeapD is needed</span><br><span class="line">FixHeapD(H, t, i)   // FixHeapD only moves down along the root/leaf path. </span><br><span class="line">1. h = i; </span><br><span class="line">2. while (2h+1 ≤ t)</span><br><span class="line">       H[g] = max&#123;H[2h+1], H[2h+2]&#125;;</span><br><span class="line">       if (H[h] &lt; H[g])</span><br><span class="line">          H[h] ↔ H[g];</span><br><span class="line">          h = g; </span><br><span class="line">       else h = t.</span><br></pre></td></tr></table></figure>

<h4 id="SortHeap"><a href="#SortHeap" class="headerlink" title="SortHeap()"></a>SortHeap()</h4><ul>
<li>Sorting a heap takes time O(n log n).</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">H[0..n-1] is a heap</span><br><span class="line">1. t = n-1; </span><br><span class="line">2. while (t &gt; 0) </span><br><span class="line">      H[1] ↔ H[t];</span><br><span class="line">      t = t – 1; </span><br><span class="line">      FixHeap(H, t, 0).</span><br></pre></td></tr></table></figure>

<h4 id="MakeHeap"><a href="#MakeHeap" class="headerlink" title="MakeHeap()"></a>MakeHeap()</h4><ul>
<li>time of MakeHeap: O(n log n)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i = ⌊(n-2)/2⌋; i ≥ 0; i--)</span><br><span class="line">      FixHeapD(H, n-1, i).</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main()"></a>Main()</h4><ul>
<li><strong>HeapSort sorts an array of size n in time O(n log n).</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FixHeapD(H, t, i)</span><br><span class="line">1. h = i; </span><br><span class="line">2. while (2h+1 ≤ t)</span><br><span class="line">       H[g] = max&#123;H[2h+1], H[2h+2]&#125;;</span><br><span class="line">       if (H[h] &lt; H[g])</span><br><span class="line">          H[h] ↔ H[g];</span><br><span class="line">          h = g; </span><br><span class="line">       else h = t.</span><br><span class="line"></span><br><span class="line">MakeHeap(H[0..n-1])</span><br><span class="line">\\ make array H[0..n-1] a heap</span><br><span class="line">1. for (i = ⌊(n-2)/2⌋; i ≥ 0; i--)</span><br><span class="line">      FixHeapD(H, n-1, i).</span><br><span class="line"></span><br><span class="line">SortHeap(H[0..n-1])</span><br><span class="line">\\ H[0..n-1] is a heap</span><br><span class="line">1. t = n-1; </span><br><span class="line">2. while (t &gt; 0) </span><br><span class="line">      H[0] ↔ H[t];</span><br><span class="line">      t = t – 1; </span><br><span class="line">      FixHeapD(H, t, 0).</span><br><span class="line"></span><br><span class="line">main HeapSort(H[0..n-1])</span><br><span class="line">\\ sort the array H[0..n-1]</span><br><span class="line">1. MakeHeap(H[0..n-1]);</span><br><span class="line">2. SortHeap(H[0..n-1]). </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="算法动图演示"><a href="#算法动图演示" class="headerlink" title="算法动图演示"></a>算法动图演示</h4><p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/849589-20171015231308699-356134237.gif" alt="849589-20171015231308699-356134237.gif"> ‘ ``</p>
<h3 id="线性时间排序（Sorting-in-Linear-Time）"><a href="#线性时间排序（Sorting-in-Linear-Time）" class="headerlink" title="线性时间排序（Sorting in Linear Time）"></a>线性时间排序（Sorting in Linear Time）</h3><h4 id="计数排序（Courting-Sort）"><a href="#计数排序（Courting-Sort）" class="headerlink" title="计数排序（Courting Sort）"></a>计数排序（Courting Sort）</h4><blockquote>
<ul>
<li> `〔筆畫〕Algorithm. CountingSort</li>
<li>Step 1. for each value v, count the number of copies of v in A[0..n-1]</li>
<li>Step 2. for each A[i], count the number of elements in A[0..n-1] that are not larger than A[i] </li>
<li>Step 3. use the information in step 2 to output a sorted list. </li>
<li>计数排序的思想是：<ul>
<li>在待排序序列中，如果我们能统计出有多少元素小于或等于某一个元素，我们也就知道了该元素的正确位置。</li>
<li>例如，对于待排序序列{2,5,3,0,2,3,0,3}，我们统计出有8个元素小于等于5（包括5自己），那么5这个元素就应该被排序到第8位</li>
<li>算法的步骤如下：<ul>
<li>（1）找出待排序的数组中最大和最小的元素</li>
<li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Algorithm. CountingSort(A[0..n-1])</span><br><span class="line"></span><br><span class="line">1. for (h=0; h&lt;k; h++) C[h] = 0;</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">       C[A[i]] = C[A[i]] + 1; </span><br><span class="line">2. for (h=1; h&lt;k; h++)</span><br><span class="line">       C[i] = C[i-1] + C[i]; </span><br><span class="line">3. for (i=n-1; i&gt;=0; i--)</span><br><span class="line">       C[A[i]] = C[A[i]] – 1.</span><br><span class="line">       B[C[A[i]]] = A[i];</span><br><span class="line">       </span><br><span class="line">其中数组A[1~n]是待排序数组；数组B[1~n]用来存放已排好序的元素。C[0~k]用来存放上面所说的统计数（具体的说C[i]就表示在数组A中，小于或等于i的元素的总个数）</span><br><span class="line"></span><br><span class="line">Algorithm. CountingSort</span><br><span class="line"></span><br><span class="line">- Step 1. for each value v, count the number of copies of v in A[0..n-1]</span><br><span class="line">- Step 2. for each A[i], count the number of elements in A[0..n-1] that are not larger than A[i] </span><br><span class="line">- Step 3. use the information in step 2 to output a sorted list. </span><br></pre></td></tr></table></figure>

<p><strong>模拟计数排序过程：</strong></p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/1.png">  </p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/countingSort.gif"> </p>
<h4 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h4><p><strong>基本思想</strong></p>
<p>原理是将整数按<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BD%8D%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:126116878%7D">位数</a>切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<ul>
<li><strong>MSD</strong>：先从高位开始进行排序，在每个关键字上，可采用计数排序</li>
<li><strong>LSD</strong>：先从低位开始进行排序，在每个关键字上，可采用桶排序</li>
</ul>
<p><strong>实现逻辑</strong></p>
<blockquote>
<p>① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>② 从最低位开始，依次进行一次排序。<br>③ 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
</blockquote>
<p><strong>复杂度分析</strong></p>
<blockquote>
<p>时间复杂度：O(k*N)<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:126116878%7D">空间复杂度</a>：O(k + N)<br>稳定性：稳定</p>
</blockquote>
<p><strong>算法动画演示</strong></p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/radixSort.gif"> </p>
<h4 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h4><p>桶排序是计数排序的升级版。</p>
<p>桶排序的思想近乎彻底的<strong>分治思想</strong>。</p>
<p><strong>step1:</strong> 桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。</p>
<p><strong>step2:</strong> 然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。</p>
<p><strong>step3:</strong> 接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]….B[M] 中的全部内容即是一个有序序列。</p>
<blockquote>
<p>补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数</p>
</blockquote>
<p><strong>它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</strong>为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p><strong>1. 什么时候最快</strong></p>
<p>当输入的数据可以均匀的分配到每一个桶中。</p>
<p><strong>2. 什么时候最慢</strong></p>
<p>当输入的数据被分配到了同一个桶中。</p>
<p><strong>示意图</strong>1</p>
<blockquote>
<p>元素分布在桶中</p>
</blockquote>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/Bucket_sort_1.svg_.png"> </p>
<blockquote>
<p>元素在每个桶中的排序</p>
</blockquote>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/Bucket_sort_2.svg_.png"> </p>
<p><strong>示意图2</strong></p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/v2-ff4cdccdb1ff6b90ecdb3fc4d361f725_r.jpg"> </p>
<p><strong>复杂度分析</strong></p>
<blockquote>
<p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%9C%80%E5%B7%AE%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:125737294%7D">最差时间复杂度</a>：O(n ^ 2)<br>空间复杂度：O(n * k)<br>稳定性：稳定</p>
</blockquote>
<h4 id="上述三种排序算法小结："><a href="#上述三种排序算法小结：" class="headerlink" title="上述三种排序算法小结："></a>上述三种排序算法小结：</h4><p>基数排序与计数排序、桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p>基数排序不是直接根据元素整体的大小进行元素比较，而是将原始列表元素分成多个部分，对每一部分按一定的规则进行排序，进而形成最终的有序列表。</p>
<h1 id="图论部分算法"><a href="#图论部分算法" class="headerlink" title="图论部分算法"></a>图论部分算法</h1><h2 id="一些容易忘记的概念"><a href="#一些容易忘记的概念" class="headerlink" title="一些容易忘记的概念"></a>一些容易忘记的概念</h2><p><strong>连通</strong></p>
<ul>
<li>An undirected graph is connected if every pair of vertices is connected by a path. <ul>
<li>如果每一对顶点都由一条路径连接，则无向图是连通的。</li>
</ul>
</li>
</ul>
<p><strong>森林</strong></p>
<ul>
<li>A forest is an acyclic graph (i.e., a graph without simple cycles). A tree is a connected acyclic graph. A tree of n vertices has n-1 edges. <ul>
<li>森林是一个无循环图(即没有简单循环的图)。树是一个连通的无环图。有n个顶点的树有n-1条边。</li>
</ul>
</li>
</ul>
<p><strong>路径</strong></p>
<ul>
<li>A path P(v0, vk) from a vertex v0 to a vertex vk is a sequence {v0, v1, v2, …, vk} of vertices, where [vi-1, vi] are edges in G for i = 1, 2,…, k. The path P(v0, vk) is a cycle if v0 = vk. The path P(v0, vk) is simple if all vertices are distinct. The length of a path is defined as the number of edges in the <ul>
<li>从顶点v0到顶点vk的路径P(v0, vk)是一个顶点序列{v0, v1, v2, vk}，其中[vi-1, vi]是G中的边(i = 1,2, k)。如果v0 = vk，路径P(v0, vk)是一个循环。如果所有顶点都是不同的，路径P(v0, vk)就很简单。路径的长度定义为路径中边的个数</li>
</ul>
</li>
</ul>
<p><strong>二分图（bipartite）</strong></p>
<ul>
<li>A graph G = (V, E) is bipartite if its vertex set V can be partitioned into two disjoint subsets V = R<img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAZCAYAAABZ5IzrAAAA90lEQVRIS+3VIUtDURiH8d8wCGITwW4aKJgsJjEMRMM+hMjQaDLJqiwPTJpWFhasfgOLn2AzGRQMMrNcOMIQ9d29MBlybj2H83/O877vuTVz9tXmjEcGiiryLwy18Ix+cNtF3OAIb5GZz/Uqhq4xwkUQspxAVvGSgb4xkA3lHvppMLp4xXkwOStpuopeGs9yys6wg2YQsose1qaFKfZVeYfW8YBNDH8Ju8UjTmYNVJx/iT000qv9NbONY2zh6S+AFnCFfXRwh3fUk5ENHOK+DEzVkk1mHOAU21hKJRokg1P/LiYPrNJDZS9dan8GinRlQ9lQZCBa/wApHTMa0RPaKgAAAABJRU5ErkJggg==" alt="img">B, R<img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAZCAYAAAAv3j5gAAAA2klEQVRIS+3Uv0qCURjH8Y9Liy1Cjl6AU1NeQ4SjczQFIg11Be1OLq01CtbgDXgJ0Q2IObgZDREuBnHiFSSINx7B6ZzlHDh/vud8nx+nYk+tsieODAqb3lVdFR20kMYzjPHy+0a7gE7xgAUm+EQTbYzQxWoDjILOMMRl0W8/oIEnvCOt+0qTEdAhpujh8Y+i1fCMPu6ioHNc4aQkGRe4xnEUNCh03JSAksI5DrCOqLsvDrgtASXFHzjCWwSUkvaK/4LqWGZQKktWFw5D6AePpC6DfgxkdaEgpE3f90o0Gph66HgAAAAASUVORK5CYII=" alt="img"> B = <img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAZCAYAAADuWXTMAAABZUlEQVQ4T93UP0iVURjH8c+VcpFK1CHcaisKHNVNByNI98YgkFoaajGIILFwbQtJEaKgyH/VUlv2d7tLtDVZo0ZBDorGE88b7325Q3CH4B544eWc53vO7/d7DqemhVFrgdVm8FEM4wg28Abb6EI3vkZWVc89uIuzWMcmjuEkpjGGT5iqwn0JPMdN/Cp14jjeYhfxv1OFX+AjbjVp3xVMppJ5xPdX9iDu4zT2KvA5zGUGB/EyrewXnmfwA7MVcACvMIH3ufYOl1Ev4Id4hGcluB8fcA2PS/MhOeqWC/gBnmA1i6Ilr/EUtytqFrEUtQV8I/1HWB2xa4ZzoUl4dZzH5wKOPkaLTuAOwuuZoiWlDYYy2KhvuCTh5RQOZbJblVN7EWFdzYMa4HGs5cKlvJYFP4J7WEhlf+YL2Z3hARcxioC/4Xv29CeuY6Wspny348JHcYwDaeFwKvjS7NFos8fgn97F/+f5NyvPRhqyABylAAAAAElFTkSuQmCC" alt="img">, such that every edge in G has one end in R and one end in B. In other words, the graph is 2-colorable<ul>
<li>图G = (V, E)属于二分图，如果它的顶点集合V可以分割成两个不相交的子集V= R, R B , 这样每条边在G R和一端一端。换句话说,图为2-colorable</li>
<li><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-08-15-28-26.png"> </li>
</ul>
</li>
</ul>
<p><strong>连通分量</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427">无向图</a>G的极大连通子图称为G的连通分量( Connected Component)。</p>
<p>任何<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995">连通图</a>的连通分量只有一个，即是其自身，非连通的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427">无向图</a>有多个连通分量。</p>
<ul>
<li>Let G be an undirected graph. A connected component (CC) of G is a maximal subgraph that is connected. <ul>
<li>设G是一个无向图。G的连通分量(CC)是一个极大的连通子图。</li>
</ul>
</li>
</ul>
<p><strong>强连通分量</strong></p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743">有向图</a>G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A/1131406">强连通</a>(strongly connected)。</p>
<p>如果有向图G的每两个顶点都强连通，称G是一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE/6769617">强连通图</a>。</p>
<p>有向图的极大强连通<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%90%E5%9B%BE/8737707">子图</a>，称为强连通分量。</p>
<ul>
<li>Let G be a directed graph. Two vertices v and w in G are in the same strongly connected component (scc) if in the graph G, there exist a (directed) path from v to w and a (directed) path from w to v.<ul>
<li>设G是一个有向图。如果在图G中存在一条从v到w的(有向)路径和一条从w到v的(有向)路径，则图G中的两个顶点v和w在同一个强连通分量(scc)中。</li>
</ul>
</li>
</ul>
<h2 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h2><blockquote>
<p>Graphs can be given by adjacency matrix or adjacency list. </p>
</blockquote>
<ul>
<li><p>The adjacency matrix of a graph has value ai,j = 1 if vertices i and j share an edge; 0 otherwise. For a weighted graph, ai,j = wi,j, the weight of the edge. </p>
<ul>
<li>如果顶点i和j共用一条边，则图的邻接矩阵值为ai,j = 1;0。对于加权图，ai,j = wi,j，是边的权值。</li>
</ul>
</li>
<li><p>The adjacency list of a graph G = (V,E) is an array Adj[1..|V|] of lists, where Adj[v] is a list of all vertices adjacent to vertex v. </p>
<ul>
<li>图G = (V,E)的邻接表是一个数组Adj[1..|V|]的列表，其中Adj[V]是与顶点V相邻的所有顶点的列表。</li>
</ul>
</li>
</ul>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-08-15-15-25.png"> </p>
<ul>
<li><p>The adjacency matrix of a directed graph has value ai,j = 1 if [i, j] is an arc in the graph; 0 otherwise. For a weighted graph, ai,j = wi,j is the weight of the arc [i, j]. </p>
<ul>
<li>如果[i, j]是图中的弧，则有向图的邻接矩阵的值为ai,j = 1;0。对于加权图，ai,j = wi,j为弧[i, j]的权值。</li>
</ul>
</li>
<li><p>The adjacency list of a directed graph G = (V,E) is an array Adj[1..|V|] of lists, where Adj[v] is a list of all arcs form v. </p>
<ul>
<li>有向图G = (V,E)的邻接表是一个数组Adj[1..]|V|]的列表，其中Adj[V]是所有弧形成V的列表</li>
</ul>
</li>
</ul>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-086-03-05.png"> </p>
<h2 id="图的遍历（Traversing-a-graph）"><a href="#图的遍历（Traversing-a-graph）" class="headerlink" title="图的遍历（Traversing a graph）"></a>图的遍历（Traversing a graph）</h2><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><ul>
<li>Breadth-First-Search (BFS). Starting from a vertex s, traverse the graph vertices “level by level.”<ul>
<li>广度优先搜索(BFS)。从顶点s开始，逐层遍历图顶点。</li>
</ul>
</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BFS(G, s)  \\ Q is a queue</span><br><span class="line">1. for (each vertex v) color[v] = white;</span><br><span class="line">2. color[s] = gray; </span><br><span class="line">3. enqueue(Q, s); </span><br><span class="line">4. while (Q is not empty)</span><br><span class="line">      w = dequeue(Q);</span><br><span class="line">      for (each edge [w, v])</span><br><span class="line">        if (color[v] == white) </span><br><span class="line">           color[v] = gray; </span><br><span class="line">           enqueue(Q, s);</span><br><span class="line">      color[w] = black.</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p><strong>动画展示</strong></p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/20191127135310793.gif"> </p>
<h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><ul>
<li>Depth-First-Search (DFS). Starting from a vertex s, explore the graph vertices as far as possible before backing tracking<ul>
<li>深度优先搜索(DFS)。从一个顶点开始，在回溯跟踪之前尽可能地探索图的顶点</li>
</ul>
</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(v)</span><br><span class="line">1. color[v] = gray; </span><br><span class="line">2. for (each edge [v, w])</span><br><span class="line">        if (color[w] == white) </span><br><span class="line">           DFS(w); </span><br><span class="line">3. color[v] = black.</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">1. for (each vertex v) </span><br><span class="line">      color[v] = white;</span><br><span class="line">2. for (each vertex v)</span><br><span class="line">       if (color[v] == white) </span><br><span class="line">          DFS(v).   </span><br><span class="line">         </span><br></pre></td></tr></table></figure>

<ul>
<li>Running Time = O(m + n): </li>
<li>DFS(v) is called on each vertex exactly once.</li>
<li>Charge the time of DFS(v)  to the vertex v, not including the recursive calls DFS(w) in DFS(v).<ul>
<li>将DFS(v)的时间计费到顶点v，不包括DFS(v)中的递归调用DFS(w)。</li>
</ul>
</li>
</ul>
<p><strong>动画展示</strong></p>
<blockquote>
<p>递归方法：</p>
</blockquote>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/20191127135244696.gif"> </p>
<blockquote>
<p>非递归，利用了 栈 的思想</p>
</blockquote>
<p> <img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2019112716422925.gif"></p>
<blockquote>
<p>bfs 和 dfs的非递归遍历比较，可以看出，很相似，只不过一个用的栈一个用的队列</p>
</blockquote>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2021-12-0815-37-08.png"> </p>
<h2 id="DFS和DAG（有向无环图）"><a href="#DFS和DAG（有向无环图）" class="headerlink" title="DFS和DAG（有向无环图）"></a>DFS和DAG（有向无环图）</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>Topological Sorting</li>
<li>Given a directed graph G, order the vertices of G into an array T[1..n] such that if [T[i], T[j]] is an arc, then i &lt; j, or report no such an order exists.<ul>
<li>给定有向图G，将G的顶点排序到数组T[1..]n]这样，如果[T[i]， T[j]是一个弧，则i &lt; j，或报告不存在这样的顺序。</li>
</ul>
</li>
</ul>
<ul>
<li>拓扑排序是对DAG的顶点进行排序，使得对每一条有向边(u, v)，均有u（在排序记录中）比v先出现。亦可理解为对某点v而言，只有当v的所有源点均出现了，v才能出现。</li>
</ul>
<p>下图给出有向无环图的拓扑排序：</p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/399159-20151229144326901-1530781288.png"> </p>
<p>下图给出的顶点排序不是拓扑排序，因为顶点<code>D</code>的邻接点<code>E</code>比其先出现：</p>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/399159-20151229144340448-1796643731.png"> </p>
<blockquote>
<p>DFS判断是否有拓扑排序</p>
<ul>
<li>算法思想：</li>
<li>let [v, w] be an arc in G.</li>
<li>When we call DFS(v) on v, what is the color of w?<ul>
<li>当我们对v调用DFS(v)时，w的颜色是什么</li>
</ul>
</li>
<li>If color[w] = black, then w becomes black before v.<ul>
<li>如果color[w] = black，则w在v之前变为黑色。</li>
</ul>
</li>
<li>If color[w] = white, DFS(v) calls DFS(w), so w becomes black before v.<ul>
<li>如果color[w] = white, DFS(v)调用DFS(w)，那么w在v之前变成黑色。</li>
</ul>
</li>
<li>If color[w] = gray, then DFS(w) (recursively) calls DFS(v), so there is a path from w to v, which plus the arc [v, w] gives a cycle. So there is no topological order<ul>
<li>如果color[w] = gray，那么DFS(w)(递归地)调用DFS(v)，所以有一条从w到v的路径，加上弧[v, w]就得到一个循环。所以没有拓扑顺序</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(v)</span><br><span class="line">1. color[v] = gray; </span><br><span class="line">2. for (each arc [v, w])</span><br><span class="line">     if (color[w] == white) DFS(w)</span><br><span class="line">     else if (color[w] == gray)</span><br><span class="line">        Stop (“no topological order”); </span><br><span class="line">3. color[v] = black; T[t] = v; t = t - 1.</span><br><span class="line"></span><br><span class="line">T-Sort() \\ T[1..n] is the output array</span><br><span class="line">1. for (each vertex v) </span><br><span class="line">      color[v] = white;</span><br><span class="line">2. t = n; </span><br><span class="line">3. for (each vertex v)</span><br><span class="line">     if (color[v] == white) DFS(v).   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>附： 非DFS方法</p>
</blockquote>
<p>动画演示：</p>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/TopoSortIndegree.html">https://www.cs.usfca.edu/~galles/visualization/TopoSortIndegree.html</a></p>
<h3 id="寻找强连通分量"><a href="#寻找强连通分量" class="headerlink" title="寻找强连通分量"></a><strong>寻找强连通分量</strong></h3><h2 id="单源最短路径问题（Single-Source-Shortest-Path-Problem）"><a href="#单源最短路径问题（Single-Source-Shortest-Path-Problem）" class="headerlink" title="单源最短路径问题（Single-Source Shortest Path Problem）"></a>单源最短路径问题（Single-Source Shortest Path Problem）</h2><h3 id="Dijikstra算法"><a href="#Dijikstra算法" class="headerlink" title="Dijikstra算法"></a>Dijikstra算法</h3><ul>
<li><p>Problem. Given a weighted graph G and two vertices s and t in G, find a shortest path from s to t in G</p>
<ul>
<li>问题: 给定一个加权图G和G中的两个顶点s和t，找出G中s到t的一条最短路径</li>
</ul>
</li>
<li><p>Dijkstra’s Idea: start from the vertex s, gradually grow a tree rooted at s, by adding the vertex that currently “looks” the best</p>
<ul>
<li>Dijkstra的想法:从顶点s开始，通过添加当前看起来最好的顶点，逐渐生长出以s为根的树</li>
</ul>
</li>
</ul>
<blockquote>
<p>Dijkstra算法：</p>
</blockquote>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-1115-52-29.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, s, t)                                 complexity</span><br><span class="line">1. for (v=1; v≤n; v++) status[v] = unseen;           〇(n)</span><br><span class="line">2. status[s] = in-tree; dist[s] = 0;				 〇（1）</span><br><span class="line">3. for (each edge [s, w])							 〇（n）</span><br><span class="line">      status[w] = fringe; dad[w] = s;</span><br><span class="line">      dist[w] = wt(s, w);</span><br><span class="line">4. While (there are fringes)</span><br><span class="line">4.1   pick the fringe v of minimum dist[v];</span><br><span class="line">4.2   status[v] = in-tree;						   &lt;=n times</span><br><span class="line">4.3   for (each edge [v, w])						 〇（n）</span><br><span class="line">4.3.1   if (status[w] == unseen)					 〇（1）</span><br><span class="line">             status[w] = fringe; dad[w] = v; 		 〇（n）</span><br><span class="line">             dist[w] = dist[v] + wt(v, w);</span><br><span class="line">4.3.2   else if (status[w] == fringe) &amp; </span><br><span class="line">             (dist[w] &gt; dist[v] + wt(v, w))</span><br><span class="line">             dad[w] = v; </span><br><span class="line">             dist[w] = dist[v] + wt(v, w);</span><br><span class="line">5. The array dad[1..n] gives the path from s.  </span><br><span class="line">												Time= 〇(n^2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 如果使用 min-heap 来存储 fringe</p>
</blockquote>
<ol>
<li>RetrieveMin(H): find the minimum, and restore the heap; </li>
<li>Insert(H, v): add a new fringe v and restore the heap;</li>
<li>Delete(H, v): delete v and restore the heap.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FixHeap(H, t, i)</span><br><span class="line">1. h = i; </span><br><span class="line">2. if (h&gt;0 &amp; H[h]&lt;H[⌊(h-1)/2⌋]) </span><br><span class="line">      while (h&gt;0 &amp; H[h]&lt;H[⌊(h-1)/2⌋]) </span><br><span class="line">         H[h] ↔ H[⌊(h-1)/2⌋];</span><br><span class="line">         h = ⌊(h-1)/2⌋</span><br><span class="line">    else</span><br><span class="line">      while (2h+1 ≤ t)</span><br><span class="line">         if (2h+1=t or H[2h+1]&lt;H[2h+2])</span><br><span class="line">            g = 2h+1;</span><br><span class="line">         else g = 2h+2;</span><br><span class="line">         if (H[h] &gt; H[g])</span><br><span class="line">            H[h] ↔ H[g];</span><br><span class="line">            h = g; </span><br><span class="line">         else break.                       time = 〇（log n）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RerieveMin(H, t)</span><br><span class="line">\\ get the minimum &amp; delete</span><br><span class="line">\\ it from the heap H[0..t]</span><br><span class="line">1. min = H[0]; </span><br><span class="line">2. H[0] = H[t]; t = t – 1;</span><br><span class="line">3. FixHeap(H, t, 0);</span><br><span class="line">4. output(min).                            time = 〇（log n）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Insert(H, t, v)</span><br><span class="line">\\ insert value v into</span><br><span class="line">\\ the heap H[0..t].</span><br><span class="line">1. t = t + 1;</span><br><span class="line">2. H[t] = v; </span><br><span class="line">3. FixHeap(H, t, t).				   	   time = 〇（log n）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Delete(H, t, i)</span><br><span class="line">\\ delete H[i] from</span><br><span class="line">\\ the heap H[0..t].</span><br><span class="line">1. H[i] = H[t];</span><br><span class="line">2. t = t - 1; </span><br><span class="line">3. FixHeap(H, t, i).                       time = 〇（log n）</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-116-20-00.png">   </p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, s, t)</span><br><span class="line">1. for (v=1; v≤n; v++) status[v] = unseen;</span><br><span class="line">2. status[s] = in-tree; dist[s] = 0; H = Φ;</span><br><span class="line">3. for (each edge [s, w])</span><br><span class="line">      status[w] = fringe; dad[w] = s;</span><br><span class="line">      dist[w] = wt(s, w); Insert(H, w); </span><br><span class="line">4. While (there are fringes)</span><br><span class="line">4.1   v = RetrieveMin(H);</span><br><span class="line">4.2   status[v] = in-tree;</span><br><span class="line">4.3   for (each edge [v, w])</span><br><span class="line">4.3.1   if (status[w] == unseen)</span><br><span class="line">             status[w] = fringe; dad[w] = v; </span><br><span class="line">             dist[w] = dist[v] + wt(v, w); </span><br><span class="line">             Insert(H, w);</span><br><span class="line">4.3.2   else if (status[w] == fringe) &amp;    </span><br><span class="line">             Delete(H, w); dad[w] = v;</span><br><span class="line">             dist[w] = dist[v] + wt(v, w);</span><br><span class="line">             Insert(H, v);</span><br><span class="line">5. The array dad[1..n] gives the path from s.         </span><br><span class="line"></span><br><span class="line">Time= 〇（m log n）</span><br></pre></td></tr></table></figure>





<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>如果图上出现了负的权值，那么使用dijikstra算法就会出错，这里介绍另外一个算法：</p>
<ul>
<li>Theorem. If there is no negative cycles in the graph G, then for a vertex v to which a shortest path from s consists of k edges, after at most k iterations of step 3, dist[v] becomes the length of the shortest path from s to v. <ul>
<li>如果图 G 中不存在负环，则对于从 s 到t的最短路径由 k 条边组成的顶点 v，经过步骤 3 的最多 k 次迭代，dist[v] 变为从 s 到t的最短路径的长度v.</li>
</ul>
</li>
</ul>
<ul>
<li>Therefore, n-1 iterations of step 3 will be sufficient to find a shortest path to every vertex from s. <ul>
<li>因此，第3步的n-1次迭代将足以找到从s到每个顶点的最短路径。</li>
</ul>
</li>
</ul>
<p>TIps：The problem is meaningful only for directed graphs with no negative cycles.</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Bellman-Ford(G, s, t)</span><br><span class="line">1. for (v=1; v≤n; v++) dist[v] = ∞;</span><br><span class="line">2. dist[s] = 0;</span><br><span class="line">3. loop n-1 times</span><br><span class="line">      for (each edge [v, w])</span><br><span class="line">         if (dist[w] &gt; dist[v] + wt(v, w))   </span><br><span class="line">                 dad[w] = v;</span><br><span class="line">                 dist[w] = dist[v] + wt(v, w);</span><br><span class="line">4. for (each edge [v, w])</span><br><span class="line">         if (dist[w] &gt; dist[v] + wt(v, w))   </span><br><span class="line">                 stop(“negative cycle”); </span><br><span class="line">5. The array dad[1..n] gives the path from s. </span><br></pre></td></tr></table></figure>





<h2 id="多源最短路径问题（All-Pairs-Shortest-Paths-Problem）"><a href="#多源最短路径问题（All-Pairs-Shortest-Paths-Problem）" class="headerlink" title="多源最短路径问题（All-Pairs Shortest Paths Problem）"></a>多源最短路径问题（All-Pairs Shortest Paths Problem）</h2><ul>
<li>Problem. Given a (possibly negatively) weighted graph G in an adjacency matrix M, find the shortest path from s to t for all vertex pairs (s, t). <ul>
<li>问题： 给定邻接矩阵M中的一个(可能是负的)加权图G，找出所有顶点对(s, t)，从s到t的最短路径。</li>
<li>即给定任意两个点，一个出发点，一个到达点，求这两个点的之间的最短路径，就是任意两点最短路径问题，多源最短路径</li>
</ul>
</li>
</ul>
<blockquote>
<p>Fyd</p>
</blockquote>
<h2 id="最小生成树Minimun-Spanning-Tree"><a href="#最小生成树Minimun-Spanning-Tree" class="headerlink" title="最小生成树Minimun Spanning Tree"></a>最小生成树Minimun Spanning Tree</h2><blockquote>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=9147041630400351432&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=9147041630400351432&amp;spm_id_from=333.337.0.0</a></p>
</blockquote>
<ul>
<li>Definition. Let G be a weighted graph. A spanning tree of G is a subgraph of G that is a tree and contains all vertices of G. The weight of a spanning tree T is the sum of weights of edges in T. <ul>
<li>定义。设G是一个加权图。G的生成树是G的一个子图，它是一棵树，包含G的所有顶点。生成树T的权值是T中各边的权值之和</li>
</ul>
</li>
<li>MST Problem. Given a weighted and undirected graph G, construct a minimum spanning tree of G, i.e., a spanning tree of G whose weight is the smallest over all spanning trees of G. <ul>
<li>MST的问题。给定一个加权无向图G，构造G的最小生成树，即G的所有生成树中权值最小的生成树。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Dijkstra’s approach</p>
<ul>
<li>starting from any vertex s, grow a tree using the lightest edges</li>
</ul>
</blockquote>
<p><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-1115-52-29.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Prim(G)</span><br><span class="line">1. for (v=1; v≤n; v++) status[v] = unseen;</span><br><span class="line">2. pick any vertex s; status[s] = in-tree; </span><br><span class="line">3. for (each edge [s, w])</span><br><span class="line">      status[w] = fringe; dad[w] = s;</span><br><span class="line">      WEIGHT[w] = wt(s, w);</span><br><span class="line">4. While (there are fringes)</span><br><span class="line">4.1   pick the fringe v of minimum WEIGHT[v];</span><br><span class="line">4.2   status[v] = in-tree;</span><br><span class="line">4.3   for (each edge [v, w])</span><br><span class="line">4.3.1   if (status[w] == unseen)</span><br><span class="line">             status[w] = fringe; dad[w] = v; </span><br><span class="line">             WEIGHT[w] = wt(v, w);</span><br><span class="line">4.3.2   else if (status[w] == fringe) &amp; </span><br><span class="line">             (WEIGHT[w] &gt; wt(v, w))</span><br><span class="line">             dad[w] = v; </span><br><span class="line">             WEIGHT[w] = wt(v, w);</span><br><span class="line">5. The array dad[1..n] gives the path from s.      </span><br></pre></td></tr></table></figure>



<blockquote>
<p>Kruskal’s approach</p>
<ul>
<li>Idea: repeatedly add the lightest edges to make a connected and acyclic graph that covers all vertices (i.e., a spanning tree).</li>
<li>重复添加最轻的边，生成一个覆盖所有顶点的连通无环图(即生成树)</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Kruskal(G)</span><br><span class="line">1. sort the edges in nondecreasing order: </span><br><span class="line">      e1, e2, …, em;</span><br><span class="line">2. T = Φ;</span><br><span class="line">3. for (i = 1; i &lt;= m; i++) </span><br><span class="line">       let ei = [ui, vi]; </span><br><span class="line">       if (T + ei does not contain a cycle)</span><br><span class="line">           T = T + ei;</span><br><span class="line">4. return(T).</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Questions:</p>
</blockquote>
<ol>
<li><p>How do we represent T so that we can test efficiently if T + ei contains a cycle?</p>
<p>我们如何表示T以便我们能有效地测试T + ei是否包含一个循环</p>
<p>Q1: Since T is acyclic, a component of T is a tree. Thus, adding an edge to the same component makes a cycle while adding an edge connecting two different components does not make a cycle. Thus, for the edge to be added, we only need to check if its two ends are in the same component.</p>
<p>因为T是无环的，所以T的一个分量就是树。因此，向同一个组件添加一条边构成一个循环，而向两个不同组件添加一条边则不构成一个循环。因此，对于要添加的边，我们只需要检查它的两端是否在同一个组件中。</p>
</li>
</ol>
<ul>
<li>We represent each component of T in a tree structure so that we can test if the two ends of an edge are in the component. 我们用树形结构表示T的每个分量，这样我们就可以测试一条边的两端是否在这个分量中</li>
</ul>
<h2 id="图匹配问题（Graph-Matching-（on-undirected-graph））"><a href="#图匹配问题（Graph-Matching-（on-undirected-graph））" class="headerlink" title="图匹配问题（Graph Matching （on undirected graph））"></a>图匹配问题（Graph Matching （on undirected graph））</h2><p>在无向图中匹配的定义：</p>
<ul>
<li>Definition. An edge set M in an undirected graph G is a matching in G if no two edges in M share a common end<ul>
<li>定义。如果无向图G中没有两条边共用一个端点，则无向图G中的边集M就是一个匹配</li>
<li><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-124-18-54.png">  </li>
</ul>
</li>
</ul>
<blockquote>
<p>The Maximum Matching Problem.</p>
<p>最大匹配问题</p>
<ul>
<li>Given an undirected graph G, construct a maximum matching in G.</li>
<li>给出一个无向图G，构造一个最大匹配。</li>
</ul>
</blockquote>
<ul>
<li><p>Definitions. M: a matching in G. A vertex is matched if it is an end of an edge in M, otherwise, unmatched.</p>
<ul>
<li>定义。如果一个顶点是M中某条边的末端，那么它就被匹配，否则就是不匹配。</li>
</ul>
</li>
<li><p>Definition. An augmenting path (w.r.t a matching M) starts and ends at unmatched vertices and goes alternatively with edges not in M and in M</p>
<ul>
<li>定义。一条增广路径(w.r.t，匹配M)开始和结束于不匹配的顶点，并交替地到达不在M和M中的边</li>
<li><img src="/2021/12/07/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/2022-01-14-19-39.png">  </li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Theorem. A matching M is maximum if and only if there is no augmenting path w.r.t. M in G. <ul>
<li>定理。当且仅当G中没有增广路径w.r.t. M时，匹配的M是最大的。</li>
</ul>
</li>
<li>Proof. If M is max, then there is no augmenting path  otherwise, we would be able to construct a larger matching.<ul>
<li>证明。如果M是最大值，那么就没有增广路径，否则我们就可以构造一个更大的匹配。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>Finding an augmenting path:  start from an unmatched vertex, try to find an augmenting path ending at another unmatched vertex.</p>
<ul>
<li>寻找增广路径:从一个不匹配的顶点开始，尝试找到一个在另一个不匹配的顶点结束的增广路径。</li>
</ul>
</li>
<li><p>Pretty much similar to BFS but: at even levels, expand all possible ways, but at odd levels, expand on a single matching edge.</p>
<ul>
<li>与BFS非常相似，但是:在偶数层，扩展所有可能的方式，但在奇数层，扩展单个匹配边。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Augment(G, M) \\ Q is a queue</span><br><span class="line">1. for (each vertex v of G) level[v] = -1; </span><br><span class="line">2. for (each unmatched vertex v)</span><br><span class="line">       level[v] = 0; dad[v] = -1; Q ← v; </span><br><span class="line">3. while (Q ≠ Φ)</span><br><span class="line">      v ← Q; </span><br><span class="line">      if (level[v] is even)</span><br><span class="line">         for (each edge [v, w]) </span><br><span class="line">            if (level[w] == -1)</span><br><span class="line">               level[w] = level[v]+1; </span><br><span class="line">               dad[w] = v;  Q ← w; </span><br><span class="line">            else if (level[v] == level[w]) </span><br><span class="line">               return an augmenting path;</span><br><span class="line">      else \\ level[v] is odd</span><br><span class="line">         let [v, w] be the edge in M;</span><br><span class="line">         if (level[v] == level[w]) </span><br><span class="line">            return an augmenting path;</span><br><span class="line">         else level[w] = level[v]+1; </span><br><span class="line">                dad[w] = v;  Q ← w; </span><br><span class="line">4. Return (false)</span><br><span class="line"> </span><br><span class="line"> Time=〇（n+m）</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0-%E7%AE%97%E6%B3%95/" rel="tag"># 学习, 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/06/2021%E5%B9%BF%E5%B7%9E%E8%8D%89%E8%8E%93%E9%9F%B3%E4%B9%90%E8%8A%82/" rel="prev" title="2021广州草莓音乐节">
      <i class="fa fa-chevron-left"></i> 2021广州草莓音乐节
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/14/%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E4%B8%8E%E5%9B%BE%E6%90%9C%E7%B4%A2/" rel="next" title="搜索问题与图搜索">
      搜索问题与图搜索 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.</span> <span class="nav-text">排序算法回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.1.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FixHeap"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">FixHeap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SortHeap"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">SortHeap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MakeHeap"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">MakeHeap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Main"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">Main()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">算法动图演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88Sorting-in-Linear-Time%EF%BC%89"><span class="nav-number">1.0.2.</span> <span class="nav-text">线性时间排序（Sorting in Linear Time）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Courting-Sort%EF%BC%89"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">计数排序（Courting Sort）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">基数排序（Radix Sort）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88Bucket-sort%EF%BC%89"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">桶排序（Bucket sort）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E8%BF%B0%E4%B8%89%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">上述三种排序算法小结：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA%E9%83%A8%E5%88%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">图论部分算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">一些容易忘记的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">图的表示方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88Traversing-a-graph%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">图的遍历（Traversing a graph）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">广度优先遍历（BFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">深度优先遍历（DFS）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS%E5%92%8CDAG%EF%BC%88%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">DFS和DAG（有向无环图）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">2.4.2.</span> <span class="nav-text">寻找强连通分量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88Single-Source-Shortest-Path-Problem%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">单源最短路径问题（Single-Source Shortest Path Problem）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijikstra%E7%AE%97%E6%B3%95"><span class="nav-number">2.5.1.</span> <span class="nav-text">Dijikstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">2.5.2.</span> <span class="nav-text">Bellman-Ford算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88All-Pairs-Shortest-Paths-Problem%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">多源最短路径问题（All-Pairs Shortest Paths Problem）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Minimun-Spanning-Tree"><span class="nav-number">2.7.</span> <span class="nav-text">最小生成树Minimun Spanning Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%EF%BC%88Graph-Matching-%EF%BC%88on-undirected-graph%EF%BC%89%EF%BC%89"><span class="nav-number">2.8.</span> <span class="nav-text">图匹配问题（Graph Matching （on undirected graph））</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiayi Liang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiayi Liang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiayi Liang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
