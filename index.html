<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi8991.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="JiayiSpace">
<meta property="og:url" content="https://jiayi8991.github.io/index.html">
<meta property="og:site_name" content="JiayiSpace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jiayi Liang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiayi8991.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JiayiSpace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JiayiSpace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/11/03/Beamforming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/Beamforming/" class="post-title-link" itemprop="url">Beamforming Primer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-03 10:18:00" itemprop="dateCreated datePublished" datetime="2022-11-03T10:18:00+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-07 14:00:33" itemprop="dateModified" datetime="2022-11-07T14:00:33+08:00">2022-11-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​        波束合成（波束成形）是将来自一组小型无定向天线的无线电信号组合起来，以模拟大型定向天线。模拟天线可以通过电子化手段进行指向，尽管天线不会物理移动。在通信中，波束成形用于将天线指向信号源，以减少干扰并提高通信质量。在测向（direction finding）应用中，波束成形可用于操纵天线以确定信号源的方向。</p>
<h2 id="Antenna-Radiation-Patterns"><a href="#Antenna-Radiation-Patterns" class="headerlink" title="Antenna Radiation Patterns"></a>Antenna Radiation Patterns</h2><p>​        发射天线在某些方向上比其他方向产生更强的电磁波。场强与方向的关系图称为天线的 “辐射方向图”。接收与发射始终相同。</p>
<p>​        在远离天线的一点处测得的电磁波是来自天线所有部分的辐射的总和。天线的每个小部分都辐射不同幅度和相位的波，并且这些波中的每一个都传播到接收器所在的点的不同距离。在某些方向上，这些波以建设性的方式添加以获得增益（gain）。在某些方向上，它们会破坏性地添加以造成损失（loss）。</p>
<p>​        半波偶极子是一种简单的天线，由半波长的电线组成，在中心切割以连接电缆。下图显示了它的辐射模式。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-112518.png">   </p>
<h2 id="Directional-Antenna"><a href="#Directional-Antenna" class="headerlink" title="Directional Antenna"></a>Directional Antenna</h2><p>​        定向天线是一种设计为在一个方向上具有增益而在另一个方向上具有损耗的天线。通过增加天线的尺寸来定向天线。这样可以将天线的辐射导体扩展到更大的距离，从而可以更好地控制相长干扰和相消干扰，以提供定向辐射方向图。</p>
<p>​        简单地说，碟形卫星天线可以被认为是一个圆形表面，它从所有部分均等地辐射电磁波。如下图所示，它的中心 “光束” 高增益，对准卫星。随着碟形直径 (波长) 的增加，中心光束变窄。请注意，在中心梁的任一侧都有较小的光束，称为 “旁瓣”。信号强度为零的方向称为 “NULL”。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-112800.png">   </p>
<h2 id="Linear-Arrays"><a href="#Linear-Arrays" class="headerlink" title="Linear Arrays"></a>Linear Arrays</h2><p>​        一个简单的定向天线由一个小型辐射天线元件的线性阵列组成，每个天线元件都来自一个发射器的相同信号 (相同的幅度和相位)。随着阵列总宽度的增加，中心光束变得更窄。随着元素数量的增加，旁瓣变小。</p>
<p>​        下图是间隔1/2波长的4个元件 (小天线) 的线的辐射方向图。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-113035.png">  </p>
<p>​        如果间隔增加到大于1/2波长，则大的旁瓣开始出现在辐射图案中。但是，由于天线的总长度增加了，中心波束变窄了。对于间隔为1个波长的4个元素，以下辐射图说明了这一点。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-113217.png">  </p>
<p>​        通过保持总长度相同，并添加元素以减小间隔回到1/2波长，减小了旁瓣。以下是辐射方向图，如果在上面的天线上增加了3个元素以减小元素间距。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-120943.png">  </p>
<h2 id="Electronically-Steered-Arrays"><a href="#Electronically-Steered-Arrays" class="headerlink" title="Electronically Steered Arrays"></a>Electronically Steered Arrays</h2><p>​        通过改变线性阵列中元素的信号相位，可以操纵其主光束。控制信号相位的最简单方法是系统地改变元件的电缆长度。电缆延迟信号，从而移相。但是，这不允许动态操纵天线。</p>
<p>​        在电子控制阵列中，可编程电子移相器用于阵列中的每个元件。通过为每个元件编程所需的相移值来操纵天线。下面的光束图案用于8元素线性阵列，每个元素具有0.7 π 的渐进相移。中央光束已向左转向约45度。2π 的相移对应于一个波长或一个载波周期，更多的正值等价于说信号更早地传输。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-122006.png">  </p>
<p><img src="/2022/11/03/Beamforming/WX20221104-122121.png">  </p>
<h2 id="Array-Configurations"><a href="#Array-Configurations" class="headerlink" title="Array Configurations"></a>Array Configurations</h2><p>​        天线阵列不需要是线性的。通常，天线元件排列成圆形，以便阵列可以在所有方向上同样良好地形成波束。在车辆上，天线元件可以放置在任何方便的位置和不同的高度以形成3维阵列。对于这些阵列，确定控制天线的相移比线性阵列更复杂。</p>
<h2 id="Beamforming"><a href="#Beamforming" class="headerlink" title="Beamforming"></a>Beamforming</h2><p>​        在波束成形中，每个天线元件的幅度和相位都受到控制。与单独的相位控制相比，可以使用组合的幅度和相位控制来更好地调节旁瓣电平和转向零。每个天线的组合相对幅度a<sub>k</sub>和相移 θ<sub>k</sub>称为 “复数权重 ( complex weight ) ”，并由复数常数w<sub>k</sub>表示 (对于第k个天线)。</p>
<p>​        无线电发射机的波束形成器将复权重应用于天线阵列的每个元件的发射信号 (移相并设置幅度)。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-144741.png">  </p>
<p>​        用于无线电接收的波束形成器将复数权重施加到来自每个天线元件的信号，然后将所有信号求和为具有所需方向图的信号。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-144839.png">  </p>
<h2 id="Digital-Beamforming"><a href="#Digital-Beamforming" class="headerlink" title="Digital Beamforming"></a>Digital Beamforming</h2><p>​        在数字波束成形中，每个天线元件的相移和幅度缩放以及用于接收的求和操作都是数字完成的。使用通用DSP或专用波束形成芯片。</p>
<p>​        本讨论的其余部分集中在波束成形接收器上。数字处理要求使用A/D转换器将来自每个天线元件的信号数字化。由于高于短波频率 (&gt;30 MHz) 的无线电信号太高，无法以合理的成本直接数字化，因此数字波束成形接收器使用模拟 “RF转换器” 在A/D转换器之前将信号频率向下移位。下图显示了将整个蜂窝电话上行链路频带以824-849 MHz向下移动到1-26 MHz范围的转换器。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-184055.png">  </p>
<p>一旦天线信号被数字化，它们就被传递到 “数字下变频器”，该变频器将无线电信道的中心频率降低到0Hz，并且仅通过一个信道所需的带宽。下变频器以低采样率产生 “正交” 基带输出。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-184133.png">  </p>
<p>正交基带i和q分量可用于将无线电信号表示为具有实部和虚部的复矢量 (相量)。需要两个分量，以便可以表示正频率和负频率 (相对于信道中心频率)。</p>
<p>s(t) = x(t) + j y(t)<br>s(t) is the complex baseband signal<br>x(t) = i(t) is the real part<br>y(t) = -q(t) is the imaginary part<br>j is √(-1)</p>
<p>对于波束成形，将复杂的基带信号乘以复杂的权重，以应用每个天线元件所需的相移和幅度缩放。</p>
<p>wk= ak ejsin(θk)<br>wk= ak cos(θk) + j ak sin(θk)<br>wk is complex weight for the kth antenna element<br>ak is the relative amplitude of the weight<br>θk is the phase shift of the weight</p>
<p>通用DSP可以实现每个天线元件的复乘法:</p>
<p>sk(t) wk = ak{ [xk(t) cos(θk) - yk(t) sin(θk)] + j [xk(t) sin(θk) + yk(t) cos(θk)] }</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-184544.png">  </p>
<p>下图显示了一个完整的数字波束形成接收器。许多波束形成器可以共享一组天线元件，RF转换器和A/D转换器。所有RF转换器和A/D转换器共享公共振荡器，因此它们都产生相同的信号相移。在数字波束形成器中，所有数字下变频器共享一个公共时钟，并设置为相同的中心频率和带宽，并且它们的数字本地振荡器是同相的，因此所有相移都是相同的。每个DDC的基带输出乘以其天线元件的复权重，并将结果求和以产生一个具有方向特性的基带信号。然后，解调器将跟随从无线电信号中恢复信息。</p>
<p><img src="/2022/11/03/Beamforming/WX20221104-184624.png">  </p>
<h2 id="Adaptive-Beamforming"><a href="#Adaptive-Beamforming" class="headerlink" title="Adaptive Beamforming"></a>Adaptive Beamforming</h2><p>仔细选择天线元件的复数权重w<sub>k</sub>，以在天线阵列的辐射方向图中给出所需的峰值和零点。在简单的情况下，可以选择权重以在某个方向上给出一个中心光束，如在测向应用中那样。然后可以缓慢地改变权重以操纵光束，直到出现最大信号强度并找到到信号源的方向。</p>
<p>在用于通信的波束成形中，选择权重以给出使接收信号质量最大化的辐射方向图。通常，模式中的峰值指向信号源，并在干扰源和信号反射的方向上创建空值。</p>
<p>自适应波束形成是动态更改复杂权重以最大程度地提高通信信道质量的过程。以下是一些常用的方法:</p>
<p>​    最小均方误差            接收器已知所需接收信号波形的形状。调整复数权重以最小化波束形成器输出和预期信号波形之间的均方误差。</p>
<p>​    最大信号干扰比        在接收机可以估计所需信号和干扰信号的强度的情况下，调整权重以使比率最大化。</p>
<p>​    最小方差        当信号形状和源方向都已知时，选择权重以最小化波束形成器输出上的噪声。</p>
<p>通常，在自适应波束形成器上设置约束，以使复权重在较差的信号条件下不会随机变化。一些无线电信号包括 “训练序列”，以便自适应波束形成器可以在传输有用信息之前快速优化其辐射方向图。</p>
<h2 id="Smart-Antennas"><a href="#Smart-Antennas" class="headerlink" title="Smart Antennas"></a>Smart Antennas</h2><p>用于通信的自适应波束形成系统有时被称为 “智能天线” 系统。对于蜂窝电话，一个具有智能天线系统的基站可以通过在每个用户处操纵单个天线波束，在相同的频率上支持多个用户，只要他们在不同的方向上。这有时被称为 “空间域多址” (SDMA)。据估计，通过使用智能天线，蜂窝电话系统的容量可以增加一倍。</p>
<h2 id="FFT’s-in-Beamforming"><a href="#FFT’s-in-Beamforming" class="headerlink" title="FFT’s in Beamforming"></a>FFT’s in Beamforming</h2><p>在数字波束形成中，许多波束形成器可以共享一组天线元件，rf转换器和A/D转换器。波束形成器的中心光束可能指向不同的方向。在必须同时形成一组固定的非重叠波束 (雷达，声纳，测向) 的情况下，FFT可以有效地实现许多波束形成器。</p>
<p>下图显示了具有N个天线元件的FFT波束形成器。每个元素都需要一个数字下变频器。所有DDC同时产生一个基带样本，并且所有这些都一次传递给N点复数FFT。然后，FFT产生一组N个复数输出，每个输出都是不同光束的下一个基带样本。</p>
<p><img src="/2022/11/03/Beamforming/WX20221107-112040.png"></p>
<p>在这种情况下，正在执行 “空间FFT”: FFT正在处理在空间中 (不是在时间中) 分离的一组样本。因此，它的输出是一组在方向上 (而不是在频率上) 分离的样本。</p>
<p>如上所示的FFT波束形成不灵活。对于线性阵列，N束是固定的，并且在方向上等距。它们的范围从阵列的宽边到-90度到90度。光束是正交的: 任何光束的中心峰在所有其他光束上都处于零值。这样的一组波束对雷达测绘很有用，但对通信不太有用。</p>
<p>可以在通信中使用FFT进行波束形成。可以像以前一样使用复杂的权重和总和来组合一组FFT输出，以形成任意的辐射方向图。这被称为 “波束空间波束形成”。先前组合来自不同天线元件的基带信号的方法被称为 “单元空间波束形成”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">天线的基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-02 15:36:30" itemprop="dateCreated datePublished" datetime="2022-11-02T15:36:30+08:00">2022-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-03 10:17:26" itemprop="dateModified" datetime="2022-11-03T10:17:26+08:00">2022-11-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="无线电波的基本知识"><a href="#无线电波的基本知识" class="headerlink" title="无线电波的基本知识"></a>无线电波的基本知识</h1><p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/WX20221102-153816.png"> </p>
<p>无线电波和光波一样，传播速度和传播媒介有关，公式为 <strong>V = C/（e）<sup>1/2</sup></strong> , 其中 e 为传播媒介的相对介电常数，同时在传播中波也会衰弱，就像池塘中的涟漪</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png">  </p>
<blockquote>
<p>波长，频率 和 传播速度</p>
<p>​    <strong>波长 = 传播速度 / 频率</strong> </p>
<p>因此同一频率的无线电波在不同的传播媒介中时，速度不同，因此波长不同</p>
</blockquote>
<h2 id="极化（polarisation）"><a href="#极化（polarisation）" class="headerlink" title="极化（polarisation）"></a>极化（polarisation）</h2><p>​        天线极化是描述天线辐射电磁波矢量空间指向的参数。由于电场与磁场有恒定的关系，故<strong>一般都以电场矢量的空间指向</strong>作为天线辐射电磁波的<strong>极化方向</strong>。</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png">  </p>
<h3 id="极化的类型"><a href="#极化的类型" class="headerlink" title="极化的类型"></a>极化的类型</h3><p>​        表征均匀平面波的电场矢量（或磁场矢量）在空间指向变化的性质，通过一给定点上正弦波的电场矢量E末端的轨迹来具体说明。光学上称之为偏振。按电场矢量轨迹的特点它可分为 <em>线极化、圆极化 和 椭圆极化</em> 三种。</p>
<p>​        线极化：电场矢量在空间的取向固定不变的电磁波叫线极化。有时以地面为参数，电场矢量方向与地面平行的叫水平极化，与地面垂直的叫垂直极化。<strong>电场矢量与传播方向构成的平面</strong>叫<strong>极化平面</strong>。垂直极化 和 水平极化波 需要用具有垂直特性 和 水平特性的天线来接收。</p>
<p>​        圆极化：当无线电波的极化面与大地法线面之间的夹角从0~360度周期地变化，即电场大小不变，方向随时间变化，电场矢量末端的轨迹在垂直于传播方向的平面上投影是一个圆时，称为圆极化。在电场的水平分量和垂直分量振幅相等，相位相差90度或270度时，可以得到圆极化。圆极化，若极化面随时间旋转并与电磁波传播方向成右螺旋关系，称右圆极化；反之，若成左螺旋关系，称左圆极化。</p>
<p>​        椭圆极化：若Ex和Ey幅度和相位差均不满足上述条件时，合成矢量端点的轨迹为一个椭圆。椭圆极化波的椭圆长短轴之比，称为轴比，当椭圆的轴比等于1，椭圆极化波即是圆极化波。当轴比为无穷时，电波的极化为线极化。</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.png">  </p>
<p>  <img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.png">  </p>
<h3 id="极化损失"><a href="#极化损失" class="headerlink" title="极化损失"></a>极化损失</h3><p>​    当来波的极化方向与接收天线的极化方向不一致的时候，在接收过程中通常要产生极化损失，例如：当用圆极化天线接收任意线极化波，或用线极化天线接收任一圆极化波时，都要产生3分贝的极化损失，就是只能收到来波的一半能量</p>
<p>​        如若水平极化遇到垂直极化的接收天线，也就是他们是完全正交，接收天线完全接收不到来波的能量，那么称来波与接收天线极化是隔离的</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.png">  </p>
<h1 id="天线辐射电磁波的基本原理"><a href="#天线辐射电磁波的基本原理" class="headerlink" title="天线辐射电磁波的基本原理"></a>天线辐射电磁波的基本原理</h1><p>导线载有交变电流时，就可以形成电磁波的辐射，辐射的能力和导线的长短形状有关。比如下图中，两个导线距离很近，电场被束缚在两导线之间，故辐射微弱；导线张开，电场散播在周围空间，所以辐射增强。</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.png">   </p>
<p>天线有五个基本参数：方向性系数、天线效率、增益系数、辐射电阻和天线有效高度。这些参数是衡量天线质量好坏的重要指标。</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.png" style="zoom:67%;"><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.png" style="zoom: 67%;"></p>
<h2 id="对称振子（半波振子）"><a href="#对称振子（半波振子）" class="headerlink" title="对称振子（半波振子）"></a>对称振子（半波振子）</h2><p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.png">   </p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/WX20221102-172327.png">  </p>
<h2 id="天线的输入阻抗"><a href="#天线的输入阻抗" class="headerlink" title="天线的输入阻抗"></a>天线的输入阻抗</h2><blockquote>
<p>定义： <strong>天线输入端的信号电压与信号电流之比，称作天线的输入阻抗。</strong></p>
</blockquote>
<p>输入阻抗具有电阻分量 R 和 电抗分量 X， 即 Z = R + j * X。 电抗分量的存在会减少天线从馈线对信号功率的提取，所以应该尽可能使电抗分量为零。</p>
<p>一般，天线的输入阻抗是复数，实部称为输入电阻，以Ri表示；虚部称为输入电抗，以Xi表示。</p>
<h2 id="天线的方向性"><a href="#天线的方向性" class="headerlink" title="天线的方向性"></a>天线的方向性</h2><p>​        方向性是指天线在一定方向辐射电磁波的能力。对于接收天线来说，方向性表示天线对不同方向传来的电波所具有的接收能力。由方向图表示，如下</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.png">  </p>
<h2 id="天线增益（gain）"><a href="#天线增益（gain）" class="headerlink" title="天线增益（gain）"></a>天线增益（gain）</h2><p>​        天线增益是指：在输入功率相等的条件下，实际天线与理想的辐射单元在空间同一点处所产生的信号的功率密度之比。它定量的描述一个天线把输入功率集中辐射的程度。增益显然与天线方向图有密切的关系，方向图主瓣越窄，副瓣越小，增益越高。天线增益是用来衡量天线朝一个特定方向收发信号的能力，它是选择基站天线最重要的参数之一。</p>
<p>​        另外，表示天线增益的参数有dBd和dBi。dBi是相对于点源天线的增益，在各方向的辐射是均匀的；dBd相对于对称阵子天线的增益dBi=dBd+2.15。相同的条件下，增益越高，电波传播的距离越远。 </p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/WX20221102-175548.png">  </p>
<h2 id="带宽（天线的工作频率范围）"><a href="#带宽（天线的工作频率范围）" class="headerlink" title="带宽（天线的工作频率范围）"></a>带宽（天线的工作频率范围）</h2><p>​        无论是发射天线还是接收天线，他们总是在一定的频率范围内工作的，通常，工作在中心频率时天线所能输送的功率最大，偏离中心频率时它所输送的功率都将减小。据此可定义天线的频率带宽</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/WX20221102-180002.png">  </p>
<h2 id="波束宽度"><a href="#波束宽度" class="headerlink" title="波束宽度"></a>波束宽度</h2><p>​        有时也称波束宽度。系指方向性图的主瓣宽度。一般是指半功率波瓣宽度。</p>
<p>​        波瓣宽度是指天线方向图中低于主瓣峰值3dB处所形成的夹角宽度，又称波束宽度、主瓣宽度、半功率角，形成的夹角叫波瓣角。波瓣宽度分为水平波瓣宽度和垂直波瓣宽度，对应波瓣角也分为水平波瓣角和垂直波瓣角。波瓣宽度是定向天线常用的一个重要指标。</p>
<p><img src="/2022/11/02/%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/WX20221102-181604.png">  </p>
<p>​        波瓣宽度越窄，方向性越好，作用距离越远，抗干扰能力越强。</p>
<ul>
<li>覆盖时主要考虑主瓣，旁瓣通常会对周边区域形成干扰，一般应用中都要增强主瓣，抑制旁瓣。但在天线近点位置需要考虑借助旁瓣来消除覆盖盲区。</li>
<li>水平波瓣宽度（H－Plane Half Power beamwidth）决定了天线水平平面的波束宽度。宽度越宽，在扇区交界处的覆盖越好，但当提高天线倾角时，也越容易发生波束畸变，形成越区覆盖；反之宽度越窄，在扇区交界处覆盖就越差，提高天线倾角可以在一定程度上改善扇区交界处的覆盖，相对而言，不容易产生对其他小区的越区覆盖。市中心基站的站距小，天线倾角大，故应当采用水平波瓣宽度小的天线，郊区选用水平波瓣宽度大的天线。</li>
<li>垂直波瓣宽度（V－Plane Half Power beamwidth）决定了天线垂直平面的波束宽度。垂直波瓣宽度越窄，偏离主波束方向时信号衰减越快，就越容易通过调整天线倾角（即俯仰角）准确控制覆盖范围，进而达到改善小区覆盖质量的目的。</li>
</ul>
<h2 id="接收灵敏度"><a href="#接收灵敏度" class="headerlink" title="接收灵敏度"></a>接收灵敏度</h2><p>接收灵敏度是指无线设备正常工作所需的天线口最小信号接收功率。系统间的干扰会导致无线设备灵敏度的下降，影响信号的正常接收，因此通常以无线设备灵敏度准则作为被干扰系统的保护准则。</p>
<p>无线传输的接收灵敏度类似于人类的听力，在日常环境下，听力越好的人捕捉细小声音的能力越强。同理，无线设备接收灵敏度越高意味着可捕获弱信号的能力越强，若接收的信号能量小于它的接收灵敏度时，无线设备将不会接收到任何数据。</p>
<p>影响因素</p>
<ul>
<li>带宽范围内的热噪声。</li>
<li>系统的噪声系数。</li>
<li>系统分析信号时需要的最小信噪比。</li>
</ul>
<p>计算公式</p>
<p>S = 10lg(kTB)+ NF + SNR，即：接收灵敏度 = 10lg(带宽范围内的热噪声功率) + 系统噪声系数 + 解调所需信噪比。</p>
<ul>
<li>S：接收灵敏度，单位是dBm。接收灵敏度值越小，说明接收机的接收性能越好。接收灵敏度值越大，说明接收机的接收性能越差。</li>
<li>k：波尔兹曼常数，单位是J/K。</li>
<li>T：绝对温度，单位是K。环境温度越高，接收灵敏度就会变大，接收性能就会恶化，因此要尽量降低系统所在的环境温度。</li>
<li>B：信号带宽，单位是Hz。信号带宽越大，系统的噪声系数越大，灵敏度就会变大，接收性能也会恶化。</li>
<li>kTB：带宽范围内的热噪声功率，单位是W。</li>
<li>NF：系统噪声系数，单位是dB。</li>
<li>SNR：解调所需信噪比，单位是dB。解调所需的最小信噪比越小越好，这样可以增加系统的接收性能。最小信噪比要求和移动台的速度、所处的无线环境及所要求的通信质量有关，不同无线制式要求不同，同一无线制式的不同业务也不相同。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QE411979W/?spm_id_from=autoNext&amp;vd_source=fa800c4c8b55ad3e9b5e96670557580d">https://www.bilibili.com/video/BV1QE411979W/?spm_id_from=autoNext&amp;vd_source=fa800c4c8b55ad3e9b5e96670557580d</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ry4y1h7Ek/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=fa800c4c8b55ad3e9b5e96670557580d">https://www.bilibili.com/video/BV1ry4y1h7Ek/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=fa800c4c8b55ad3e9b5e96670557580d</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">傅里叶变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 10:42:28" itemprop="dateCreated datePublished" datetime="2022-08-30T10:42:28+08:00">2022-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-31 12:10:23" itemprop="dateModified" datetime="2022-08-31T12:10:23+08:00">2022-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="频域"><a href="#频域" class="headerlink" title="频域"></a>频域</h1><p>本文转载于：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19763358">https://zhuanlan.zhihu.com/p/19763358</a></p>
<p>李永乐讲的傅立叶变换：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A4411Y7vj?spm_id_from=333.337.search-card.all.click&amp;vd_source=fa800c4c8b55ad3e9b5e96670557580d">https://www.bilibili.com/video/BV1A4411Y7vj?spm_id_from=333.337.search-card.all.click&amp;vd_source=fa800c4c8b55ad3e9b5e96670557580d</a></p>
<blockquote>
<p>你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。</p>
</blockquote>
<p>从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。但如果我告诉你，用另一种方法来观察世界的话，你会发现世界是永恒不变的，你会不会觉得我疯了？我没有疯，这个静止的世界就叫做频域。</p>
<p>先举一个<strong>公式上并非很恰当</strong>，但意义上再贴切不过的例子：</p>
<p>在你的理解中，一段音乐是什么呢？</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/1.png">  </p>
<p>这是我们对音乐最普遍的理解，一个随着时间变化的震动。但我相信对于乐器小能手们来说，音乐更直观的理解是这样的：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/2.png">  </p>
<p>上图是音乐在时域的样子，而下图则是音乐在频域的样子。</p>
<p>将两个图进行简化：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/3.png">  </p>
<p>在时域，我们观察到钢琴的琴弦一会上一会下的摆动，就如同一支股票的走势；而在频域，只有那一个永恒的音符。</p>
<blockquote>
<p><strong>任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。</strong></p>
<p>在第一个例子里我们可以理解为，利用对不同琴键不同力度，不同时间点的敲击，可以组合出任何一首乐曲。</p>
</blockquote>
<p>而贯穿时域与频域的方法之一，就是传说中的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)，我们从简单的开始谈起。</p>
<h1 id="傅立叶级数-Fourier-Series-的频谱"><a href="#傅立叶级数-Fourier-Series-的频谱" class="headerlink" title="傅立叶级数(Fourier Series)的频谱"></a>傅立叶级数(Fourier Series)的频谱</h1><p>下面用一个例子来用正弦曲线波叠加出来一个带90度角的矩形波来，你会相信吗？你不会，就像当年的我一样。但是看看下图：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/4.png">  </p>
<p>第一幅图是一个郁闷的正弦波cos（x）</p>
<p>第二幅图是2个卖萌的正弦波的叠加cos(x)+a.cos(3x)</p>
<p>第三幅图是4个发春的正弦波的叠加</p>
<p>第四幅图是10个便秘的正弦波的叠加</p>
<p>随着正弦波数量逐渐的增长，他们最终会叠加成一个标准的矩形，大家从中体会到了什么道理？</p>
<p>（只要努力，弯的都能掰直！）</p>
<p>随着叠加的递增，所有正弦波中上升的部分逐渐让原本缓慢增加的曲线不断变陡，而所有正弦波中下降的部分又抵消了上升到最高处时继续上升的部分使其变为水平线。一个矩形就这么叠加而成了。但是要多少个正弦波叠加起来才能形成一个标准90度角的矩形波呢？不幸的告诉大家，答案是无穷多个。（上帝：我能让你们猜着我？）</p>
<p>不仅仅是矩形，你能想到的任何波形都是可以如此方法用正弦波叠加起来的。这是没<br>有接触过傅里叶分析的人在直觉上的第一个难点，但是一旦接受了这样的设定，游戏就开始有意思起来了。</p>
<p>还是上图的正弦波累加成矩形波，我们换一个角度来看看：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/5.png">  </p>
<p>在这几幅图中，最前面黑色的线就是所有正弦波叠加而成的总和，也就是越来越接近矩形波的那个图形。而后面依不同颜色排列而成的正弦波就是组合为矩形波的各个分量。这些正弦波按照频率从低到高从前向后排列开来，而每一个波的振幅都是不同的。一定有细心的读者发现了，每两个正弦波之间都还有一条直线，那并不是分割线，而是振幅为0的正弦波！也就是说，为了组成特殊的曲线，有些正弦波成分是不需要的。</p>
<p>这里，不同频率的正弦波我们成为频率分量。</p>
<p>如果我们把第一个频率最低的频率分量看作“1”，我们就有了构建频域的最基本单元。</p>
<p>对于我们最常见的有理数轴，数字“1”就是有理数轴的基本单元。</p>
<p>时域的基本单元就是“1秒”，如果我们将一个角频率为ω0的正弦波cos（ω0t）看作基础，那么频域的基本单元就是ω0。</p>
<p>有了“1”，还要有“0”才能构成世界，那么频域的“0”是什么呢？cos（0t）就是一个周期无限长的正弦波，也就是一条直线！所以在频域，0频率也被称为直流分量，在傅里叶级数的叠加中，它仅仅影响全部波形相对于数轴整体向上或是向下而不改变波的形状。</p>
<p>接下来，让我们回到初中，回忆一下已经死去的八戒，啊不，已经死去的老师是怎么定义正弦波的吧。</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/6.png">  </p>
<p>正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/Fourier_series_square_wave_circles_animation.gif">  <img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/Fourier_series_sawtooth_wave_circles_animation.gif">  </p>
<p>介绍完了频域的基本组成单元，我们就可以看一看一个矩形波，在频域里的另一个模样了：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/7.png">  </p>
<p>这就是矩形波在频域的样子，是不是完全认不出来了？教科书一般就给到这里然后留给了读者无穷的遐想，以及无穷的吐槽，其实教科书只要补一张图就足够了：频域图像，也就是俗称的频谱，就是——</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/8.png">  </p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/9.png">  </p>
<p>可以发现，在频谱中，偶数项的振幅都是0，也就对应了图中的彩色直线。振幅为0的正弦波。动态图片如下：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/Fourier_series_and_transform.gif">  </p>
<p>在讲相位谱之前，我们先回顾一下刚刚的这个例子究竟意味着什么。记得前面说过的那句“世界是静止的”吗？估计好多人对这句话都已经吐槽半天了。想象一下，世界上每一个看似混乱的表象，实际都是一条时间轴上不规则的曲线，但实际这些曲线都是由这些无穷无尽的正弦波组成。我们看似不规律的事情反而是规律的正弦波在时域上的投影，而正弦波又是一个旋转的圆在直线上的投影。那么你的脑海中会产生一个什么画面呢？</p>
<p>我们眼中的世界就像皮影戏的大幕布，幕布的后面有无数的齿轮，大齿轮带动小齿轮，小齿轮再带动更小的。在最外面的小齿轮上有一个小人——那就是我们自己。我们只看到这个小人毫无规律的在幕布前表演，却无法预测他下一步会去哪。而幕布后面的齿轮却永远一直那样不停的旋转，永不停歇。这样说来有些宿命论的感觉。说实话，这种对人生的描绘是我一个朋友在我们都是高中生的时候感叹的，当时想想似懂非懂，直到有一天我学到了傅里叶级数……</p>
<h1 id="傅立叶级数-Fourier-Series-的相位谱"><a href="#傅立叶级数-Fourier-Series-的相位谱" class="headerlink" title="傅立叶级数(Fourier Series)的相位谱"></a>傅立叶级数(Fourier Series)的相位谱</h1><p>上一章的关键词是：从侧面看。这一章的关键词是：从下面看。</p>
<p>在这一章最开始，我想先回答很多人的一个问题：傅里叶分析究竟是干什么用的？这段相对比较枯燥，已经知道了的同学可以直接跳到下一个分割线。</p>
<p>先说一个最直接的用途。无论听广播还是看电视，我们一定对一个词不陌生——频道。频道频道，就是频率的通道，不同的频道就是将不同的频率作为一个通道来进行信息传输。下面大家尝试一件事：</p>
<p>先在纸上画一个sin（x），不一定标准，意思差不多就行。不是很难吧。</p>
<p>好，接下去画一个sin（3x）+sin（5x）的图形。</p>
<p>别说标准不标准了，曲线什么时候上升什么时候下降你都不一定画的对吧？</p>
<p>好，画不出来不要紧，我把sin（3x）+sin（5x）的曲线给你，但是前提是你不知道这个曲线的方程式，现在需要你把sin（5x）给我从图里拿出去，看看剩下的是什么。这基本是不可能做到的。</p>
<p>但是在频域呢？则简单的很，无非就是几条竖线而已。</p>
<p>所以很多在时域看似不可能做到的数学操作，在频域相反很容易。这就是需要傅里叶变换的地方。尤其是从某条曲线中去除一些特定的频率成分，这在工程上称为滤波，是信号处理最重要的概念之一，只有在频域才能轻松的做到。</p>
<p>再说一个更重要，但是稍微复杂一点的用途——求解微分方程。（这段有点难度，看不懂的可以直接跳过这段）微分方程的重要性不用我过多介绍了。各行各业都用的到。但是求解微分方程却是一件相当麻烦的事情。因为除了要计算加减乘除，还要计算微分积分。而傅里叶变换则可以让微分和积分在频域中变为乘法和除法，大学数学瞬间变小学算术有没有。</p>
<p>傅里叶分析当然还有其他更重要的用途，我们随着讲随着提。</p>
<p>————————————————————————————————————</p>
<p>下面我们继续说相位谱：</p>
<p>通过时域到频域的变换，我们得到了一个从侧面看的频谱，但是这个频谱并没有包含时域中全部的信息。因为频谱只代表每一个对应的正弦波的振幅是多少，而没有提到相位。基础的正弦波A.sin(wt+θ)中，振幅，频率，相位缺一不可，不同相位决定了波的位置，所以对于频域分析，仅仅有频谱（振幅谱）是不够的，我们还需要一个相位谱。那么这个相位谱在哪呢？我们看下图，这次为了避免图片太混论，我们用7个波叠加的图。</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/10.png">  </p>
<p>鉴于正弦波是周期的，我们需要设定一个用来标记正弦波位置的东西。在图中就是那些小红点。小红点是距离频率轴最近的波峰，而这个波峰所处的位置离频率轴有多远呢？为了看的更清楚，我们将红色的点投影到下平面，投影点我们用粉色点来表示。当然，这些粉色的点只标注了波峰距离频率轴的距离，并不是相位。</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/11.png">  </p>
<p>这里需要纠正一个概念：时间差并不是相位差。如果将全部周期看作2Pi或者360度的话，相位差则是时间差在一个周期中所占的比例。我们将时间差除周期再乘2Pi，就得到了相位差。</p>
<p>在完整的立体图中，我们将投影得到的时间差依次除以所在频率的周期，就得到了最下面的相位谱。所以，频谱是从侧面看，相位谱是从下面看。</p>
<p>注意到，相位谱中的相位除了0，就是Pi。因为cos（t+Pi）=-cos（t），所以实际上相位为Pi的波只是上下翻转了而已。对于周期方波的傅里叶级数，这样的相位谱已经是很简单的了。另外值得注意的是，由于cos（t+2Pi）=cos（t），所以相位差是周期的，pi和3pi，5pi，7pi都是相同的相位。人为定义相位谱的值域为(-pi，pi]，所以图中的相位差均为Pi。</p>
<p>最后来一张大集合：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/12.png">  </p>
<h1 id="傅立叶变换-Fourier-Transformation"><a href="#傅立叶变换-Fourier-Transformation" class="headerlink" title="傅立叶变换(Fourier Transformation)"></a>傅立叶变换(Fourier Transformation)</h1><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/21.png" style="zoom:150%;">  

<p>实部为 频率的连续谱</p>
<p>虚部为 相位的连续谱</p>
<p>相信通过前面三章，大家对频域以及傅里叶级数都有了一个全新的认识。但是文章在一开始关于钢琴琴谱的例子我曾说过，这个栗子是一个公式错误，但是概念典型的例子。所谓的公式错误在哪里呢？</p>
<p>傅里叶级数的本质是将一个周期的信号分解成无限多分开的（离散的）正弦波，但是宇宙似乎并不是周期的。</p>
<p>比如傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。这句话比较绕嘴，实在看着费事可以干脆回忆第一章的图片。</p>
<p>而在我们接下去要讲的傅里叶变换，则是将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。</p>
<p>算了，还是上一张图方便大家理解吧：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/13.png">  </p>
<p>所以说，钢琴谱其实并非一个连续的频谱，而是很多在时间上离散的频率，但是这样的一个贴切的比喻真的是很难找出第二个来了。</p>
<p>因此在傅里叶变换在频域上就从离散谱变成了连续谱。那么连续谱是什么样子呢？</p>
<blockquote>
<p>你见过大海么？</p>
</blockquote>
<p>为了方便大家对比，我们这次从另一个角度来看频谱，还是傅里叶级数中用到最多的那幅图，我们从频率较高的方向看。</p>
<p>以上是离散谱，那么连续谱是什么样子呢？</p>
<p>尽情的发挥你的想象，想象这些离散的正弦波离得越来越近，逐渐变得连续……</p>
<p>直到变得像波涛起伏的大海：</p>
<p><img src="https://pic4.zhimg.com/ece53f825c6de629befba3de12f929a7_r.jpg" alt="img"></p>
<p>很抱歉，为了能让这些波浪更清晰的看到，我没有选用正确的计算参数，而是选择了一些让图片更美观的参数，不然这图看起来就像屎一样了。</p>
<p>不过通过这样两幅图去比较，大家应该可以理解如何从离散谱变成了连续谱的了吧？原来离散谱的叠加，变成了连续谱的累积。所以在计算上也从求和符号变成了积分符号。</p>
<p>不过，这个故事还没有讲完，接下去，我保证让你看到一幅比上图更美丽壮观的图片，但是这里需要介绍到一个数学工具才能然故事继续，这个工具就是——</p>
<h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>虚数i这个概念大家在高中就接触过，但那时我们只知道它是-1的平方根，可是它真正的意义是什么呢?</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/15.png">  </p>
<p>这里有一条数轴，在数轴上有一个红色的线段，它的长度是1。当它乘以3的时候，它的长度发生了变化，变成了蓝色的线段，而当它乘以-1的时候，就变成了绿色的线段，或者说线段在数轴上围绕原点旋转了180度。</p>
<p>我们知道乘-1其实就是乘了两次 i使线段旋转了180度，那么乘一次 i 呢——答案很简单——旋转了90度。</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/16.png">  </p>
<p>同时，我们获得了一个垂直的虚数轴。实数轴与虚数轴共同构成了一个复数的平面，也称复平面。这样我们就了解到，乘虚数i的一个功能——旋转。</p>
<p>现在，就有请宇宙第一耍帅公式欧拉公式隆重登场——</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/17.png">  </p>
<p>这个公式在数学领域的意义要远大于傅里叶分析，但是乘它为宇宙第一耍帅公式是因为它的特殊形式——当x等于Pi的时候。</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/18.png">  </p>
<p>这个公式关键的作用，是将正弦波统一成了简单的指数形式。我们来看看图像上的含义：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/19.png">   </p>
<p>欧拉公式所描绘的，是一个随着时间变化，在复平面上做圆周运动的点，随着时间的改变，在时间轴上就成了一条螺旋线。如果只看它的实数部分，也就是螺旋线在左侧的投影，就是一个最基础的余弦函数。而右侧的投影则是一个正弦函数。</p>
<h1 id="指数形式的傅立叶变换"><a href="#指数形式的傅立叶变换" class="headerlink" title="指数形式的傅立叶变换"></a>指数形式的傅立叶变换</h1><p>有了欧拉公式的帮助，我们便知道：<strong>正弦波的叠加</strong>，也可以理解为<strong>螺旋线的叠加</strong>在实数空间的投影。而螺旋线的叠加如果用一个形象的栗子来理解是什么呢？</p>
<p><strong>光波</strong></p>
<p>高中时我们就学过，自然光是由不同颜色的光叠加而成的，而最著名的实验就是牛顿师傅的三棱镜实验：</p>
<p>所以其实我们在很早就接触到了光的频谱，只是并没有了解频谱更重要的意义。</p>
<p>但不同的是，傅里叶变换出来的频谱不仅仅是可见光这样频率范围有限的叠加，而是频率从0到无穷所有频率的组合。</p>
<p>这里，我们可以用两种方法来理解正弦波：</p>
<p>第一种前面已经讲过了，就是螺旋线在实轴的投影。</p>
<p>另一种需要借助欧拉公式的另一种形式去理解：</p>
<p>e<sup>it</sup>=cos(t) + i*sin(t)<br>e<sup>-it</sup>=cos(t) - i *sin(t)</p>
<p>将以上两式相加再除2，得到：</p>
<p>cos(t)=e<sup>it</sup>+e<sup>-it</sup> / 2</p>
<p>这个式子可以怎么理解呢？</p>
<p>我们刚才讲过，e^(it)可以理解为一条逆时针旋转的螺旋线，那么e^(-it)则可以理解为一条顺时针旋转的螺旋线。而cos(t)则是这两条旋转方向不同的螺旋线叠加的一半，因为这两条螺旋线的虚数部分相互抵消掉了！</p>
<p>举个例子的话，就是极化方向不同的两束光波，磁场抵消，电场加倍。</p>
<p>这里，逆时针旋转的我们称为正频率，而顺时针旋转的我们称为负频率（注意不是复频率）。</p>
<p>好了，刚才我们已经看到了大海——连续的傅里叶变换频谱，现在想一想，连续的螺旋线会是什么样子：</p>
<p>想象一下再往下翻：</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/20.png">   </p>
<p>那个像大海螺一样的图，为了方便观看，我仅仅展示了其中正频率的部分，负频率的部分没有显示出来。</p>
<p>如果你认真去看，海螺图上的每一条螺旋线都是可以清楚的看到的，每一条螺旋线都有着不同的振幅（旋转半径），频率（旋转周期）以及相位。而将所有螺旋线连成平面，就是这幅海螺图了。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol>
<li><p>声音的应用</p>
<p>声波进行傅立叶变换，将其中的频率分出来，如低频是男声，高频是女声，或者噪音，进行区分</p>
</li>
<li><p>图像的处理</p>
<p>光波或者图像，低频是轮廓部分，高频是细节部分，通过对于高频低频的过滤，可以进行图像的操作</p>
<p><img src="/2022/08/30/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/22.png">  </p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">CUDA编程基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-29 09:30:44 / 修改时间：15:59:00" itemprop="dateCreated datePublished" datetime="2022-08-29T09:30:44+08:00">2022-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载引用于：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34587739">https://zhuanlan.zhihu.com/p/34587739</a></p>
</blockquote>
<h1 id="关于CUDA"><a href="#关于CUDA" class="headerlink" title="关于CUDA"></a>关于CUDA</h1><p>2006年，NVIDIA公司发布了<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/">CUDA</a>，CUDA是建立在NVIDIA的CPUs上的一个通用并行计算平台和编程模型，基于CUDA编程可以利用GPUs的并行计算引擎来更加高效地解决比较复杂的计算难题。近年来，GPU最成功的一个应用就是深度学习领域，基于GPU的并行计算已经成为训练深度学习模型的标配。</p>
<p>GPU并不是一个独立运行的计算平台，而需要与CPU协同工作，可以看成是CPU的协处理器，因此当我们在说GPU并行计算时，其实是指的基于CPU+GPU的异构计算架构。在异构计算架构中，GPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为为主机端（host），而GPU所在位置称为设备端（device），如下图所示。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1.png">  </p>
<p>可以看到GPU包括更多的运算核心，其特别适合数据并行的计算密集型任务，如大型矩阵运算，而CPU的运算核心较少，但是其可以实现复杂的逻辑运算，因此其适合控制密集型任务。另外，CPU上的线程是重量级的，上下文切换开销大，但是GPU由于存在很多核心，其线程是轻量级的。因此，基于CPU+GPU的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，而GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2.png">  </p>
<p>CUDA是NVIDIA公司所开发的GPU编程模型，它提供了GPU编程的简易接口，基于CUDA编程可以构建基于GPU计算的应用程序。CUDA提供了对其它编程语言的支持，如C/C++，Python，Fortran等语言，这里我们选择CUDA C/C++接口对CUDA编程进行讲解。</p>
<h1 id="CUDA编程基础"><a href="#CUDA编程基础" class="headerlink" title="CUDA编程基础"></a>CUDA编程基础</h1><p>在给出CUDA的编程实例之前，这里先对CUDA编程模型中的一些概念及基础知识做个简单介绍。CUDA编程模型是一个异构模型，需要CPU和GPU协同工作。在CUDA中，<strong>host</strong>和<strong>device</strong>是两个重要的概念，我们用host指代CPU及其内存，而用device指代GPU及其内存。CUDA程序中既包含host程序，又包含device程序，它们分别在CPU和GPU上运行。同时，host与device之间可以进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行流程如下：</p>
<ol>
<li>分配host内存，并进行数据初始化；</li>
<li>分配device内存，并从host将数据拷贝到device上；</li>
<li>调用CUDA的核函数在device上完成指定的运算；</li>
<li>将device上的运算结果拷贝到host上；</li>
<li>释放device和host上分配的内存。</li>
</ol>
<p>上面流程中最重要的一个过程是调用CUDA的核函数来执行并行计算，<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23kernels">kernel</a>是CUDA中一个重要的概念，<strong>kernel是在device上线程中并行执行的函数</strong>，<strong>核函数用<code>__global__</code>符号声明，在调用时需要用<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定kernel要执行的线程数量，在CUDA中，每一个线程都要执行核函数，并且每个线程会分配一个唯一的线程号thread ID，这个ID值可以通过核函数的内置变量<code>threadIdx</code>来获得</strong>。</p>
<p>由于GPU实际上是异构模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词开区别host和device上的函数，主要的三个函数类型限定词如下：</p>
<ul>
<li><code>__global__</code>：<strong>在device上执行，从host中调用</strong>（一些特定的GPU也可以从device上调用），返回类型必须是<code>void</code>，不支持可变参数参数，不能成为类成员函数。注意用<code>__global__</code>定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。</li>
<li><code>__device__</code>：在device上执行，单仅可以从device中调用，不可以和<code>__global__</code>同时用。</li>
<li><code>__host__</code>：在host上执行，仅可以从host上调用，一般省略不写，不可以和<code>__global__</code>同时用，但可和<code>__device__</code>，此时函数会在device和host都编译。</li>
</ul>
<p>要深刻理解kernel，必须要对kernel的线程层次结构有一个清晰的认识。</p>
<p>首先GPU上很多并行化的轻量级线程。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个<strong>网格</strong>（grid），同一个网格上的线程共享相同的全局内存空间，grid是线程结构的第一层次，而网格又可以分为很多<strong>线程块</strong>（block），一个线程块里面包含很多线程，这是第二个层次。线程两层组织结构如下图所示，这是一个gird和block均为2-dim的线程组织。grid和block都是定义为<code>dim3</code>类型的变量，<code>dim3</code>可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此grid和block可以灵活地定义为1-dim，2-dim以及3-dim结构，对于图中结构（主要水平方向为x轴），定义的grid和block如下所示，kernel在调用时也必须通过<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23execution-configuration">执行配置</a><code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定kernel所使用的线程数及结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/3.png"> </p>
<p>所以，一个线程需要两个内置的坐标变量（blockIdx，threadIdx）来唯一标识，它们都是<code>dim3</code>类型变量，其中blockIdx指明线程所在grid中的位置，而threaIdx指明线程所在block中的位置，如图中的Thread (1,1)满足：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadIdx.x = <span class="number">1</span></span><br><span class="line">threadIdx.y = <span class="number">1</span></span><br><span class="line">blockIdx.x = <span class="number">1</span></span><br><span class="line">blockIdx.y = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>一个线程块上的线程是放在同一个流式多处理器（SM)上的，但是单个SM的资源有限，这导致线程块中的线程数是有限制的，现代GPUs的线程块可支持的线程数可达1024个。</p>
<p>有时候，我们要知道一个线程在blcok中的全局ID，此时就必须还要知道block的组织结构，这是通过线程的内置变量blockDim来获得。它获取线程块各个维度的大小。对于一个2-dim的block (Dx,Dy) ，线程 (x,y) 的ID值为 (x+y∗Dx) ，如果是3-dim的block (Dx,Dy,Dz) ，线程 (x,y,z) 的ID值为 (x+y∗Dx+z∗Dx∗Dy) 。另外线程还有内置变量gridDim，用于获得网格块各个维度的大小。</p>
<p>kernel的这种线程组织结构天然适合vector,matrix等运算，如我们将利用上图2-dim结构实现两个矩阵的加法，每个线程负责处理每个位置的两个元素相加，代码如下所示。线程块大小为(16, 16)，然后将N*N大小的矩阵均分为不同的线程块来执行加法运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kernel定义</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; j &lt; N) </span><br><span class="line">        C[i][j] = A[i][j] + B[i][j]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Kernel 线程配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>; </span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span><br><span class="line">    <span class="comment">// kernel调用</span></span><br><span class="line">    MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外这里简单介绍一下CUDA的内存模型，如下图所示。</p>
<p>可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。内存结构涉及到程序优化，这里不深入探讨它们。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/4.png">  </p>
<p>还有重要一点，你需要对GPU的硬件实现有一个基本的认识。上面说到了kernel的线程组织层次，那么一个kernel实际上会启动很多线程，这些线程是逻辑上并行的，但是在物理层却并不一定。这其实和CPU的多线程有类似之处，多线程如果没有多核支持，在物理层也是无法实现并行的。但是好在GPU存在很多CUDA核心，充分利用CUDA核心可以充分发挥GPU的并行计算能力。</p>
<p>GPU硬件的一个核心组件是SM，前面已经说过，SM是英文名是 Streaming Multiprocessor，翻译过来就是流式多处理器。</p>
<p>SM的核心组件包括CUDA核心，共享内存，寄存器等，SM可以并发地执行数百个线程，并发能力就取决于SM所拥有的资源数。当一个kernel被执行时，它的gird中的线程块被分配到SM上，一个线程块只能在一个SM上被调度。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个kernel的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。</p>
<p>SM采用的是<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23simt-architecture">SIMT</a> (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（warps)，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为GPU规定线程束中所有线程在同一周期执行相同的指令，线程束分化会导致性能下降。当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。</p>
<p>总之，就是网格和线程块只是逻辑划分，一个kernel的所有线程其实在物理层是不一定同时并发的。所以kernel的grid和block的配置不同，性能会出现差异，这点是要特别注意的。还有，由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/5.png">  </p>
<p>在进行CUDA编程前，可以先检查一下自己的GPU的硬件配置，这样才可以有的放矢，可以通过下面的程序获得GPU的配置属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dev = <span class="number">0</span>;</span><br><span class="line">  cudaDeviceProp devProp;</span><br><span class="line">  CHECK(cudaGetDeviceProperties(&amp;devProp, dev));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用GPU device &quot;</span> &lt;&lt; dev &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; devProp.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SM的数量：&quot;</span> &lt;&lt; devProp.multiProcessorCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个线程块的共享内存大小：&quot;</span> &lt;&lt; devProp.sharedMemPerBlock / <span class="number">1024.0</span> &lt;&lt; <span class="string">&quot; KB&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个线程块的最大线程数：&quot;</span> &lt;&lt; devProp.maxThreadsPerBlock &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个EM的最大线程数：&quot;</span> &lt;&lt; devProp.maxThreadsPerMultiProcessor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个SM的最大线程束数：&quot;</span> &lt;&lt; devProp.maxThreadsPerMultiProcessor / <span class="number">32</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出如下</span></span><br><span class="line">  使用GPU device <span class="number">0</span>: GeForce GT <span class="number">730</span></span><br><span class="line">  SM的数量：<span class="number">2</span></span><br><span class="line">  每个线程块的共享内存大小：<span class="number">48</span> KB</span><br><span class="line">  每个线程块的最大线程数：<span class="number">1024</span></span><br><span class="line">  每个EM的最大线程数：<span class="number">2048</span></span><br><span class="line">  每个EM的最大线程束数：<span class="number">64</span></span><br></pre></td></tr></table></figure>



<h1 id="向量加法实例"><a href="#向量加法实例" class="headerlink" title="向量加法实例"></a>向量加法实例</h1><p>知道了CUDA编程基础，我们就来个简单的实战，利用CUDA编程实现两个向量的加法，在实现之前，先简单介绍一下CUDA编程中内存管理API。首先是在device上分配内存的cudaMalloc函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="keyword">void</span>** devPtr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数和C语言中的malloc类似，但是在device上申请一定字节大小的显存，其中devPtr是指向所分配内存的指针。同时要释放分配的内存使用cudaFree函数，这和C语言中的free函数对应。另外一个重要的函数是负责host和device之间数据通信的cudaMemcpy函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count, cudaMemcpyKind kind)</span></span></span><br></pre></td></tr></table></figure>

<p>其中src指向数据源，而dst是目标区域，count是复制的字节数，其中kind控制复制的方向：cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost及cudaMemcpyDeviceToDevice，如cudaMemcpyHostToDevice将host上数据拷贝到device上。</p>
<p>现在我们来实现一个向量加法的实例，这里grid和block都设计为1-dim，首先定义kernel如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个向量加法kernel，grid和block均为一维</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span>* x, <span class="keyword">float</span> * y, <span class="keyword">float</span>* z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取全局索引</span></span><br><span class="line">    <span class="keyword">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="comment">// 步长</span></span><br><span class="line">    <span class="keyword">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; n; i += stride)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中stride是整个grid的线程数，有时候向量的元素数很多，这时候可以将在每个线程实现多个元素（元素总数/线程总数）的加法，相当于使用了多个grid来处理，这是一种<a href="https://link.zhihu.com/?target=https://devblogs.nvidia.com/cuda-pro-tip-write-flexible-kernels-grid-stride-loops/">grid-stride loop</a>方式，不过下面的例子一个线程只处理一个元素，所以kernel里面的循环是不执行的。下面我们具体实现向量加法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> nBytes = N * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="comment">// 申请host内存</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    x = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    y = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    z = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">10.0</span>;</span><br><span class="line">        y[i] = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请device内存</span></span><br><span class="line">    <span class="keyword">float</span> *d_x, *d_y, *d_z;</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_x, nBytes);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_y, nBytes);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_z, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将host数据拷贝到device</span></span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)d_x, (<span class="keyword">void</span>*)x, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)d_y, (<span class="keyword">void</span>*)y, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((N + blockSize.x - <span class="number">1</span>) / blockSize.x)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    add &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(d_x, d_y, d_z, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将device得到的结果拷贝到host</span></span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)z, (<span class="keyword">void</span>*)d_z, nBytes, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(z[i] - <span class="number">30.0</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最大误差: &quot;</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放device内存</span></span><br><span class="line">    cudaFree(d_x);</span><br><span class="line">    cudaFree(d_y);</span><br><span class="line">    cudaFree(d_z);</span><br><span class="line">    <span class="comment">// 释放host内存</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="built_in">free</span>(y);</span><br><span class="line">    <span class="built_in">free</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们的向量大小为1&lt;&lt;20，而block大小为256，那么grid大小是4096，kernel的线程层级结构如下图所示：</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/6.png">  </p>
<p>使用nvprof工具可以分析kernel运行情况，结果如下所示，可以看到kernel函数费时约1.5ms。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvprof cuda9.exe</span><br><span class="line">==7244== NVPROF is profiling process 7244, command: cuda9.exe</span><br><span class="line">最大误差: 4.31602e+008</span><br><span class="line">==7244== Profiling application: cuda9.exe</span><br><span class="line">==7244== Profiling result:</span><br><span class="line">            Type  Time(%)      Time     Calls       Avg       Min       Max  Name</span><br><span class="line"> GPU activities:   67.57%  3.2256ms         2  1.6128ms  1.6017ms  1.6239ms  [CUDA memcpy HtoD]</span><br><span class="line">                   32.43%  1.5478ms         1  1.5478ms  1.5478ms  1.5478ms  add(float*, float*, float*, int)</span><br></pre></td></tr></table></figure>

<p>你调整block的大小，对比不同配置下的kernel运行情况，我这里测试的是当block为128时，kernel费时约1.6ms，而block为512时kernel费时约1.7ms，当block为64时，kernel费时约2.3ms。看来不是block越大越好，而要适当选择。</p>
<p>在上面的实现中，我们需要单独在host和device上进行内存分配，并且要进行数据拷贝，这是很容易出错的。好在CUDA 6.0引入统一内存（<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23um-unified-memory-programming-hd">Unified Memory</a>）来避免这种麻烦，简单来说就是统一内存使用一个托管内存来共同管理host和device中的内存，并且自动在host和device中进行数据传输。CUDA中使用cudaMallocManaged函数分配托管内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocManaged</span><span class="params">(<span class="keyword">void</span> **devPtr, <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>利用统一内存，可以将上面的程序简化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> nBytes = N * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请托管内存</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;x, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;y, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;z, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">10.0</span>;</span><br><span class="line">        y[i] = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((N + blockSize.x - <span class="number">1</span>) / blockSize.x)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    add &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(x, y, z, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(z[i] - <span class="number">30.0</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最大误差: &quot;</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    cudaFree(x);</span><br><span class="line">    cudaFree(y);</span><br><span class="line">    cudaFree(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之前的代码，使用统一内存更简洁了，值得注意的是kernel执行是与host异步的，由于托管内存自动进行数据传输，这里要用cudaDeviceSynchronize()函数保证device和host同步，这样后面才可以正确访问kernel计算的结果。</p>
<h1 id="矩阵乘法实例"><a href="#矩阵乘法实例" class="headerlink" title="矩阵乘法实例"></a>矩阵乘法实例</h1><p>最后我们再实现一个稍微复杂一些的例子，就是两个矩阵的乘法，设输入矩阵为 A 和 B ，要得到 C=A×B 。实现思路是每个线程计算 C 的一个元素值 Ci,j ，对于矩阵运算，应该选用grid和block为2-D的。首先定义矩阵的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵类型，行优先，M(row, col) = *(M.elements + row * M.width + col)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">float</span> *elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/7.png">  </p>
<p>然后实现矩阵乘法的核函数，这里我们定义了两个辅助的<code>__device__</code>函数分别用于获取矩阵的元素值和为矩阵元素赋值，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取矩阵A的(row, col)元素</span></span><br><span class="line"><span class="function">__device__ <span class="keyword">float</span> <span class="title">getElement</span><span class="params">(Matrix *A, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A-&gt;elements[row * A-&gt;width + col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为矩阵A的(row, col)元素赋值</span></span><br><span class="line"><span class="function">__device__ <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(Matrix *A, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A-&gt;elements[row * A-&gt;width + col] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵相乘kernel，2-D，每个线程计算一个元素</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">matMulKernel</span><span class="params">(Matrix *A, Matrix *B, Matrix *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> Cvalue = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">int</span> row = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line">	<span class="keyword">int</span> col = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A-&gt;width; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Cvalue += getElement(A, row, i) * getElement(B, i, col);</span><br><span class="line">	&#125;</span><br><span class="line">	setElement(C, row, col, Cvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们采用统一内存编写矩阵相乘的测试实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    Matrix *A, *B, *C;</span><br><span class="line">    <span class="comment">// 申请托管内存</span></span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;A, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;B, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;C, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    <span class="keyword">int</span> nBytes = width * height * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;A-&gt;elements, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;B-&gt;elements, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;C-&gt;elements, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    A-&gt;height = height;</span><br><span class="line">    A-&gt;width = width;</span><br><span class="line">    B-&gt;height = height;</span><br><span class="line">    B-&gt;width = width;</span><br><span class="line">    C-&gt;height = height;</span><br><span class="line">    C-&gt;width = width;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A-&gt;elements[i] = <span class="number">1.0</span>;</span><br><span class="line">        B-&gt;elements[i] = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">32</span>, <span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((width + blockSize.x - <span class="number">1</span>) / blockSize.x, </span></span></span><br><span class="line"><span class="params"><span class="function">        (height + blockSize.y - <span class="number">1</span>) / blockSize.y)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    matMulKernel &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(A, B, C);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; ++i)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(C-&gt;elements[i] - <span class="number">2</span> * width));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最大误差: &quot;</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里矩阵大小为，设计的线程的block大小为(32, 32)，那么grid大小为(32, 32)，最终测试结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nvprof cuda9.exe</span><br><span class="line">==<span class="number">16304</span>== NVPROF is profiling process <span class="number">16304</span>, command: cuda9.exe</span><br><span class="line">最大误差: <span class="number">0</span></span><br><span class="line">==<span class="number">16304</span>== Profiling application: cuda9.exe</span><br><span class="line">==<span class="number">16304</span>== Profiling result:</span><br><span class="line">            Type  Time(%)      Time     Calls       Avg       Min       Max  Name</span><br><span class="line"> GPU activities:  <span class="number">100.00</span>%  <span class="number">1.32752</span>s         <span class="number">1</span>  <span class="number">1.32752</span>s  <span class="number">1.32752</span>s  <span class="number">1.32752</span>s  matMulKernel(Matrix*, Matrix*, Matrix*)</span><br><span class="line">      API calls:   <span class="number">83.11</span>%  <span class="number">1.32762</span>s         <span class="number">1</span>  <span class="number">1.32762</span>s  <span class="number">1.32762</span>s  <span class="number">1.32762</span>s  cudaDeviceSynchronize</span><br><span class="line">                   <span class="number">13.99</span>%  <span class="number">223.40</span>ms         <span class="number">6</span>  <span class="number">37.233</span>ms  <span class="number">37.341u</span>s  <span class="number">217.66</span>ms  cudaMallocManaged</span><br><span class="line">                    <span class="number">2.81</span>%  <span class="number">44.810</span>ms         <span class="number">1</span>  <span class="number">44.810</span>ms  <span class="number">44.810</span>ms  <span class="number">44.810</span>ms  cudaLaunch</span><br><span class="line">                    <span class="number">0.08</span>%  <span class="number">1.3300</span>ms        <span class="number">94</span>  <span class="number">14.149u</span>s       <span class="number">0</span>ns  <span class="number">884.64u</span>s  cuDeviceGetAttribute</span><br><span class="line">                    <span class="number">0.01</span>%  <span class="number">199.03u</span>s         <span class="number">1</span>  <span class="number">199.03u</span>s  <span class="number">199.03u</span>s  <span class="number">199.03u</span>s  cuDeviceGetName</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">10.009u</span>s         <span class="number">1</span>  <span class="number">10.009u</span>s  <span class="number">10.009u</span>s  <span class="number">10.009u</span>s  cuDeviceTotalMem</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">6.5440u</span>s         <span class="number">1</span>  <span class="number">6.5440u</span>s  <span class="number">6.5440u</span>s  <span class="number">6.5440u</span>s  cudaConfigureCall</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">3.0800u</span>s         <span class="number">3</span>  <span class="number">1.0260u</span>s     <span class="number">385</span>ns  <span class="number">1.5400u</span>s  cudaSetupArgument</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">2.6940u</span>s         <span class="number">3</span>     <span class="number">898</span>ns     <span class="number">385</span>ns  <span class="number">1.5390u</span>s  cuDeviceGetCount</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">1.9250u</span>s         <span class="number">2</span>     <span class="number">962</span>ns     <span class="number">385</span>ns  <span class="number">1.5400u</span>s  cuDeviceGet</span><br><span class="line"></span><br><span class="line">==<span class="number">16304</span>== Unified Memory profiling result:</span><br><span class="line">Device <span class="string">&quot;GeForce GT 730 (0)&quot;</span></span><br><span class="line">   Count  Avg Size  Min Size  Max Size  Total Size  Total Time  Name</span><br><span class="line">    <span class="number">2051</span>  <span class="number">4.0000</span>KB  <span class="number">4.0000</span>KB  <span class="number">4.0000</span>KB  <span class="number">8.011719</span>MB  <span class="number">21.20721</span>ms  Host To Device</span><br><span class="line">     <span class="number">270</span>  <span class="number">45.570</span>KB  <span class="number">4.0000</span>KB  <span class="number">1.0000</span>MB  <span class="number">12.01563</span>MB  <span class="number">7.032508</span>ms  Device To Host</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C语言复习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-31 11:36:14" itemprop="dateCreated datePublished" datetime="2022-07-31T11:36:14+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-10 21:15:38" itemprop="dateModified" datetime="2022-10-10T21:15:38+08:00">2022-10-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><p>C语言格式特点：</p>
<ol>
<li>习惯用 小写字母，<strong>大小写敏感</strong></li>
<li>不使用行号，<strong>无程序行概念</strong></li>
<li>可使用空行和空格</li>
<li>常用<strong>锯齿形</strong>书写格式</li>
</ol>
<blockquote>
<p>注释可以用 // 或者 /*     */ </p>
</blockquote>
<p><img src="/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="image-20220731115703687">  </p>
<h1 id="数据类型、运算符和表达式"><a href="#数据类型、运算符和表达式" class="headerlink" title="数据类型、运算符和表达式"></a>数据类型、运算符和表达式</h1><h2 id="C的数据类型"><a href="#C的数据类型" class="headerlink" title="C的数据类型"></a>C的数据类型</h2><p><img src="/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png">  </p>
<p><strong>数据类型决定：</strong></p>
<ol>
<li>数据占内存字节数</li>
<li>数据取值范围</li>
<li>可以进行的操作</li>
</ol>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><blockquote>
<p>常量：在程序运行中，不能被改变的量</p>
<ul>
<li>整型，实型，字符型，字符串</li>
<li>符号常量：用某种符号来表示某个常量，称之为符号常量<ul>
<li>#define PRICE 30  //用PRICE代表30</li>
<li><strong>不可以再给符号常量进行赋值</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>变量：<strong>变量</strong>是指在程序运行时其值可以改变的量。</p>
<ul>
<li>变量的功能就是存储数据。</li>
<li>C规定，标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串，并且其第一个字符必须是字母或下划线。且不能与C语言的关键字重名。<ul>
<li>标识符使用规则：</li>
<li>(1)<strong>标准C不限制标识符的长度，但它受各种版本的C语言编译系统限制，同时也受到具体机器的限制</strong>。例如在某版本C中规定标识符前八位有效，当两个标识符前八位相同时，则被认为是同一个标识符。<br>(2)在标识符中，<strong>大小写是有区别的</strong>。例如CLANG和Clang 是两个不同的标识符。<br>(3)标识符虽然可由程序员随意定义，但标识符是用于标识某个量的符号。因此，命名应尽量有相应的意义，以便阅读理解，做到“顾名思义”。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>C语言的基本数据类型为：整型、字符型、实数型。</p>
<p>这些类型按其在计算机中的存储方式可被分为两个系列，即<strong>整数(integer)类型</strong>和<strong>浮点数(floating-point)类型</strong>。 </p>
<p>这三种类型之下分别是：short、int、long、char、float、double这六个关键字再加上两个符号说明符signed和unsigned就基本表示了C语言的最常用的数据类型。</p>
<p>下面列出了在32位操作系统下常见编译器下的数据类型大小及表示的数据范围：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>类型关键字</th>
<th>占字节数</th>
<th>其他叫法</th>
<th>表示的数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>字符型</td>
<td>char</td>
<td>1</td>
<td>signed char</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>无符号字符型</td>
<td>unsigned char</td>
<td>1</td>
<td>none</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4</td>
<td>signed int</td>
<td>-2,147,483,648 ~ 2,147,483,647</td>
</tr>
<tr>
<td>无符号整型</td>
<td>unsigned int</td>
<td>4</td>
<td>unsigned</td>
<td>0 ~ 4,294,967,295</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2</td>
<td>short int</td>
<td>-32,768 ~ 32,767</td>
</tr>
<tr>
<td>无符号短整型</td>
<td>unsigned short</td>
<td>2</td>
<td>unsigned short int</td>
<td>0 ~ 65,535</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>4</td>
<td>long int</td>
<td>-2,147,483,648 ~ 2,147,483,647</td>
</tr>
<tr>
<td>无符号长整型</td>
<td>unsigned long</td>
<td>4</td>
<td>unsigned long</td>
<td>0 ~ 4,294,967,295</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>float</td>
<td>4</td>
<td>none</td>
<td>3.4E +/- 38 (7 digits)</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double</td>
<td>8</td>
<td>none</td>
<td>1.7E +/- 308 (15 digits)</td>
</tr>
<tr>
<td>长双精度浮点数</td>
<td>long double</td>
<td>10</td>
<td>none</td>
<td>1.2E +/- 4932 (19 digits)</td>
</tr>
</tbody></table>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>在C语言中，为了定义变量、表达语句功能和对一些文件进行预处理，还必须用到一些具有特殊意义的字符，这就是关键字，我们用户自己定义的变量函数名等要注意不可以与关键字同名。</p>
<table>
<thead>
<tr>
<th>C语言中的32个关键字</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>int</td>
<td>struct</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>switch</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>register</td>
<td>typedef</td>
</tr>
<tr>
<td>char</td>
<td>extern</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>const</td>
<td>float</td>
<td>short</td>
<td>unsigned</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>signed</td>
<td>void</td>
</tr>
<tr>
<td>default</td>
<td>goto</td>
<td>sizeof</td>
<td>volatile</td>
</tr>
<tr>
<td>do</td>
<td>if</td>
<td>static</td>
<td>while</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table>
<thead>
<tr>
<th>运算符类型</th>
<th>运算符表示</th>
<th>运算符用法</th>
</tr>
</thead>
<tbody><tr>
<td>赋值运算符</td>
<td>=</td>
<td>将值赋给 “=” 左侧变量</td>
</tr>
<tr>
<td>算数运算符</td>
<td>+，-，*，/，%</td>
<td>注意：除法中，整数的除法会丢掉小数部分；取模运算两侧必须为整数，取出来的为余数</td>
</tr>
<tr>
<td>sizeof运算符</td>
<td>sizeof()</td>
<td><strong>sizeof</strong>是C语言的32个关键字之一，并非“函数”(我们会后面介绍)，也叫<strong>长度(求字节)运算符</strong>，sizeof是一种<strong>单目运算符</strong>，<em>以字节为单位返回某操作数的大小，用来求某一类型变量的长度</em>。其运算对象可以是任何<strong>数据类型</strong>或<strong>变量</strong>。</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>逻辑与&amp;&amp;、逻辑或||、逻辑非！</td>
<td>其中逻辑与&amp;&amp;是<strong>双目运算符</strong>，即需要运算符两边都要有表达式，且两边表达式都为真，此表达式才为真；                     逻辑||也是<strong>双目运算符</strong>，要求左右两边的表达式只要有一个为真整体就为真。                                                      逻辑非! 运算符是<strong>单目运算符</strong>，只需右边跟一个表达式，表示取反的意思，即原先真的取反则为假，原先假的取反则为真</td>
</tr>
<tr>
<td>？：条件运算符</td>
<td>表达式1?表达式2:表达式3</td>
<td>首先计算表达式1的值，看看是真还是假，也就是成立还是不成立，如果表达式1成立，那么这个三目运算符整体的值就是表达式2的值，否则（也就是表达式1不成立），这个三目运算符整体的值就是表达式3的值</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;, &lt; , ==, &gt;=, &lt;=, !=</td>
<td>关系运算符的比较结果是<strong>逻辑值</strong>，即非真即假，也就是非1即0;     ex. 1 &gt;= 2 的值为 0</td>
</tr>
</tbody></table>
<h2 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h2><p>​        <strong>表达式(expression)<strong>是由</strong>运算符</strong>和<strong>操作数</strong>组合构成的（回忆一下，<strong>操作数是运算符操作的对象</strong>）。</p>
<p>​        最简单的表达式即一个单独的操作数，以此作为基础可以建立复杂的表达式，比如下面这些：</p>
<blockquote>
<p>3+2<br>a=(2+b/3)/5<br>x=i++<br>m=2*5</p>
</blockquote>
<p>​        正如看到的一样，操作数可以是<strong>常量</strong>，也可以是<strong>变量</strong>，亦可以是他们的组合。一些表达式是多个较小的表达式的组合，这些小的表达式称为**子表达式(subexpression)**。</p>
<p>​        **语句(statement)**是构造程序的基本部分。</p>
<p>​        **程序(program)**是一系列带有某种必须的标点语句集合。一个语句是一条完整的计算机指令。在C中，语句用结束处的一个分号标示。</p>
<p>例如：c=3这只是一个表达式（它可能是一个较大语句的一个部分），而c=3;则是一个语句。<br>想必您应该已经看到了，没错，表达式后面加一个分号即构成了一条C语句（它们被称为<strong>表达式语句</strong>）</p>
<h1 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h1><h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf()函数"></a>printf()函数</h2><p><strong>printf函数</strong>叫做<strong>格式输出函数</strong>，其功能是按照用户指定的格式，把指定的数据输出到屏幕上，printf函数的格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输出表项);</span><br></pre></td></tr></table></figure>



<p>格式控制字符串有两种：<strong>格式字符串</strong>和<strong>非格式字符串</strong>。非格式字符串在输出的时候原样打印；格式字符串是以%打头的字符串，在“%”后面跟不同格式字符，用来说明输出数据的类型、形式、长度、小数位数等。格式字符串的形式为：</p>
<blockquote>
<p><strong>% [输出最小宽度] [.精度] [长度] 类型</strong></p>
<p>例： </p>
<p>float  a = 3.1415;</p>
<p>printf (“%3.2f \n”, a );</p>
<p>结果：</p>
</blockquote>
<p>例如：%d格式符表示用十进制整形格式输出，%f表示用实型格式输出，%5.2f格式表示输出宽度为5(包括小数点)，并包含2位小数。</p>
<p><strong>常用的输出格式</strong>及含义如下：</p>
<table>
<thead>
<tr>
<th>格式字符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>d , i</td>
<td>以十进制形式输出有符号整数(正数不输出符号)</td>
</tr>
<tr>
<td>O</td>
<td>以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr>
<td>x</td>
<td>以十六进制形式输出无符号整数(不输出前缀0x)</td>
</tr>
<tr>
<td>U</td>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<td>f</td>
<td>以小数形式输出单、双精度类型实数</td>
</tr>
<tr>
<td>e</td>
<td>以指数形式输出单、双精度实数</td>
</tr>
<tr>
<td>g</td>
<td>以%f或%e中较短输出宽度的一种格式输出单、双精度实数</td>
</tr>
<tr>
<td>C</td>
<td>输出单个字符</td>
</tr>
<tr>
<td>S</td>
<td>输出字符串</td>
</tr>
</tbody></table>
<h2 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h2><p><strong>scanf函数</strong>称为<strong>格式输入函数</strong>，即按照格式字符串的格式，从键盘上把数据输入到指定的变量之中。scanf函数的调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输入项地址列表);</span><br></pre></td></tr></table></figure>



<p>其中，<strong>格式控制字符串</strong>的作用与printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串。地址表项中的地址给出各变量的地址，地址是由地址运算符“&amp;”后跟变量名组成的。</p>
<p>scanf函数中格式字符串的构成与printf函数基本相同，但使用时有几点不同。</p>
<p>(1)格式说明符中，可以指定数据的宽度，但不能指定数据的精度。例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a；</span><br><span class="line"><span class="built_in">scanf</span>(“%<span class="number">10f</span>”，&amp;a); <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">scanf</span>(“%<span class="number">10.2f</span>”,&amp;a); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>(2)输入long类型数据时必须使用%ld，输入double数据必须使用%lf或%le</p>
<p>(3)附加格式说明符“*”使对应的输入数据不赋给相应的变量</p>
<p>scanf()函数所用的转换说明符与printf()所用的几乎完全相同。主要区别在于printf()把%f、%e、%E、%g、%G同时用于float类型和double类型，而scanf()只是把他们用于float类型，而用于double类型时要求使用l(字母l)修饰符。</p>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>把输入解释成一个字符</td>
</tr>
<tr>
<td>%d</td>
<td>把输入解释成一个有符号十进制整数</td>
</tr>
<tr>
<td>%e,%f,%g,%a</td>
<td>把输入解释成一个浮点数(%a是C99的标准)</td>
</tr>
<tr>
<td>%E,%F,%G,%A</td>
<td>把输入解释成一个浮点数(%A是C99的标准)</td>
</tr>
<tr>
<td>%i</td>
<td>把输入解释成一个有符号十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>把输入解释成一个有符号的八进制整数</td>
</tr>
<tr>
<td>%p</td>
<td>把输入解释成一个指针(一个地址)</td>
</tr>
<tr>
<td>%s</td>
<td>把输入解释成一个字符串：输入的内容以第一个非空白字符作为开始，并且包含直到下一个空白字符的全部字符</td>
</tr>
<tr>
<td>%u</td>
<td>把输入解释成一个无符号十进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>把输入解释称一个有符号十六进制整数</td>
</tr>
</tbody></table>
<p>​    </p>
<p>*<strong>修饰符</strong>在scanf中()的用法：</p>
<p>*在scanf()中提供截然不同的服务，当把它放在%和说明符字母之间时，它使函数跳过相应的输入项目。请参考程序事例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用*跳过scanf接收的数字*/</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter three number:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span> ,&amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The last number is %d\n&quot;</span>,num);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>gcc下运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please enter three number:</span><br><span class="line">2014 2015 2016</span><br><span class="line">The last number is 2016</span><br></pre></td></tr></table></figure>



<p>关于scanf()的<strong>返回值</strong>：</p>
<p>scanf()函数返回成功读入的项目的个数。如果它没有读取任何项目（比如它期望接收一个数字而您却输入的一个非数字字符时就会发生这种情况），scanf()返回0。</p>
<p>当它检测到“文件末尾”(end of file)时，它返回EOF(EOF在是文件stdio.h中的定义好的一个特殊值，一般，#define指令将EOF的值定义为-1)。当您学过循环之后，或在参加ACM这样的比赛及使用在线评测系统的时候会经常用到这种写法。</p>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if语句选择结构"><a href="#if语句选择结构" class="headerlink" title="if语句选择结构"></a>if语句选择结构</h2><p><strong>if else选择程序结构</strong>用于判断给定的条件，根据判断条件的成立与否来控制程序的流程。选择结构有<strong>单选择</strong>、<strong>双选择</strong>和<strong>多选择</strong>3种形式，单选择结构用<strong>if语句</strong>实现。</p>
<p><strong>形式一：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) <span class="comment">/*若条件成立则实行花括号里的语句，反之则不执行*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>形式二：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) <span class="comment">/*若表达式成立则执行语句1，否则执行语句2*/</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//语句1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//语句2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>形式三：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)       <span class="comment">/*如果表达式成立，执行语句1否则继续判断表达式2*/</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//语句1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>) <span class="comment">/*如果表达式成立，执行语句2否则继续判断表达式3*/</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//语句2 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>) <span class="comment">/*如果表达式成立，则执行语句3否则继续判断下一个表达式*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//语句3; </span></span><br><span class="line">&#125; <span class="comment">//… … </span></span><br><span class="line"><span class="keyword">else</span>            <span class="comment">/*如果以上表达式都不成立 则执行语句4*/</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//语句4 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句"></a>switch case语句</h2><p>​        <strong>switch语句</strong>的执行过程为：首先计算表达式的值，然后依次与常量表达式依次进行比较，若表达式的值与某常量表达式相等，则从该常量表达式处开始执行，直到switch语句结束。若所有的常量表达式的值均不等于表达式的值，则从<strong>default</strong>处开始执行。一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)         <span class="comment">/*首先计算表达式的值*/</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>; </span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">3</span>:语句<span class="number">3</span>; </span><br><span class="line">	<span class="comment">// ……   </span></span><br><span class="line">	<span class="keyword">case</span> 常量表达式n:语句n;</span><br><span class="line">	<span class="keyword">default</span>:语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">switch</span>(value)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">printf</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">&quot;two&quot;</span>);  <span class="comment">// break； 从这里跳出</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">&quot;three&quot;</span>)；</span><br><span class="line">  <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>break</strong>，顾名思义，跳出的意思，仅用于跳出<strong>switch结构</strong>或<strong>循环结构</strong>，用于提前结束switch结构或循环。</p>
</blockquote>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h2><p>​        <strong>while语句</strong>创建一个循环，<strong>该循环在判断表达式为假(或0)之前重复执行</strong>。while语句是一个<strong>入口条件(entry-condition)循环</strong>，在进行一次循环之前决定是否要执行循环。因此有可能一次也不执行。</p>
<p>循环的语句部分可以是一个<strong>简单语句</strong>或一个<strong>复合语句</strong>。</p>
<p><strong>while循环</strong>其一般式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式) </span><br><span class="line">&#123; </span><br><span class="line">	循环体语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在表达式为假(或0)之前重复执行循环体语句部分</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><p>​        <strong>do while语句</strong>创建一个循环，它在判断表达式为假(或0)之前重复执行。do while语句是一个<strong>退出条件循环</strong>，<strong>在执行一次循环之后才决定是否要再次执行循环</strong>，因此循环至少要被执行一次。循环的语句部分可以是一个<strong>简单语句</strong>或一个<strong>复合语句</strong></p>
<p><strong>do while循环</strong>其一般式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体语句 </span><br><span class="line">	&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<p>在表达式为假(或0)之前重复执行循环体语句</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>​        <strong>for语句</strong>使用由分号隔开的三个控制表达式来控制循环过程。初始化表达式只在开始执行循环语句之前执行一次。如果判断表达式为真(或非0)就执行一次循环。然后计算更新表达式并再次检查判断表达式的值。for语句是一个<strong>入口条件循环</strong>，在进行一次循环之前决定是否要执行循环，因此有可能循环一次也不执行。循环的语句部分可以是一个<strong>简单语句</strong>或一个<strong>复合语句</strong>。</p>
<p><strong>for循环</strong>其一般式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式;判断表达式;更新表达式)</span><br><span class="line">&#123;</span><br><span class="line">	循环体语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环在判断表达式为假(或0)之前重复执行</p>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>​        <strong>continue</strong>，顾名思义，是继续的意思，它<strong>仅用于循环</strong>中，用于<strong>提前结束本次循环</strong>，即跨过continue后面的循环语句，提前进入下次循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将<span class="number">100</span>以内的偶数相加</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum)</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>​        C源程序是由<strong>函数</strong>组成的。</p>
<p>​        最简单的程序有一个主函数main()，但实用程序往往由多个函数组成，由主函数调用其他函数，其他函数也可以互相调用。</p>
<p>​        <strong>函数</strong>是C源程序的基本模块，程序的许多功能是通过对函数模块的调用来实现的，学会编写和调用函数可以提高编程效率。</p>
<p><strong>函数的定义：</strong></p>
<blockquote>
<p><strong>返回值类型 函数名（形参表说明）     /* 函数首部 */</strong></p>
<p><strong>{</strong></p>
<p>​        <strong>说明语句    /* 函数体 */</strong></p>
<p>​        <strong>执行语句</strong></p>
<p><strong>}</strong></p>
</blockquote>
<p>对上面的定义形式进行以下说明：<br>(1)“<strong>返回值类型</strong>”是指函数返回值的类型。<strong>函数返回值不能是数组，也不能是函数</strong>，除此之外任何合法的数据类型都可以是函数的类型，如：int，long，float，char等。函数类型可以省略，当不指明函数类型时，系统默认的是整型。</p>
<p>(2)函数名是用户自定义的<strong>标识符</strong>，在C语言函数定义中不可省略，须符合C语言对标识符的规范，用于标识函数，并用该标识符调用函数。另外函数名本身也有值，它代表了该函数的入口地址，使用指针调用函数时，将用到此功能。</p>
<p>(3)形参又称为“<strong>形式参数</strong>”。形参表是用逗号分隔的一组变量说明，包括形参的类型和形参的标识符，其作用是指出每一个形参的类型和形参的名称，当调用函数时，接收来自主调函数的数据，确定各参数的值。</p>
<p>(4)用{ }括起来的部分是函数的主体，称为<strong>函数体</strong>。函数体是一段程序，确定该函数应完成的规定的运算，应执行的规定的动作，集中体现了函数的功能。函数内部应有自己的<strong>说明语句</strong>和<strong>执行语句</strong>，但函数内定义的变量不可以与形参同名。花括号{ }是不可以省略的。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><blockquote>
<p>主调函数使用被调函数的功能，称为<strong>函数调用</strong>。</p>
</blockquote>
<p>在C语言中，只有在<strong>函数调用</strong>时，函数体中定义的功能才会被执行。C语言中，<strong>函数调用</strong>的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(类型 形参,类型 形参...);</span><br></pre></td></tr></table></figure>



<p>对无参函数调用时则无实际参数表。</p>
<p>实际参数表中的参数可以是<strong>常数、变量或其他构造类型数据及表达式</strong>，各实参之间用逗号分隔。</p>
<p>在C语言中，可以用以下几种方式<strong>调用函数</strong>。</p>
<p>​        (1)<strong>函数表达式</strong>：函数作为表达式中的一项出现在表达式中，以函数返回值参与表达式的运算。这种方式要求函数是有返回值的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z=max(x,y);</span><br></pre></td></tr></table></figure>

<p>是一个赋值表达式，把max的返回值赋予变量z。</p>
<p>​        (2)<strong>函数语句</strong>：函数调用的一般形式加上分号即构成函数语句，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br></pre></td></tr></table></figure>

<p>都是以函数语句的方式调用函数。</p>
<p>​        (3)<strong>函数实参</strong>：函数作为另一个函数调用的实际参数出现。这种情况是把该函数的返回值作为实参进行传送，因此要求该函数必须是有返回值的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max(x,y));<span class="comment">/*把max调用的返回值作为printf函数的实参*/</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​        <strong>在主调函数中调用某函数之前应对该被调函数进行声明</strong>，在主调函数中对被调函数进行声明的目的是使编译系统知道被调函数返回值的类型，以便在主调函数中按此种类型对返回值进行相应的处理。其一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 被调函数名(类型 形参,类型 形参...);</span><br></pre></td></tr></table></figure>

<p>​        需要注意的是，<strong>函数的声明</strong>和<strong>函数的定义</strong>有本质上的不同，主要区别在以下两个方面：</p>
<p>(1)函数的定义是编写一段程序，应有函数的具体功能语句——<strong>函数体</strong>，而函数的声明仅是向编译系统的一个说明，不含具体的执行动作。</p>
<p>(2)在程序中，函数的定义只能有一次，而函数的声明可以有多次。</p>
<h2 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h2><p>​        在C语言中，<strong>变量</strong>是对程序中数据所占内存空间的一种抽象定义，定义变量时，用户定义变量的名、变量的类型，这些都是变量的操作属性。<em>不仅可以通过变量名访问该变量，系统还通过该标识符确定变量在内存中的位置。</em></p>
<p>​        在计算机中，保存变量当前值的<strong>存储单元</strong>有两类，一类是内存，另一类是CPU的寄存器。</p>
<p>​        变量的存储类型关系到变量的存储位置，C语言中定义了4种存储属性，即**自动变量(auto)、外部变量(extern)、静态变量(static)和寄存器变量(register)**，它关系到变量在内存中的存放位置，由此决定了变量的保留时间和变量的作用范围。</p>
<p>​        变量的保留时间又称为<strong>生存期</strong>，从时间角度，可将变量分为<strong>静态存储</strong>和<strong>动态存储</strong>两种情况：</p>
<p>（1）<strong>静态存储</strong>是指变量存储在内存的静态存储区，在编译时就分配了存储空间，在整个程序的运行期间，该变量占有固定的存储单元，程序结束后，这部分空间才释放，变量的值在整个程序中始终存在。</p>
<p>（2）<strong>动态存储</strong>是指变量存储在内存的动态存储区，在程序的运行过程中，只有当变量所在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值只在函数调用期存在。</p>
<p>​        变量的作用范围又称为<strong>作用域</strong>，从空间角度，可以将变量分为<strong>全局变量</strong>和<strong>局部变量</strong>：</p>
<p>（1）<strong>局部变量</strong>是在一个函数或复合语句内定义的变量，它仅在函数或复合语句内有效，编译时，编译系统不为局部变量分配内存单元，而是在程序运行过程中，当局部变量所在的函数被调用时，编译系统根据需要，临时分配内存，调用结束，空间释放。</p>
<p>（2）<strong>全局变量</strong>是在函数之外定义的变量，其作用范围为从定义处开始到本文件结束，编译时，编译系统为其分配固定的内存单元，在程序运行的自始至终都占用固定单元。</p>
<h2 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h2><p>​        <strong>函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的，数据存储在动态存储区中</strong>。</p>
<p>​        函数中的形参和在函数中定义的变量（包括在复合语句中定义的变量）都属此类，在调用该函数时系统会给它们分配存储空间，在函数调用结束时就自动释放这些存储空间，这类局部变量称为<strong>自动变量</strong>。</p>
<p>自动变量用<strong>关键字auto</strong>进行存储类别的声明，例如声明一个自动变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">	auto int b,c=3; /*定义b,c为自动变量*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a是函数fun()的形参，b、c是自动变量，并对c赋初值3。执行完fun()函数后，自动释放a、b、c所占的存储单元。</p>
<h2 id="extern外部变量"><a href="#extern外部变量" class="headerlink" title="extern外部变量"></a>extern外部变量</h2><p>​        <strong>外部变量</strong>，即<strong>全局变量</strong>，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。</p>
<ol>
<li><p>如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件末尾。</p>
</li>
<li><p>如果在定义点之前的函数想引用该外部变量，则应该在引用之前用<strong>关键字extern</strong>对该变量进行“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
</li>
</ol>
<p>​    通常的，用extern声明外部变量，扩展程序文件中的作用域</p>
<h2 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h2><p>​        有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定局部变量为<strong>静态局部变量</strong>，用<strong>关键字static</strong>进行声明。</p>
<p>​        通过用static类型声明后的变量，<strong>其变量的内存空间位于内存的全局静态区</strong>，仅会<strong>初始化一次</strong>，这是一个非常重要的特性，请大家通过如下的程序理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a = a*<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a = %d \n&quot;</span>, a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    fun();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:     </span><br><span class="line"><span class="comment">//这个结果的原因在于，每次a的值是接着上一次函数调用的值继续运算的，并非每次都初始化从5开始计算，这就是static的特性，请大家好好理解</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">a=<span class="number">20</span></span><br><span class="line">a=<span class="number">40</span></span><br><span class="line">a=<span class="number">80</span></span><br><span class="line">a=<span class="number">160</span></span><br><span class="line">a=<span class="number">320</span></span><br><span class="line">a=<span class="number">640</span></span><br><span class="line">a=<span class="number">1280</span></span><br><span class="line">a=<span class="number">2560</span></span><br><span class="line">a=<span class="number">5120</span></span><br></pre></td></tr></table></figure>



<h2 id="register寄存器变量"><a href="#register寄存器变量" class="headerlink" title="register寄存器变量"></a>register寄存器变量</h2><p>​        为提高效率，C语言允许将局部变量的值存放在CPU的寄存器中，这种变量叫做<strong>寄存器变量</strong>，用<strong>关键字register</strong>声明。使用寄存器变量需要注意以下几点：</p>
<ol>
<li><strong>只有局部自动变量和形式参数可以作为寄存器变量</strong></li>
<li>一个计算机系统中的寄存器数目有限，<strong>不能定义任意多个寄存器变量</strong></li>
<li><strong>不能使用取地址运算符“&amp;”求寄存器变量的地址</strong></li>
</ol>
<p>例如如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a=<span class="number">0</span>; <span class="comment">//将变量a存储在寄存器上</span></span><br></pre></td></tr></table></figure>



<p>在C语言发展迭代的今天，当我们尝试用regiter声明一个变量时，编译器很可能会根据情况，把”register”忽略掉，需要大家知晓这一情况。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>​        数组是同类型有序数据的集合，可以为这些数据的集合起一个名字，称为<strong>数组名</strong>。该集合中的各个数据项称为<strong>数组元素</strong>，每个元素可用数组名和下标表示。</p>
<p>​        <strong>一维数组</strong>(姑且先叫一维数组)的定义和使用：</p>
<p>​        在C语言中使用数组必须先进行定义，一维数组的定义方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 数组名 [常量表达式];</span><br></pre></td></tr></table></figure>



<p>​        其中<strong>类型说明符</strong>是任意一种<strong>基本数据类型 或 构造数据类型</strong>，它定义了全体数组成员的数据类型，可以发现要比我们定义N个元素要方便的多了，如果把一个元素看作一个点，那么一维数组就像一条线。</p>
<p>​        名是用户定义的<strong>数组标识符</strong>，方括号中的常量表达式表示数据元素的个数，也称为<strong>数组的长度</strong>。需要注意的是，数组中的元素下标是从0开始计算的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">//定义一个数组名为a，存储100个int类型的数组，其元素分别是a[0]~a[99]</span></span><br><span class="line"><span class="keyword">float</span> b[<span class="number">10</span>];<span class="comment">//数组名为b的，存储10个float类型的数组，其元素分别是b[0]~b[9]</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">256</span>]; <span class="comment">//定义一个数组名为c的字符型数组，长度为256，其元素分别是c[0]~c[255]</span></span><br></pre></td></tr></table></figure>

<p>​        当在函数中只定义数组时，数组里的值和函数里定义一个变量的值一样，都是未初始化过的，我们也可以定义的时候并初始化赋值，并且，当给部分元素赋初值的时候，未被赋值的元素将自动赋值为0，更细一些，int类型未被赋值的元素为0，浮点型为小数类型，而字符类型则为’\0’，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//定义一个整型数组a，前5个元素即赋值为1，2，3，4，5，后95个元素值值全部为0</span></span><br><span class="line"><span class="keyword">float</span> b[<span class="number">10</span>]=&#123;&#125;<span class="number">1.1</span>, <span class="number">2</span>,<span class="number">2</span>, <span class="number">0.0</span>&#125;; <span class="comment">//定义float数组b并对全部float类型的元素都分别赋值</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">256</span>] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span>&#125;; <span class="comment">//定义一个数组名为c的字符型数组，并对前9个元素进行赋值，其余元素全部为&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>​        一维数组是呈线性排布的，如果我们需要比如矩阵这样的结构时，该怎么办？一个最直观的想法就是每一行都用一个一维数组存放，那么有几行，就需要几个一维数组。等等，还记得上节课的点与线的关系吗？那矩阵这种结构就是线与面的关系！丹尼斯·里奇同样为我们提供了<strong>二维数组</strong>（<strong>多维数组</strong>）这样的东西，很好地解决了这个问题。</p>
<p><strong>二维数组的定义</strong><br>类型说明符 数组名[] [];</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">/*定义一个整形二维数组a，有3行4列共12个元素分别为：a[0][0] a[0][1] a[0][2] a[0][3]</span></span><br><span class="line"><span class="comment">a[1][0] a[1][1] a[1][2] a[1][3]</span></span><br><span class="line"><span class="comment">a[2][0] a[2][1] a[2][2] a[2][3]*/</span></span><br><span class="line"><span class="keyword">char</span> arry[<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">//定义一个字符型二维数组arry，有10行10列，依次为arry[0][0]~arry[9][9]共100个元素</span></span><br></pre></td></tr></table></figure>



<p><strong>二维数组的初始化</strong></p>
<p>二维数组可以用以下两种方式初始化赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;,&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>&#125;&#125;; <span class="comment">//定义一个三行四列的二维数组，按行赋值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>&#125;;  <span class="comment">//定义一个三行四列的二维数组并对其中的12（3*4）个元素进行赋值</span></span><br></pre></td></tr></table></figure>

<p>您可能会想，为什么第二种也可以？这样的话，定义int a 【3][4]和定义int a[12]有什么区别呢？</p>
<ul>
<li>真相是：二维数组与一维数组一样在内存中的存储也是按照线性排布的</li>
</ul>
<h2 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h2><p>​        用来存放字符的数组称为<strong>字符数组</strong>。字符数组的各个元素依次存放字符串的各字符，字符数组的数组名代表该数组的<strong>首地址</strong>，这为处理字符串中个别字符和引用整个字符串提供了极大的方便。</p>
<p>字符数组的定义形式与前面介绍的数值数组相同，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>];		</span><br></pre></td></tr></table></figure>



<p>字符数组也允许在定义时进行初始化赋值，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>]=&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; h &#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;a&#x27;</span>， <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>对字符数组的各个元素逐个赋值后，各元素的值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">0</span>]= ``<span class="string">&#x27;c&#x27;</span>``,c[<span class="number">1</span>]= ``<span class="string">&#x27;h&#x27;</span>``,c[<span class="number">2</span>]= ``<span class="string">&#x27;i&#x27;</span>``,c[<span class="number">3</span>]= ``<span class="string">&#x27;n&#x27;</span>``,c[<span class="number">4</span>]= ``<span class="string">&#x27;a&#x27;</span>``,c[<span class="number">5</span>]= ``<span class="string">&#x27;\0&#x27;</span>``;</span><br></pre></td></tr></table></figure>



<p>其中,‘\0’为<strong>字符串结束符</strong>。如果不对c[5]赋任何值，‘\0’会由系统自动添加。字符数组也可采用字符串常量的赋值方式，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[]=&#123;<span class="string">&quot;china&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>熟悉了C语言中字符串的存储表达方式之后，大家可以扩展学习：</p>
<p><a target="_blank" rel="noopener" href="https://www.dotcpp.com/course/579">字符串的常见处理函数</a>，包括strcmp、strcpy、strlen、strcat等等，增加字符串的处理能力。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>​        在学习指针之前，我们先弄清楚一个概念：<strong>地址</strong></p>
<p>​        何谓地址？在内存（注意：我们这里提到的内存并不是人们常说的计算机的物理内存，而是虚拟的逻辑内存空间）中，简单地说：地址就是可以唯一标识某一点的一个编号，即一个数字！我们都见过尺子，我们统一以毫米为单位，一把长1000毫米的尺子，其范围区间为0~999，而我们可以准确的找到35毫米、256毫米处的位置。</p>
<p>​        同样的道理，内存也如此，也是像尺子一样线性排布，只不过这个范围略大，在我们最广泛使用的32位操作系统下，是从0~4,294,967,295之间，而地址就是这之中的的一个编号而已，习惯上，在计算机里地址我们常常用其对应的十六进制数来表示，比如0x12ff7c这样。</p>
<p>​        在我们的C程序中，每一个定义的变量，在内存中都占有一个内存单元，比如int类型占四个字节，char类型占一个字节等等，每个字节都在0~4,294,967,295之间都有一个对应的编号，C语言允许在程序中使用变量的地址，并可以通过地址运算符”&amp;”得到变量的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>]=&#123;<span class="string">&quot;clanguage&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;int address:0x %x,value:%d\n&quot;</span>,&amp;a[i],a[i]);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;char address:0x%x,value:%c\n&quot;</span>,&amp;b[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff360,value:<span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff364,value:<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff368,value:<span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff36c,value:<span class="number">4</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff370,value:<span class="number">5</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff374,value:<span class="number">6</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff378,value:<span class="number">7</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff37c,value:<span class="number">8</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff380,value:<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff384,value:<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff356,value:c</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff357,value:l</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff358,value:a</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff359,value:n</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35a,value:g</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35b,value:u</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35c,value:a</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35d,value:g</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35e,value:e</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35f,value:x00</span><br></pre></td></tr></table></figure>

<h2 id="指针定义和使用"><a href="#指针定义和使用" class="headerlink" title="指针定义和使用"></a>指针定义和使用</h2><p>​        简单地讲，地址就是逻辑内存上的编号，而指针虽然也表示一个编号，也是一个地址。但两者性质却不相同。一个代表了常量，另一个则是变量。就好比内存是一把尺子，而指针就是尺子上面的游标，可以左右移动，它某一个时刻是指向一个地方的，这就是<strong>指针变量</strong>。</p>
<blockquote>
<p>对指针变量定义的一般形式为：<br>                类型说明符 *变量名;</p>
</blockquote>
<p>其中，这里的与前面的类型说明符共同说明这是一个指针变量，类型说明符表示该指针变量<strong>所指向的变量</strong>为何种数据类型，变量名即为定义的<strong>指针变量名</strong>。除此之外，C还提供运算符获取地址上对应的值，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">2014</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;num;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num Address = 0x%x,num=%d\n&quot;</span>,&amp;num,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x, *p = %d\n&quot;</span>),p,*p;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*&amp;num);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line"> <span class="comment">/* num Address = 0xefbff348,num=2014</span></span><br><span class="line"><span class="comment"> 		p = 0xefbff348, *p = 2014</span></span><br><span class="line"><span class="comment"> 		2014   */</span></span><br></pre></td></tr></table></figure>

<p>​        现在假设有一个 char 类型的变量 c，它存储了字符 ‘K’（ASCII码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190114/1IG34354-0.png" alt="img">   </p>
<p>​        <code>*</code>是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带<code>*</code>。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上<code>*</code>，后边可以像使用普通变量一样来使用指针变量。也就是说，**定义指针变量时必须带<code>*</code>，给指针变量赋值时不能带<code>*</code>**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义普通变量</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">99.5</span>, b = <span class="number">10.6</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;@&#x27;</span>, d = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="comment">//定义指针变量</span></span><br><span class="line"><span class="keyword">float</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">char</span> *p2 = &amp;c;</span><br><span class="line"><span class="comment">//修改指针变量的值</span></span><br><span class="line">p1 = &amp;b;</span><br><span class="line">p2 = &amp;d;</span><br></pre></td></tr></table></figure>

<p>​        假设变量 a、b、c、d 的地址分别为 0X1000、0X1004、0X2000、0X2004，下面的示意图很好地反映了 p1、p2 指向的变化：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190114/1IG3J50-1.jpg" alt="img">  </p>
<p>​    </p>
<p>值得一提的是，由于<strong>指针存放的都是地址</strong>，在364位操作系统下都在0~4,294,967,295这个数区间内，所以，<strong>在64位操作系统下，任何类型的指针变量都占8个字节</strong>！  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        <span class="keyword">char</span> *p1;</span><br><span class="line">        <span class="keyword">float</span> *p2;</span><br><span class="line">        <span class="keyword">double</span> *p3;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">INFO</span> *<span class="title">p4</span>;</span>   <span class="comment">//struct INFO类型为结构体类型 我们将会在后面的章节中讲解</span></span><br><span class="line">        <span class="keyword">void</span> *p5;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;int point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;char point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p1));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;float point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p2));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;double point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p3));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p4));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;void point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p5));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line"><span class="keyword">int</span> point size is :<span class="number">8</span><span class="keyword">char</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="keyword">float</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="keyword">double</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">size</span> <span class="title">is</span> :</span><span class="number">8</span></span><br><span class="line"><span class="keyword">void</span> point size is :<span class="number">8</span></span><br></pre></td></tr></table></figure>



<h2 id="数组和指针的区别和联系"><a href="#数组和指针的区别和联系" class="headerlink" title="数组和指针的区别和联系"></a>数组和指针的区别和联系</h2><p>​        前面我们已经知道，通过数组下标可以确定数组元素在数组中的<strong>顺序</strong>和<strong>存储地址</strong>。由于每个数组元素相当于一个变量，因此<strong>指针变量</strong>可以指向数组中的元素，也就是说可以用指针方式访问数组中的元素。</p>
<p>​        对一个指向数组元素的指针变量的定义和赋值方法，与指针变量相同，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; ``<span class="comment">/*定义a为包含10个整型数据的数组*/</span></span><br><span class="line"><span class="keyword">int</span> *p; ``<span class="comment">/*定义p为指向整型变量的指针*/</span></span><br><span class="line">p=&amp;a[<span class="number">0</span>]; ``<span class="comment">/*把a[0]元素的地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure>

<p> C语言规定，数组名代表数组的首地址，也就是第0号元素的地址。因此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=a; <span class="comment">/* 等价于p=&amp;a[0]; */</span></span><br><span class="line"><span class="keyword">int</span> *p=a; <span class="comment">/* 等价于int *p=&amp;a[0]; */</span></span><br></pre></td></tr></table></figure>



<p>对于指向首地址的指针p，p+i(或a+i)就是数组元素a[i]的地址，*(p+i)( 或*(a+i) )就是a[i]的值。</p>
<p>如果指针变量p已指向数组中的某一个元素，则p+1指向同一数组中的下一个元素。</p>
<p>引入指针变量后，就可以用以下两种方法来访问<strong>数组元素</strong>：<br>(1)<strong>下标法</strong>，即用a[i]形式访问数组元素，在前面介绍数组时都是采用这种方法。<br>(2)<strong>指针法</strong>，即采用*(a+i)或*(p+i)形式，用间接访问的方法来访问数组元素，其中a是数组名，p是指向数组的指针变量，其初值p=a。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> *p=a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;P Value:%d   a Value :%d\n&quot;</span>,*(p++),*(a+i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">  <span class="comment">/* P Value:1   a Value :1</span></span><br><span class="line"><span class="comment">P Value:2   a Value :2</span></span><br><span class="line"><span class="comment">P Value:3   a Value :3</span></span><br><span class="line"><span class="comment">P Value:4   a Value :4</span></span><br><span class="line"><span class="comment">P Value:5   a Value :5</span></span><br><span class="line"><span class="comment">P Value:6   a Value :6</span></span><br><span class="line"><span class="comment">P Value:7   a Value :7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>注意输出的两种方式，指针可以通过++或–并修改自身值的方式移动，然而数组名本身值不可以被更改。</p>
<h2 id="字符串与指针的用法"><a href="#字符串与指针的用法" class="headerlink" title="字符串与指针的用法"></a>字符串与指针的用法</h2><p>前面我们已经讨论过字符数组与字符串，<strong>字符指针</strong>也可以指向一个字符串，可以用字符串常量对字符指针进行<strong>初始化</strong>，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;www.dotcpp.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这是对字符指针进行初始化。此时，字符指针指向一个字符串常量的<strong>首地址</strong>。</p>
<p>还可以用字符数组来存放字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[ ] = <span class="string">&quot;Welcome to dotcpp.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个语句中，string是数组名，代表字符数组的首地址。因此可以通过数组名string来访问字符串。</p>
<p>字符串指针和字符串数组两种方式都可以访问字符串，但它们有着本质的区别：字符指针str是个变量，可以改变str使它指向不同的字符串，但不能改变str所指向的字符串常量的值。而string是一个数组，可以改变数组中保存的内容。应注意字符串指针和字符串数组的区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;www.dotcpp.com&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[]=<span class="string">&quot;Welcome to dotcpp.com&quot;</span>;</span><br><span class="line">    str[<span class="number">0</span>]=<span class="string">&#x27;C&#x27;</span>; <span class="comment">//试图修改str指向的常量区的字符串内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">错误的做法❌</span><br></pre></td></tr></table></figure>



<h1 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h1><h2 id="struct结构体的定义和使用"><a href="#struct结构体的定义和使用" class="headerlink" title="struct结构体的定义和使用"></a>struct结构体的定义和使用</h2><p><strong>结构体</strong>与数组类似，都是由若干分量组成的，与数组不同的是，结构体的成员可以是不同类型，可以通过成员名来访问结构体的元素。</p>
<p><strong>结构体的定义</strong>说明了它的组成成员，以及每个成员的数据类型。定义一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  数据类型 成员名 <span class="number">1</span>; ``  ``</span><br><span class="line">  数据类型 成员名 <span class="number">2</span>; ``  ``</span><br><span class="line">  ...... ``  ``</span><br><span class="line">  数据类型 成员名 n; ``</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构的定义说明了变量在结构中的存在格式，要使用该结构就必须说明结构类型的变量。<strong>结构变量说明</strong>的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名称 结构变量名;</span></span><br></pre></td></tr></table></figure>



<p>定义结构体便是定义了一种由成员组成的复合类型，而用这种类型说明了一个变量才会产生具体的实体。与说明基本数据类型的变量一样，系统会按照结构定义时的内部组成，为说明的结构变量分配内存空间。<strong>结构变量的成员在内存中占用连续的存储区域，所占内存大小为结构中每个成员的长度之和。</strong></p>
<p>我们可以将变量student1说明为address类型的结构变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span> <span class="title">student1</span>;</span></span><br></pre></td></tr></table></figure>

<p>虽然，结构体作为若干成员的集合是一个整体，但在使用结构时，不仅要对结构的整体进行操作，还经常要访问结构中的每一个成员。在程序中<strong>使用结构中成员</strong>的方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构变量名.成员名称</span><br></pre></td></tr></table></figure>

<p>如student1.tel表示结构变量student1的电话信息。</p>
<p>和其他类型的变量一样，结构变量也可以进行初始化。<strong>结构初始化</strong>的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名 结构变量 =</span> &#123; 初始化数据 <span class="number">1</span>, ...... 初始化数据 n &#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span> <span class="title">A</span>;</span></span><br><span class="line">    A.num = <span class="number">2014</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(A.str,<span class="string">&quot;Welcome to dotcpp.com&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This year is %d %s\n&quot;</span>,A.num,A.str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p><strong>结构体数组</strong>是一个数组，其数组的每一个元素都是<strong>结构体类型</strong>。</p>
<p>在实际应用中，经常用结构体数组来表示具有相同数据结构的一个群体，如一个班的学生档案，一个车间职工的工资表等。</p>
<p>定义结构体数组和结构体变量相仿，只需说明它为数组类型即可。比如定义一个结构体数组student，包含3个元素：student[0]、student[1]、student[2]，每个数组元素都具有struct address的结构形式，并对该结构体数组进行初始化赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>]; <span class="comment">/*姓名，字符数组作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">char</span> street[<span class="number">40</span>]; <span class="comment">/*街道*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tel; <span class="comment">/*电话，无符号长整型作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> zip; <span class="comment">/*邮政编码*/</span></span><br><span class="line">&#125;student[<span class="number">3</span>]=&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Zhang&quot;</span>,<span class="string">&quot;Road NO.1&quot;</span>,<span class="number">111111</span>,<span class="number">4444</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot; Road NO.2&quot;</span>,<span class="number">222222</span>,<span class="number">5555</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Li&quot;</span>,<span class="string">&quot; Road NO.3&quot;</span>,<span class="number">333333</span>,<span class="number">6666</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="结构体指针及具体操作"><a href="#结构体指针及具体操作" class="headerlink" title="结构体指针及具体操作"></a>结构体指针及具体操作</h2><p><strong>结构体指针</strong>即指向结构体的指针。</p>
<p>当一个指针用来指向一个结构体变量时，称之为<strong>结构体指针变量</strong>。结构体指针变量中的值是所指向的结构变量的首地址，通过结构指针即可访问该结构变量。这与数组指针和函数指针的情况是相同的。结构体指针变量定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名 *结构指针变量名</span></span><br></pre></td></tr></table></figure>



<p>定义之后，就可以像之前学过的指针一样，将结构体类型的变量赋值给这个指针即可，后面就可以用这个指针间接的访问结构体了，需要注意的是，不用于结构体变量用点（**.<strong>）来访问成员的方法，结构体指针是通过箭头（</strong>-&gt;**）来访问的，下面给大家一个完整的例子来学习。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>]; <span class="comment">/*姓名，字符数组作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">char</span> street[<span class="number">40</span>]; <span class="comment">/*街道*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tel; <span class="comment">/*电话，无符号长整型作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> zip; <span class="comment">/*邮政编码*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> <span class="title">A</span>[3]=</span>&#123;&#123;<span class="string">&quot;Zhang&quot;</span>,<span class="string">&quot;Road NO.1&quot;</span>,<span class="number">111111</span>,<span class="number">4444</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot; Road NO.2&quot;</span>,<span class="number">222222</span>,<span class="number">5555</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Li&quot;</span>,<span class="string">&quot; Road NO.3&quot;</span>,<span class="number">333333</span>,<span class="number">6666</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> *<span class="title">p</span>;</span></span><br><span class="line">    p=&amp;A[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s %u %u\n&quot;</span>,p-&gt;name,p-&gt;street,p-&gt;tel,p-&gt;zip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">  Zhang Road NO<span class="number">.1</span> <span class="number">111111</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure>

<h2 id="typedef用法详解"><a href="#typedef用法详解" class="headerlink" title="typedef用法详解"></a>typedef用法详解</h2><p>在C语言中，除系统定义的标准类型和用户自定义的结构体、共用体等类型之外，还可以使用类型说明语句typedef定义新的类型来代替已有的类型。typedef语句的一般形式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 已定义的类型 新的类型;</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTEGER; ``<span class="comment">/*指定用 INTEGER 代表 int 类型*/</span>``</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> REAL; ``<span class="comment">/*指定用 REAL 代表 float 类型*/</span></span><br></pre></td></tr></table></figure>



<p>在具有上述<strong>typedef语句</strong>的程序中，下列语句就是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j; <span class="comment">/*与 INTEGER i,j;*/</span>``</span><br><span class="line"><span class="keyword">float</span> pi; <span class="comment">/*与 REAL pi;*/</span></span><br></pre></td></tr></table></figure>



<p>当然typedef的最常用的作用就是给<strong>结构体变量</strong>重命名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;INFO;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span> <span class="title">A</span>;</span></span><br><span class="line">    INFO B; <span class="comment">//通过typedef重命名后的名字INFO与struct _INFO完全等价！</span></span><br><span class="line">    A.num = <span class="number">2014</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(A.str,<span class="string">&quot;Welcome to dotcpp.com&quot;</span>);</span><br><span class="line">    B=A;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T1his year is %d %s\n&quot;</span>,A.num,A.str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This year is %d %s\n&quot;</span>,B.num,B.str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="enum枚举类型详解"><a href="#enum枚举类型详解" class="headerlink" title="enum枚举类型详解"></a>enum枚举类型详解</h2><p>C语言中还有一种特殊的类型：<strong>枚举类型</strong>，它可以让代码更简介、更易读，通过<strong>关键字enum</strong>实现，一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就会定义了一个“枚举名”的枚举类型，其值为枚举元素1（即0）、枚举元素2（即1）…（依次递增）</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>​        一直以来，我们学习C语言都是数据的处理，这些数据都是在内存中的。一旦程序结束，程序结束退出，数据也将灰飞烟灭。<strong>文件操作</strong>的实现将帮助我们把数据存储到文件中，既硬盘上的文件，如我们所熟知的txt格式，或其他各种后缀的文件，避免程序结束后数据丢失，实现存储数据的功能，甚至充当“<strong>数据库</strong>”的功能。</p>
<p>​        下面为大家C语言中操作文件的流程与方法。</p>
<p>​        在C语言中，除了我们认识的文件，还是系统设备都将视为文件来看待。对于文件的操作分为三个步骤：</p>
<p>第一步：<strong>打开文件</strong></p>
<ul>
<li>需要用到<strong>fopen函数</strong>来实现，这一步作用主要是建立程序和文件的关系，获取文件在内存中的文件指针，方便后面两步</li>
</ul>
<p>第二步：<strong>读写文件</strong></p>
<ul>
<li>读写文件分为<strong>fprintf</strong>、<strong>fscanf</strong>或者<strong>fwrite</strong>、<strong>fread</strong>或者<strong>fputs</strong>、<strong>getss</strong>等多组函数来实现</li>
<li>每组函数都分别是写和读文件。就像我们熟知的printf和scanf这组输入输出文件一样，这不过这里的读写不是向屏幕，而是向文件</li>
</ul>
<p>第三步：<strong>关闭文件</strong></p>
<ul>
<li>关闭文件则需要<strong>fclose函数</strong>实现。这一步则是切断文件指针和文件的关联，避免误操作。如果未关闭文件就对文件进行读写删除等操作，就是出现类似“正在被使用，无法修改”的提示</li>
</ul>
<h2 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h2><p>在C语言中，对文件操作之前，首先需要打开文件，使用的函数是<strong>fopen函数</strong>，它的作用是<strong>打开文件</strong>，获取该文件的文件指针，方便后续操作。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>



<p>可以看得出来，该函数需要两个字符串类型的参数，第一个是<strong>文件名</strong>，既要操作的文件对象。第二个是<strong>打开方式</strong>，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写还是追加等等等等，具体类型如下表，可以根据情况使用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>r+</td>
<td>以读/写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>rb+</td>
<td>以读/写方式打开一个二进制文件，只允许读/写数据。</td>
</tr>
<tr>
<td>rt+</td>
<td>以读/写方式打开一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据。</td>
</tr>
<tr>
<td>wb+</td>
<td>以读/写方式打开或新建一个二进制文件，允许读和写。</td>
</tr>
<tr>
<td>wt+</td>
<td>以读/写方式打开或新建一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>at+</td>
<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td>
</tr>
<tr>
<td>ab+</td>
<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td>
</tr>
</tbody></table>
<p>函数的返回值则表示打开成功后的文件指针，格式为<strong>FILE类型</strong>，是一个结构体类型，供后面使用，如果打开失败，则返回NULL。</p>
<p>比如：如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据，那么我们可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp=fopen(<span class="string">&quot;d:\\abc.dat&quot;</span>,<span class="string">&quot;r&quot;</span>)<span class="comment">//后面通过fp指针开始读文件</span></span><br></pre></td></tr></table></figure>



<p>值得说明的是：</p>
<ol>
<li><p>该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。</p>
</li>
<li><p>路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作<strong>转义字符</strong>处理，因此要用两个反斜杠才能表示一个。</p>
</li>
<li><p>一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！</p>
</li>
</ol>
<h2 id="fprintf-函数-写文件"><a href="#fprintf-函数-写文件" class="headerlink" title="fprintf()函数-写文件"></a>fprintf()函数-写文件</h2><p>上一节，我们学会了打开文件之后，如果打开模式是写，那么可以用<strong>fprintf函数</strong>来进行写，下面来介绍fprintf函数，它的原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, [argument])</span></span></span><br></pre></td></tr></table></figure>



<p>该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数<strong>文件指针</strong>，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;www.dotcpp.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这句代码的意思是将字符串”<a href="http://www.dotcpp.com&quot;以%s的格式写入fp所指向的文件中。">www.dotcpp.com&quot;以%s的格式写入fp所指向的文件中。</a></p>
<table>
<thead>
<tr>
<th>控制符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%d 或 %i</td>
<td>有符号十进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>使用 e 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td>%E</td>
<td>使用 E 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td>%f</td>
<td>十进制浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>自动选择 %e 或 %f 中合适的表示法</td>
</tr>
<tr>
<td>%G</td>
<td>自动选择 %E 或 %f 中合适的表示法</td>
</tr>
<tr>
<td>%o</td>
<td>有符号八进制</td>
</tr>
<tr>
<td>%s</td>
<td>字符的字符串</td>
</tr>
<tr>
<td>%u</td>
<td>无符号十进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>无符号十六进制整数</td>
</tr>
<tr>
<td>%X</td>
<td>无符号十六进制整数（大写字母）</td>
</tr>
<tr>
<td>%p</td>
<td>指针地址</td>
</tr>
<tr>
<td>%n</td>
<td>无输出</td>
</tr>
<tr>
<td>%</td>
<td>字符</td>
</tr>
</tbody></table>
<p>更多的格式可以参照<a target="_blank" rel="noopener" href="https://www.dotcpp.com/course/14">printf的用法</a>中的格式，可以通用。</p>
<p>而返回值为<strong>整型</strong>，如果写入成功则返回写入字符的格式，否则返回一个<strong>负数</strong>。</p>
<p>需要注意理解的是，fprintf函数虽然和printf函数很像，表示输出，但准确说是是<strong>写入</strong>的意思，是指程序向文件里写，要清楚数据的流向。</p>
<h2 id="scanf-函数-读文件"><a href="#scanf-函数-读文件" class="headerlink" title="scanf()函数-读文件"></a>scanf()函数-读文件</h2><p>如同printf与scanf的关系一样，fprintf和fscanf也是如此，fprintf负责向文件里写数据，<strong>fscanf函数</strong>则可以从文件里读数据，它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *format[,argument...])</span></span>;</span><br></pre></td></tr></table></figure>



<p>作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数<strong>文件指针</strong>，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">fscanf</span> (fp, <span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>

<p>则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中。</p>
<p>更多fscanf的格式如下表：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>读入一个十进制整数</td>
</tr>
<tr>
<td>%i</td>
<td>读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25</td>
</tr>
<tr>
<td>%u</td>
<td>读入一个无符号十进制整数</td>
</tr>
<tr>
<td>%f %F %g %G</td>
<td>用来输入实数，可以用小数形式或指数形式输入</td>
</tr>
<tr>
<td>%x %x</td>
<td>读入十六进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>读入八进制整数</td>
</tr>
<tr>
<td>%s</td>
<td>直到遇到一个空格字符（空格字符可以是空白、换行和制表符）</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符</td>
</tr>
</tbody></table>
<h2 id="fwrite-函数-写文件"><a href="#fwrite-函数-写文件" class="headerlink" title="fwrite()函数-写文件"></a>fwrite()函数-写文件</h2><p>到目前位置，我们已经学习了C语言读写文件的函数fprintf和fscanf函数，除了这对格式化文件读写函数之外，还有很多。今天介绍的<strong>fwrite函数</strong>就是写文件的函数，它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>



<p>可以看到这个函数的<strong>参数</strong>有四个：</p>
<p>第一个ptr是要写入的数据的<strong>头指针</strong>，无符号类型；</p>
<p>第二个参数size是<strong>大小</strong>，表示每个写入元素的大小，单位是字节；</p>
<p>第三个参数nmemb是<strong>个数</strong>，以上一个参数为单位的个数；</p>
<p>第四个参数stream就是<strong>文件指针</strong>，表示往哪里写。</p>
<p>至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;``  </span><br><span class="line">	FILE fp;   </span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">&quot;www.dotcpp.com&quot;</span>;   </span><br><span class="line">	fp =  fopen(<span class="string">&quot;dotcpp.dat&quot;</span>, <span class="string">&quot;w&quot;</span>); </span><br><span class="line">  fwrite(str, <span class="keyword">sizeof</span>(str) , <span class="number">1</span>, fp );</span><br><span class="line">	fclose(fp); </span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了dotcpp.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的dotcpp.dat文件对比。</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li><p>预处理命令可以改变程序设计环境，提高编程效率，它们并不是C语言本身的组成部分，不能直接对它们进行编译，必须在对程序进行编译之前，先对程序中这些特殊的命令进行“预处理”。</p>
</li>
<li><p>经过预处理后，程序就不再包括预处理命令了，最后再由编译程序对预处理之后的源程序进行编译处理，得到可供执行的目标代码。</p>
</li>
<li><p>C语言提供的预处理功能有三种，分别为宏定义、文件包含和条件编译，下面将对它们进行简单介绍。</p>
</li>
</ul>
<h2 id="宏定义define的用法"><a href="#宏定义define的用法" class="headerlink" title="宏定义define的用法"></a>宏定义define的用法</h2><blockquote>
<p>宏定义在C语言源程序中允许用一个标识符来表示一个字符串，称为“宏”，被定义为“宏”的标识符称为“宏名”。</p>
</blockquote>
<p>​        在编译预处理时，对程序中所有出现的宏名，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。宏定义是由源程序中的宏定义命令完成的，宏代换是由预处理程序自动完成的。在C语言中，宏分为有参数和无参数两种。无参宏的宏名后不带参数，其定义的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 字符串;</span><br></pre></td></tr></table></figure>



<p>其中“#”表示这是一条预处理命令（在C语言中凡是以“#”开头的均为预处理命令）<strong>“define”为宏定义命令，“标识符”为所定义的宏名，“字符串”可以是常数、表达式、格式串等</strong>。</p>
<p>符号常量的定义就是一种无参宏定义。<br>此外，常常对程序中反复使用的表达式进行宏定义。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define M (y*y+3*y);</span><br></pre></td></tr></table></figure>

<p>它的作用是指定标识符M来代替表达式(y* y+3*y)。</p>
<p>在编写源程序时，所有的(y* y+3* y)都可由M代替，而对源程序进行编译时，将先由预处理程序进行宏代换，即用(y* y+3* y)表达式去置换所有的宏名M，然后再进行编译。</p>
<p>C语言允许宏带有参数。在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对于带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。</p>
<p>带参宏定义的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 宏名(形参表) 字符串;</span><br></pre></td></tr></table></figure>

<p>在字符串中含有各个形参。</p>
<p>带参宏调用的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏名(实参表);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(y) y*y+3*y<span class="comment">/*宏定义*/</span></span></span><br><span class="line">......</span><br><span class="line">k=M(<span class="number">5</span>);  <span class="comment">/*宏调用*/</span></span><br></pre></td></tr></table></figure>

<p>……<br>在上面的宏调用时，用实参5去代替形参y，经预处理宏展开后的语句为：<br>k=5<em>5+3</em>5;</p>
<h2 id="include的用法"><a href="#include的用法" class="headerlink" title="include的用法"></a>include的用法</h2><p><strong>文件包含</strong><br>文件包含是C预处理程序的另一个重要功能，文件包含命令行的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;文件名&quot;</span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。</p>
<p>在程序设计中，文件包含是很有用的。一个大的程序可以分为多个模块，由多个程序员分别编程，有些公用的符号常量或宏定义等可单独组成一个文件，在其他文件的开头用包含命令包含该文件即可使用。这样，可避免在每个文件开头都去书写那些公用量，从而节省时间，并减少出错。</p>
<p>这里对C语言的文件包含命令进行以下几点说明：</p>
<ol>
<li>包含命令中的文件名可以用<strong>双引号</strong>引起来，也可以用<strong>尖括号</strong>引起来。例如以下写法都是允许的：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是这两种形式是有区别的：</p>
<ul>
<li>使用尖括号表示在包含文件目录中去查找（包含目录是由系统的环境变量进行设置的，一般为系统头文件的默认存放目录，比如Linux系统在/usr/include目录下），而不在源文件的存放目录中查找；</li>
<li>使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找。用户编程时可根据自己文件所在的目录来选择某一种命令形式。</li>
</ul>
<ol start="2">
<li>一个include命令只能指定<strong>一个被包含文件</strong>，若有多个文件要包含，则需用多个include命令。</li>
</ol>
<ol start="3">
<li>文件包含允许<strong>嵌套</strong>，即在一个被包含的文件中又可以包含另一个文件。</li>
</ol>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><strong>条件编译</strong><br><strong>预处理程序</strong>提供了条件编译的功能，可以按不同的条件去编译不同的程序部分，因而产生不同的<strong>目标代码文件</strong>，这对于程序的移植和调试是很有用的。<strong>条件编译</strong>可分为三种形式。</p>
<p>第一种形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>它的功能是如果标识符已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。<br>如果没有程序段2（为空），本格式中的#else可以没有，即可以写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>第二种形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>与第一种形式的区别是将“ifdef”改为“ifndef”。它的功能是如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。这与第一种形式的功能正好相反。</p>
<p>第三种形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>它的功能是如果常量表达式的值为真（非0），则对程序段1进行编译，否则对程序段2进行编译。<br>因此可以使程序在不同的条件下完成不同的功能。</p>
<h2 id="其他与处理命令"><a href="#其他与处理命令" class="headerlink" title="其他与处理命令"></a>其他与处理命令</h2><p><strong>#error等其他常用预处理命令</strong></p>
<p>除了上面介绍的之外，C语言还有#error、#line、#pragma等其他常用的预处理命令，在很多C语言的程序中也是经常可见的，下面简单介绍一下它们。</p>
<p><strong>1. #error</strong><br>#error指令强制编译程序停止编译，它主要用于<strong>程序调试</strong>。#error指令的一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#error error-message</span><br></pre></td></tr></table></figure>

<p>注意：宏串error-message不用双引号引起来。遇到#error指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容。</p>
<p><strong>2. #line</strong><br>#line指令改变__LINE__和__FILE__的内容。__LINE__和__FILE__都是编译程序中<strong>预定义</strong>的标识符。__FILE__的内容是当前被编译源文件的文件名。</p>
<p>#line标识符__LINE__的内容是当前被编译代码行的行号，其一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#line number &quot;filename&quot;</span><br></pre></td></tr></table></figure>


<p>其中，number是正整数并变成__LINE__的新值；可选的“filename”是合法文件标识符并变成__FILE__的新值。#line主要用于调试和特殊应用。</p>
<p><strong>3. #pragma</strong><br>#pragma是编译程序实现时定义的指令，它允许由此向编译程序传入各种指令。例如：一个编译程序可能具有支持跟踪程序执行的选项，此时可以用#pragma语句选择该功能，编译程序忽略其不支持的#pragma选项。使用#pragma预处理命令可提高C源程序对编译程序的可移植性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/07/18/%E6%B5%85%E8%AF%86%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/%E6%B5%85%E8%AF%86%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/" class="post-title-link" itemprop="url">浅识射电天文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-18 11:45:24" itemprop="dateCreated datePublished" datetime="2022-07-18T11:45:24+08:00">2022-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-12 21:02:19" itemprop="dateModified" datetime="2022-09-12T21:02:19+08:00">2022-09-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="射电天文学基础"><a href="#射电天文学基础" class="headerlink" title="射电天文学基础"></a>射电天文学基础</h1><h1 id="射电望远镜"><a href="#射电望远镜" class="headerlink" title="射电望远镜"></a>射电望远镜</h1><blockquote>
<p>美国国家射电天文台： 什么是射电望远镜</p>
<p><a target="_blank" rel="noopener" href="https://public.nrao.edu/radio-astronomy/the-science-of-radio-astronomy/">https://public.nrao.edu/radio-astronomy/the-science-of-radio-astronomy/</a></p>
</blockquote>
<h2 id="射电天文的历史"><a href="#射电天文的历史" class="headerlink" title="射电天文的历史"></a>射电天文的历史</h2><p>射电天文学是天文学的一个相对年轻的分支。今天，关于我们宇宙的一些最重要的发现来自射电望远镜。</p>
<p>射电天文学诞生于 20 世纪初。 1932 年，贝尔实验室的一位年轻工程师 Karl G. Jansky遇到了一个令人费解的问题：嘈杂的静电干扰了短波无线电跨大西洋语音通信。在追踪源头几个月后，他注意到它在天空中缓慢移动。这可能是什么？被难住了，他咨询了一位天文学家，得出了一个惊人的结论：</p>
<blockquote>
<p>“我获取了更多数据，这些数据明确表明，无论是什么东西，这些东西不仅来自外星，而且来自太阳系之外。 它来自一个固定在太空中的方向，令人惊讶的是……[它] 是太阳系在太空中移动的方向。 根据斯凯莱特的说法……那个方向有“宇宙尘埃”云……”</p>
<p>Karl Jansky</p>
</blockquote>
<p>Jansky had discovered something at the heart of the Milky Way Galaxy. His work led to one of the most important papers in the history of astronomy in the 20th century, called “Radio Waves from Outside the Solar System”, published in 1933. His work laid the foundation for the science of radio astronomy! </p>
<p>扬斯基在银河系的中心发现了一些东西。 他的工作促成了 20 世纪天文学史上最重要的论文之一，名为《太阳系外的无线电波》，于 1933 年发表。他的工作为射电天文学奠定了基础！</p>
<p>最著名的射电天文学发现之一发生在 1967 年，当时一位名叫乔斯林·贝尔的年轻研究生在她帮助建造的射电望远镜的打印输出中发现了一个奇怪的信号。</p>
<blockquote>
<p>“我的灵感发生在深夜，清晨，在一个寒冷的夜晚，我的脚冷得痛得要命。 但是当结果从图表中涌出时，你就忘记了这一切。 你会立即意识到这是多么重要——你真正得到了什么——这太棒了！”</p>
<p>Jocelyn Bell</p>
</blockquote>
<p>她发现了什么？起初并不清楚。该物体以规则的速度产生强烈的无线电脉冲，大约每秒 30 次。贝尔和她的同事们首先将这个物体命名为 LGM-1，因为他们开玩笑说，规律的脉冲可能来自“小绿人”，尽管他们知道这是一种尚未得到解释的自然现象</p>
<p>这些信号原来是来自一种叫做脉冲星的奇怪物体的无线电发射闪光。 脉冲星是一颗大质量恒星坍缩然后爆炸为超新星后留下的东西。 它将碎片云送入太空，留下一个完全由中子组成的巨大压缩物体。 脉冲星贝尔发现它的轴每秒旋转 30 次，每次旋转都会发出一个信标。 这几乎就像时钟的滴答声。</p>
<p>今天，我们知道超过 2,000 颗脉冲星。对于一些，例如蟹状星云中心的脉冲星，我们还可以看到这颗大质量恒星的发光碎片。射电天文学家专注于爆炸中心的滴答作响的脉冲星。</p>
<p>我们可以问的最有趣的问题之一是关于我们自己在宇宙中的位置，即太阳系。 它是如何形成的？ 必须存在什么条件才能在我们的星球上形成生命？ 阿塔卡马大毫米/亚毫米阵列 (ALMA) 旨在研究宇宙中寒冷、黑暗的部分，例如孕育婴儿太阳系的区域。这些区域被称为恒星托儿所。 猎户座大星云是一个著名的恒星托儿所，它的气体和尘埃云中似乎也嵌入了婴儿行星系统。 ALMA 科学家继续研究这个星云。 无线电发射和红外光可以直接穿过那些厚厚的气体和尘埃云，“揭开”恒星和行星形成过程的面纱。</p>
<h2 id="什么是射电天文"><a href="#什么是射电天文" class="headerlink" title="什么是射电天文"></a>什么是射电天文</h2><p>世界各地的天文学家使用射电望远镜观察来自恒星、行星、星系、尘埃云和气体分子的自然发生的无线电波。我们大多数人都熟悉可见光天文学及其对这些天体的揭示。可见光——也称为光学光——是我们用眼睛看到的东西，但是，可见光并不能说明物体的全部情况。例如，为了全面了解遥远的类星体或行星，天文学家会在尽可能多的波长（包括射电范围）中对其进行研究。</p>
<p>那里有一个隐藏的宇宙，以我们肉眼看不到的波长和频率辐射。宇宙中的每个物体都会发出独特的无线电发射模式，让天文学家能够获得遥远物体的全貌。射电天文学家研究气体巨行星的排放、星系中心的爆炸，甚至是垂死恒星的精确滴答信号。</p>
<p>今天，射电天文学是天文学的一个主要分支，它揭示了宇宙中一切原本隐藏的特征。</p>
<h2 id="什么是无线电波"><a href="#什么是无线电波" class="headerlink" title="什么是无线电波"></a>什么是无线电波</h2><p>我们的眼睛是用来在可见光下看宇宙的。然而，宇宙中的物体会辐射许多其他类型的光，跨越所谓的“电磁光谱”。光以波浪的形式穿过空间，就像池塘里的涟漪。每个波纹都有一个波峰和一个波谷，称为一个周期。发射无线电波的物体在很短的时间内会发出许多周期。在每个周期中，波移动一小段距离，称为它的波长</p>
<h2 id="如何做射电天文"><a href="#如何做射电天文" class="headerlink" title="如何做射电天文"></a>如何做射电天文</h2><p>The radio portion of the electromagnetic spectrum can come from energetic objects and processes in the universe as well as cold, dark objects that emit no visible light. Because different wavelengths are given off by different objects, radio astronomers use a variety of methods and instruments to detect them. One type of instrument is a large antenna that looks similar to a satellite TV dish. It’s called a radio telescope. While single-dish radio telescopes are essential, NRAO’s telescopes consist of many dishes linked together in giant arrays to gather detailed radio images of distant objects.</p>
<p>电磁频谱的无线电部分可以来自宇宙中的高能物体和过程，以及不发射可见光的冷、暗物体。由于不同的物体发出不同的波长，射电天文学家使用各种方法和仪器来探测它们。一种仪器是看起来类似于卫星电视天线的大型天线。它被称为射电望远镜。虽然单碟射电望远镜是必不可少的，但 NRAO 的望远镜由许多碟形天线组成，它们以巨大的阵列连接在一起，以收集远处物体的详细射电图像。</p>
<p>Since humans are a visual species, seeing or “imaging” is an important part of all astronomy, regardless of the type of light being studied. While radio telescopes don’t take pictures in the same way that visible-light telescopes do, the radio signals they detect are converted into data that can be used to make images. Radio astronomy data streams are brought together and processed in a supercomputer. The output can be turned into images that are colored in different ways to show characteristics of the object such as its temperature, “clumpiness”, or the strength of radio emissions from different regions. The resulting images let scientists and the public see the otherwise invisible radio objects.</p>
<p>由于人类是一种视觉物种，因此无论所研究的光类型如何，视觉或“成像”都是所有天文学的重要组成部分。 虽然射电望远镜不像可见光望远镜那样拍照，但它们检测到的无线电信号被转换成可用于制作图像的数据。 射电天文数据流在超级计算机中汇集和处理。 输出可以转换为以不同方式着色的图像，以显示物体的特征，例如其温度、“结块”或来自不同区域的无线电发射强度。 由此产生的图像让科学家和公众看到原本看不见的无线电物体。</p>
<h2 id="射电天文的技术"><a href="#射电天文的技术" class="headerlink" title="射电天文的技术"></a>射电天文的技术</h2><p><strong>射电望远镜是怎么样工作的？</strong></p>
<p>可以将射电望远镜想象成配备接收器的非常专业的天线。在日常生活中，电视和卫星天线接收信号，为人们的家庭和其他地方提供娱乐。射电望远镜从天空中非人类制造的物体中接收信号。其中一些望远镜是大盘子，另一些看起来像栅栏或散布在整个景观中的小型垂直金属框架。</p>
<p><img src="/2022/07/18/%E6%B5%85%E8%AF%86%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/WX20220912-144030.png">  </p>
<p>一个典型的射电望远镜，无论其大小和形状如何，都有几个主要部件。首先是碟形天线。尺寸和形状取决于仪器用于探测的频率以及天文学家想要成像的精细细节。</p>
<p>一个碟子需要很大，才能将来自宇宙中遥远来源的非常微弱的信号收集到它们的探测器上。它将来自远处物体的信号聚焦到碟形上方的副反射器上。这会将信号反射到检测器，然后再反射到信号增强器以放大信号（如果信号非常微弱）。然后记录数据以供以后研究。</p>
<p><strong>干涉测量的解释</strong></p>
<p>While “bigger” usually means “brighter images” with more fine detail, telescopes can only get so big.The amount of detail possible is also dependent on the telescope’s wavelength of operation. To get Hubble-like resolution, a radio telescope would have to be many kilometers across. So when radio astronomers want a finely detailed look at a distant object, they point a set of antennas at that object then use precise timing and a supercomputer to have them act as one giant telescope. Each antennas gathers radio waves that need to be combined in clever ways, allowing astronomers to produce images with the detail of a huge telescope equal to the separation between the component telescopes. Using computers and signal processing, all those signals are combined to create a high-resolution image.</p>
<p>虽然“更大”通常意味着“更亮的图像”和更精细的细节，但望远镜只能变得如此之大。可能的细节量还取决于望远镜的工作波长。为了获得类似哈勃的分辨率，射电望远镜必须有好几公里宽。因此，当射电天文学家想要对一个遥远的物体进行细致的观察时，他们会将一组天线指向该物体，然后使用精确的计时和一台超级计算机让它们充当一个巨型望远镜。每个天线都收集需要以巧妙方式组合的无线电波，使天文学家能够生成具有巨大望远镜细节的图像，该图像的细节等于组件望远镜之间的间隔。使用计算机和信号处理，将所有这些信号组合在一起以创建高分辨率图像。</p>
<h1 id="射电望远镜的基本结构"><a href="#射电望远镜的基本结构" class="headerlink" title="射电望远镜的基本结构"></a>射电望远镜的基本结构</h1><p>射电望远镜通常是由天线，馈源，接收机，数据采集和计算机等5部分构成：</p>
<p><img src="/2022/07/18/%E6%B5%85%E8%AF%86%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/WX20220912-152136.png">  </p>
<h2 id="天线系统及性能参数"><a href="#天线系统及性能参数" class="headerlink" title="天线系统及性能参数"></a>天线系统及性能参数</h2><p><strong>抛物面天线</strong></p>
<p><strong>球面天线</strong></p>
<p><strong>振子天线</strong></p>
<p><strong>天线的重要参数</strong></p>
<ol>
<li> 有效面积和天线效率</li>
<li>抛物面天线的方向性，角分辨率和增益</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 23:12:50" itemprop="dateCreated datePublished" datetime="2022-06-20T23:12:50+08:00">2022-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-26 15:42:40" itemprop="dateModified" datetime="2022-08-26T15:42:40+08:00">2022-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><blockquote>
<p>参考书目：计算机网络–自顶向下 第七版</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://gaia.cs.umass.edu/kurose_ross/interactive">http://gaia.cs.umass.edu/kurose_ross/interactive</a> </p>
<p>端系统通过通信链路(communication link)和分组交换机(packet switch)连接到一起.</p>
<p><img src="/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png">  </p>
<p>​        这里有许多类型的通信链路，它们由不同类型的物理媒体组成。这些物理媒体包括同轴电缆、铜线、光纤和无线电频谱。不同的链路能够以不同的速率传输 数据，链路的传输速率(transmission rate)以比特/秒(bit/s,或bps)度量。当一台端系 统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此 形成的信息包用计算机网络的术语来说称为分组(packet)。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p>
<p>​        分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。市面上流行着各种类型、各具特色的分组交换机，但在当今的因特网中，两种最著名的类型是路由器(router)和链路层交换机(link-layer switch)。这两种类型的交换机朝着最终目的地转发分组。链路层交换机通常用于接入网中，而路由器通常用于网络核心 中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(route或path)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/06/09/OpenStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/OpenStack/" class="post-title-link" itemprop="url">OpenStack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-09 17:10:22" itemprop="dateCreated datePublished" datetime="2022-06-09T17:10:22+08:00">2022-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-13 16:10:10" itemprop="dateModified" datetime="2022-06-13T16:10:10+08:00">2022-06-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OpenStack-云计算平台学习与实践"><a href="#OpenStack-云计算平台学习与实践" class="headerlink" title="OpenStack 云计算平台学习与实践"></a>OpenStack 云计算平台学习与实践</h1><h1 id="云计算-和-OpenStack"><a href="#云计算-和-OpenStack" class="headerlink" title="云计算 和 OpenStack"></a>云计算 和 OpenStack</h1><blockquote>
<p>注：全文摘自CloudMan</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqF6TzeFS35dvTgauaRJ6AYOr7vOIFRNygXlHmjWfiaC9MicXIicZ5d44ibgyp96PPGbpBJ9bc62UMyD0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>IT系统架构的发展到目前为止大致可以分为3个阶段：</p>
<ol>
<li><p>物理机架构 这一阶段，应用部署和运行在物理机上。 比如企业要上一个ERP系统，如果规模不大，可以找3台物理机，分别部署Web服务器、应用服务器和数据库服务器。 如果规模大一点，各种服务器可以采用集群架构，但每个集群成员也还是直接部署在物理机上。 我见过的客户早期都是这种架构，一套应用一套服务器，通常系统的资源使用率都很低，达到20%的都是好的。</p>
</li>
<li><p>虚拟化架构 摩尔定律决定了物理服务器的计算能力越来越强，虚拟化技术的发展大大提高了物理服务器的资源使用率。 这个阶段，物理机上运行若干虚拟机，应用系统直接部署到虚拟机上。 虚拟化的好处还体现在减少了需要管理的物理机数量，同时节省了维护成本。</p>
</li>
<li><p>云计算架构 虚拟化提高了单台物理机的资源使用率，随着虚拟化技术的应用，IT环境中有越来越多的虚拟机，这时新的需求产生了： 如何对IT环境中的虚拟机进行统一和高效的管理。 有需求就有供给，云计算登上了历史舞台。</p>
</li>
</ol>
<p>计算（CPU/内存）、存储和网络是 IT 系统的三类资源。 通过云计算平台，这三类资源变成了三个池子 当需要虚机的时候，只需要向平台提供虚机的规格。 平台会快速从三个资源池分配相应的资源，部署出这样一个满足规格的虚机。 虚机的使用者不再需要关心虚机运行在哪里，存储空间从哪里来，IP是如何分配，这些云平台都搞定了。</p>
<p>云平台是一个面向服务的架构，按照提供服务的不同分为 IaaS、PaaS 和 SaaS。 请看下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqF6TzeFS35dvTgauaRJ6AYOmLnZAQqNfOm6wVVZ8PhDVxK2F0c6G7k91R4JVrT5hDFaCrH8n5OI3Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<ul>
<li><strong>IaaS</strong>（Infrastructure as a Service）提供的服务是虚拟机。 IaaS 负责管理虚机的生命周期，包括创建、修改、备份、启停、销毁等。 使用者从云平台得到的是一个已经安装好镜像（操作系统+其他预装软件）的虚拟机。 使用者需要关心虚机的类型（OS）和配置（CPU、内存、磁盘），并且自己负责部署上层的中间件和应用。 IaaS 的使用者通常是数据中心的系统管理员。 典型的 IaaS 例子有 AWS、Rackspace、阿里云等。</li>
</ul>
<ul>
<li><strong>PaaS</strong>（Platform as a Service）提供的服务是应用的运行环境和一系列中间件服务（比如数据库、消息队列等）。 使用者只需专注应用的开发，并将自己的应用和数据部署到PaaS环境中。 PaaS负责保证这些服务的可用性和性能。 PaaS的使用者通常是应用的开发人员。 典型的 PaaS 有 Heroku、Google App Engine、IBM BlueMix 等。</li>
</ul>
<ul>
<li><strong>SaaS</strong>（Software as a Service）提供的是应用服务。 使用者只需要登录并使用应用，无需关心应用使用什么技术实现，也不需要关系应用部署在哪里。 SaaS的使用者通常是应用的最终用户。 典型的 SaaS 有 Google Gmail、Salesforce 等。</li>
</ul>
<blockquote>
<p>OpenStack is a cloud operating system that controls large pools of compute, storage, and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface.</p>
</blockquote>
<h1 id="OpenStack架构"><a href="#OpenStack架构" class="headerlink" title="OpenStack架构"></a>OpenStack架构</h1><p>OpenStack的核心：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqgAa9OJl30dqPYe5PbT3Ye6MdB4H0HLABVb2eZqkgLibkxNuxR7z4wgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<p>作为 IaaS 层的云操作系统，OpenStack 为虚机提供并管理三大类资源：计算、网络和存储。</p>
<p>这三个就是核心，所以我们的学习重点就是： 搞清楚 OpenStack 是如何对计算、网络和存储资源进行管理的。 在 20+ 模块中，管理这三类资源的核心模块其实不多，这几个模块就是我们的重点了。</p>
<p>要达到这个目的，我们自然需要研究 OpenStack 的整体架构。 架构里哪些核心模块负责管理计算资源、网络资源和存储资源？模块之间如何协调工作？ 同时我们会构建一个实验环境，进到各个模块的内部，通过实际操作真正理解和掌握 OpenStack。</p>
<p>OpenStack的架构：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcq1snxN7gKt4eV1Licgib1xSfEgQxkHykruS96YuiabakkL4gRwRkWrJYgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>中间菱形<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqe6TUoXLp9hkwWI4zDS7Np17dVv5ofHUK9iacibzAx5CuhVIPntEolJjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">是虚拟机，围绕 VM 的那些长方形代表 OpenStack 不同的模块（OpenStack 叫服务，后面都用服务这个术语），下面来分别介绍。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqOde9JicQFubwIP7qpIuCc3IUONoExsWkOzcviaLIPPwYnkm4ibiaenlSKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Nova：管理 VM 的生命周期，是 OpenStack 中最核心的服务。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqH0wYMryzypMrfAsbPicKYibgtgQW9xvZtD6xniaLicEmbKboYpHyicJTBgQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Neutron：为 OpenStack 提供网络连接服务，负责创建和管理L2、L3 网络，为 VM 提供虚拟网络和物理网络连接。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqmbLTpI7E2fnK7Zvdibdt6jR3geZ8099m4cHcVw1gDq9BGCG9U2gIlOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Glance：管理 VM 启动镜像，Nova 创建 VM 时将使用 Glance 提供的镜像。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqRV3kyJ5RosdVianHHP8yQ06elhjJhgnHPmekTOkOjP1wopmUOSdK7Rg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Cinder：为 VM 提供块存储服务。Cinder 提供的每一个 Volume 在 VM 看来就是一块虚拟硬盘，一般用作数据盘。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqbia1SvK6ib6gOPpfeNaj6KEiaaw2Q4IpYTNO02RibQ9aYNhdfAQ0xvrM6g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Swift：提供对象存储服务。VM 可以通过 RESTful API 存放对象数据。作为可选的方案，Glance 可以将镜像存放在 Swift 中；Cinder 也可以将 Volume 备份到 Swift 中。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqFic1hgb6ibhPR4rqdf1vkjye02icyWnC56yyCGtaONI6UACUIib4LHrvjw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Keystone：为 OpenStack 的各种服务提供认证和权限管理服务。简单的说，OpenStack 上的每一个操作都必须通过 Keystone 的审核。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqhHBGEcDMFEraRKSSBJINBIibf1gUy9RAOQfByCz5H3zOI3sKhRbqkWQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Ceilometer：提供 OpenStac k监控和计量服务，为报警、统计或计费提供数据。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqsGyPwjQvONfXEWhbsu1x3EqxYvqYicew2YnRqc3CLArjvlcV7uADwUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Horizon：为 OpenStack 用户提供一个 Web 的自服务 Portal。</p>
<p>在上面的这些服务中，哪些是 OpenStack 的核心服务呢？ 核心服务就是如果没有它，OpenStack 就跑不起来。 很显然：</p>
<ol>
<li>Nova 管理计算资源，是核心服务。</li>
<li>Neutron 管理网络资源，是核心服务。</li>
<li>Glance 为 VM 提供 OS 镜像，属于存储范畴，是核心服务。</li>
<li>Cinder 提供块存储，VM怎么也得需要数据盘吧，是核心服务。</li>
<li>Swift 提供对象存储，不是必须的，是可选服务。</li>
<li>Keystone 认证服务，没它 OpenStack 转不起来，是核心服务。</li>
<li>Ceilometer 监控服务，不是必须的，可选服务。</li>
<li>Horizon 大家都需要一个操作界面吧。</li>
</ol>
<p>现在核心服务有了，接下来我们将镜头拉近点，看看核心服务内部的组成结构。</p>
<p><strong>Logical Architecture</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcq2Zgu4WuejxFZCJR6zPgspp7ibB81xX7Tic0tfrLpIrcwKLo31KZs8PeA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<p>在 Logical Architecture 中，可以看到每个服务又由若干组件组成。 以 Neutron 为例，包含</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqA1GBGVtuNMU2yn5QshpDjrtMpCg6bxRS0qUyriaTk5wibul6AIRVibHrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<ol>
<li>Neutron Server、Neutron plugins 和 Neutron agents</li>
<li>Network provider</li>
<li>消息队列 Queue</li>
<li>数据库 Neutron Database</li>
</ol>
<p>在后面 Neutron 章节会展开学习这些组件。</p>
<p>这里想要强调一点： 上面是 Logical Architecture，描述的是 Neutron 服务各个组成部分以及各组件之间的逻辑关系。 而在实际的部署方案上，各个组件可以部署到不同的物理节点上。</p>
<p>OpenStack 本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署。 这种分布式特性让 OpenStack 具备极大的灵活性、伸缩性和高可用性。 当然从另一个角度讲，这也使得 OpenStack 比一般系统复杂，学习难度也更大。</p>
<p>![image-20220610142857117](/Users/jiayi/Library/Application Support/typora-user-images/image-20220610142857117.png) </p>
<h1 id="认证Keystone"><a href="#认证Keystone" class="headerlink" title="认证Keystone"></a>认证Keystone</h1><p>作为 OpenStack 的基础支持服务，Keystone 做下面这几件事情：</p>
<ol>
<li>管理用户及其权限</li>
<li>维护 OpenStack Services 的 Endpoint</li>
<li>Authentication（认证）和 Authorization（鉴权）</li>
</ol>
<p>学习 Keystone，得理解下面这些概念：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWa2KibqTdaff9tvEANsMjp0BCynsgfc70Xwsm27t8UadFCZDzfqVFrBRA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>User</strong></p>
<p>User 指代任何使用 OpenStack 的实体，可以是真正的用户，其他系统或者服务。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWawibNBibEX5aYMXl6FvDhyIqhAQibk4BDd3cYYnWhy2LkTNQc5WQVF1JJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当 User 请求访问 OpenStack 时，Keystone 会对其进行验证。Horizon 在 Identity-&gt;Users 管理 User</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWamX925ARyEMyX6RvkBuqsxM7lteia9XY7jPqW5LxCZXF9nzicsicvMFjEw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>除了 admin 和 demo，OpenStack 也为 nova、cinder、glance、neutron 服务创建了相应的 User。 admin 也可以管理这些 User。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWavEdMFN4jPkNTXDK54fAoM4XgI8ZBuItNTjDhuK6Vcr7ibZicZBDE5zOg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Credentials</strong></p>
<p>Credentials 是 User 用来证明自己身份的信息，可以是：</p>
<p>\1. 用户名/密码<br>\2. Token<br>\3. API Key<br>\4. 其他高级方式</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaF68soIpKKAxyicqzUU1liacwNeJ4gibtZph0Agw6cibyCdEhJoEunYib2ng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Authentication</strong></p>
<p>Authentication 是 Keystone 验证 User 身份的过程。User 访问 OpenStack 时向 Keystone 提交用户名和密码形式的 Credentials，Keystone 验证通过后会给 User 签发一个 Token 作为后续访问的 Credential。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaNLPLcmEFEBHH7Yvb3hAqBfoeksoQg8Rhc6umRhJZpFsEkP4ExvbgAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Token</strong></p>
<p>Token 是由数字和字母组成的字符串，User 成功 Authentication 后 Keystone 生成 Token 并分配给 User。</p>
<ol>
<li><p>Token 用做访问 Service 的 Credential</p>
</li>
<li><p>Service 会通过 Keystone 验证 Token 的有效性</p>
</li>
<li><p>Token 的有效期默认是 24 小时</p>
</li>
</ol>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaezgaPs2ygAsU0ibNcRHQqGmVMXlhic1QiclHFCNic9WGeibsdh60q1hfbVg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Project</strong></p>
<p>Project 用于将 OpenStack 的资源（计算、存储和网络）进行分组和隔离。</p>
<p>根据 OpenStack 服务的对象不同，Project 可以是一个客户（公有云，也叫租户）、部门或者项目组（私有云）。</p>
<p>这里请注意：</p>
<ol>
<li>资源的所有权是属于 Project 的，而不是 User。</li>
<li>在 OpenStack 的界面和文档中，Tenant / Project / Account 这几个术语是通用的，但长期看会倾向使用 Project</li>
<li>每个 User（包括 admin）必须挂在 Project 里才能访问该 Project 的资源。 一个User可以属于多个 Project。</li>
<li>admin 相当于 root 用户，具有最高权限</li>
</ol>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaQVuygKUakA7VnrutH5h0OmdUicZ3uUNVSSAtXQeQCH1yibiaQd0SWz1QQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Horizon 在 Identity-&gt;Projects 中管理 Project</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaicNVhtiaHt5Cgg7o2GrrtDVJHQiaGW7iagWCM0OYG1CQ7T17H0XW5YISng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过 Manage Members 将 User 添加到 Project</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWakxB3z8MicuPa8v9vymY5XZDjhZwEPPJsUI3608nMuoGicQjR30qWic3rQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWadKJp3AncCubsUSXTVq5hsKViaErAHeiciaicHjWDyuSfV71ExRnOWia0g1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Service</strong></p>
<p>OpenStack 的 Service 包括 Compute (Nova)、Block Storage (Cinder)、Object Storage (Swift)、Image Service (Glance) 、Networking Service (Neutron) 等。每个 Service 都会提供若干个 Endpoint，User 通过 Endpoint 访问资源和执行操作。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaI7wKjbq1vZCz6VZL9L1PWIHIVHRXHsibK1gMklFg9uibjsJnquWBiaJFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Endpoint</strong></p>
<p>Endpoint 是一个网络上可访问的地址，通常是一个 URL。Service 通过 Endpoint 暴露自己的 API。 Keystone 负责管理和维护每个 Service 的 Endpoint。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaoiabnooGYCurrphFx1H1ibHfVpUTeFY1Jqgh6cxy9xoM1PCz4IWzLAvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以使用下面的命令来查看 Endpoint。</p>
<blockquote>
<p># source devstack/openrc admin admin<br># openstack catalog list</p>
</blockquote>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWa4LOnib0Ev8fXLrGX0vCZJHVrFaLdkib9ibgrvyuKRRbBCsGhiaw4oZIoJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Role</strong></p>
<p>安全包含两部分：Authentication（认证）和 Authorization（鉴权）</p>
<p>Authentication 解决的是“你是谁？”的问题<br>Authorization 解决的是“你能干什么？”的问题</p>
<p>Keystone 借助 Role 实现 Authorization：</p>
<ol>
<li><p>Keystone定义Role<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWa4g1Lo2bT0Qr8icAANReoib7RGstCFT2CBtDeKOIoWRZ4gUO5vOum2w2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>可以为 User 分配一个或多个 Role，Horizon 的菜单为 Identity-&gt;Project-&gt;Manage Members<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaLZFW0PTibkq4N67D3FzvgQZmZTV4UAA19NQejTGvVnHlddpBul6zomw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>Service 决定每个 Role 能做什么事情 Service 通过各自的 policy.json 文件对 Role 进行访问控制。 下面是 Nova 服务 /etc/nova/policy.json 中的示例<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaCA7OcpYVDYSurGCPRtibLrq3xjKmSuicibeQicyDFv1svQp4Ycmmwcx2lQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ol>
<p>上面配置的含义是：对于 create、attach_network 和 attach_volume 操作，任何Role的 User 都可以执行； 但只有 admin 这个 Role 的 User 才能执行 forced_host 操作。</p>
<p>以下是Keystone运作的例子：</p>
<p><strong>第 1 步 登录</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxleSFk8sxVTUxuibcQyicibaSCTvbjlb0WxiaMBIR4icdhyic5mJ97oc8Ld6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当点击<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxwjzH7jyFGEYpbaGt3defG7DW9HnuHjhXRUtXw6208wflf6G6S541Vg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">时，OpenStack 内部发生了哪些事情？请看下面</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxbibiaxgJU3lPxbllrLobtc0O1unT1zau0hYJEFqkqpI3r4HU13ibP2x4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Token 中包含了 User 的 Role 信息</p>
<p><strong>第 2 步 显示操作界面</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxSibOG7PwlWGToOrxulMXx6XembGB2uKMlQCYOI3oEx88dakWAibBWmVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>请注意，顶部显示 admin 可访问的  Project 为 “admin” 和 “demo”。 其实在此之前发生了一些事情：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxbm2acjkegnZOcZk1r2e27Y2FyBiauRnNz0icV1TnsughYEflBVIBlKOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>同时，admin 可以访问 Intance, Volume, Image 等服务</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxdLKxHd2bmhsAl23Yv9T6icoT9qRmRom8kOPUrsw669CU49E2N0FgG4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是因为 admin 已经从 Keystone 拿到了各 Service 的 Endpoints</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxNjSVFicMrzicW9vT7hG6WZ81ohZxNFrS3OqNDwbVtP4Nd5CvRhTHzS8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>第 3 步 显示 image 列表</strong></p>
<p>点击 “Images”，会显示 image 列表</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSx9fNGZKjvHqCichIXPN0B1hTZd4rmPsCqPTGNQ0ueOmcA1ic35669Wsrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>背后发生了这些事：</p>
<p>首先 admin 将请求发送到 Glance 的 Endpoint</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxAtRkENfMOcEccZuKVEM9x5zZ8Zu9jvWeGJcBicPVNSQTOBmRFRHS5Ng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Glance 向 Keystone 询问 admin 身份是否有效</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxnVgRLtf0KjqeWQ1BeOR00kddTNgHJTYPFrbAqyxmiapHFotz4qr5Fdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>接下来 Glance 会查看 /etc/glance/policy.json 判断 admin 是否有查看 image 的权限</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxDwkYzcnY04u4XQ7XPvAbXxc2sHjpjsEOlPS0oSic7MIXwdCmQjoIsLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>权限判定通过，Glance 将 image 列表发给 admin。</p>
<h1 id="镜像Glance"><a href="#镜像Glance" class="headerlink" title="镜像Glance"></a>镜像Glance</h1><p>OpenStack 由 Glance 提供 Image 服务。</p>
<blockquote>
<p> <strong>理解 Image</strong></p>
</blockquote>
<p>要理解 Image Service，先得搞清楚什么是 Image 以及为什么要用 Image？</p>
<p>在传统 IT 环境下，安装一个系统要么从安装 CD 从头安装，要么用 Ghost 等克隆工具恢复。这两种方式有如下几个问题：</p>
<ol>
<li>如果要安装的系统多了效率就很低</li>
<li>时间长，工作量大</li>
<li>安装完还要进行手工配置，比如安装其他的软件，设置 IP 等</li>
<li>备份和恢复系统不灵活</li>
</ol>
<p>云环境下需要更高效的方案，这就是 Image。 Image 是一个模板，里面包含了基本的操作系统和其他的软件。</p>
<p>举例来说，有家公司需要为每位员工配置一套办公用的系统，一般需要一个 Win7 系统再加 MS office 软件。 OpenStack 是这么玩的：</p>
<ol>
<li><p>先手工安装好这么一个虚机</p>
</li>
<li><p>然后对虚机执行 snapshot，这样就得到了一个 image</p>
</li>
<li><p>当有新员工入职需要办公环境时，立马启动一个或多个该 image 的 instance（虚机）就可以了</p>
</li>
</ol>
<p>在这个过程中，第 1 步跟传统方式类似，需要手工操作和一定时间，但第 2、3 步非常快，全自动化，一般都是秒级别。而且 2、3 步可以循环做。 比如公司新上了一套 OA 系统，每个员工的 PC 上都得有客户端软件。 那么可以在某个现有虚机中先手工安装好 OA 客户端，然后执行 snapshot 操作，得到新的 image，以后可以就直接使用新 image 创建虚机了。另外，snapshot 还有备份的作用，能够非常方便的恢复系统。</p>
<blockquote>
<p><strong>理解Image Service</strong></p>
</blockquote>
<p>Image Service 的功能是管理 Image，让用户能够发现、获取和保存 Image。在 OpenStack 中，提供 Image Service 的是 Glance，其具体功能如下：</p>
<ol>
<li>提供 REST API 让用户能够查询和获取 image 的元数据和 image 本身</li>
<li>支持多种方式存储 image，包括普通的文件系统、Swift、Amazon S3 等</li>
<li>对 Instance 执行 Snapshot 创建新的 image</li>
</ol>
<h3 id="Glance架构"><a href="#Glance架构" class="headerlink" title="Glance架构"></a><strong>Glance架构</strong></h3><p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNTNNp6sY0DicaymCAuHMsAjvUrxuB9DdYiaFAPuVIHKYDxibUrXabCzUjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<p>上面是 Glance 的架构图</p>
<h4 id="glance-api"><a href="#glance-api" class="headerlink" title="glance-api"></a><strong>glance-api</strong></h4><p>glance-api 是系统后台运行的服务进程。 对外提供 REST API，响应 image 查询、获取和存储的调用。</p>
<p>glance-api 不会真正处理请求。 如果操作是与 image metadata（元数据）相关，glance-api 会把请求转发给 glance-registry； 如果操作是与 image 自身存取相关，glance-api 会把请求转发给该 image 的 store backend。</p>
<p>在控制节点上可以查看 glance-api 进程</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNytPPuKCkITlL30ac6LlgFGJMoqRCOEfdBCqbB5ffj6sFwWRibXXc4Rg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="glance-registry"><a href="#glance-registry" class="headerlink" title="glance-registry"></a><strong>glance-registry</strong></h4><p>glance-registry 是系统后台运行的服务进程。 负责处理和存取 image 的 metadata，例如 image 的大小和类型。在控制节点上可以查看 glance-registry 进程</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNkRicyFx3ALNxOKlicibuwxR01XWbJicajicF1yAAnCKVDIQMx4XrOuZACFA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Glance 支持多种格式的 image，包括</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNykY5eXxtnQiaUnHhMR7x2sAQ3sNd9VgptlVjMZib6GOZPkw21fnUuZOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a><strong>Database</strong></h4><p>Image 的 metadata 会保持到 database 中，默认是 MySQL。 在控制节点上可以查看 glance 的 database 信息</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNB38ZPb2w8xMVUs8XZZZ3aJ4TpIy7PTsv68Sg1WhhXQPeZJStAciaNKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="Store-backend"><a href="#Store-backend" class="headerlink" title="Store backend"></a><strong>Store backend</strong></h4><p>Glance 自己并不存储 image。 真正的 image 是存放在 backend 中的。 Glance 支持多种 backend，包括：</p>
<ol>
<li>A directory on a local file system（这是默认配置）</li>
<li>GridFS</li>
<li>Ceph RBD</li>
<li>Amazon S3</li>
<li>Sheepdog</li>
<li>OpenStack Block Storage (Cinder)</li>
<li>OpenStack Object Storage (Swift)</li>
<li>VMware ESX</li>
</ol>
<p>具体使用哪种 backend，是在 /etc/glance/glance-api.conf 中配置的<br>在我们的 devstack 环境中，image 存放在控制节点本地目录 /opt/stack/data/glance/images/ 中</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNiaU5wkNHXPNHlLNzLAyz8VricN8XxG7B6n0T8UupITiboz0oAWpeFJhaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其他 backend 的配置可参考<a target="_blank" rel="noopener" href="http://docs.openstack.org/liberty/config-reference/content/configuring-image-service-backends.html">http://docs.openstack.org/liberty/config-reference/content/configuring-image-service-backends.html</a></p>
<p>查看目前已经存在的 image</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNYywoRibibobzDHUkibR1y1wexueDmQnDcelsa2jgv0Nnyt812kuVCFM5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>查看保存目录</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPN51bK22FuiaUicc4ES3WneFxvIfkj69rtCKtSzzvWDqlur3yL1QQsFiaFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>每个 image 在目录下都对应有一个文件，文件以 image 的 ID 命名。</p>
<h3 id="CLI-创建-image"><a href="#CLI-创建-image" class="headerlink" title="CLI 创建 image"></a>CLI 创建 image</h3><p>cirros 这个 linux 镜像很小，通过 Web UI 上传很快，操作会很顺畅。但如果我们要上传的镜像比较大（比如好几个 G ），那么操作会长时间停留在上传的 Web 界面，我们也不知道目前到底处于什么状态。 对于这样的操作，CLI 是更好的选择。</p>
<ol>
<li><p>将 image 上传到控制节点的文件系统中，例如 /tmp/cirros-0.3.4-x86_64-disk.img</p>
</li>
<li><p>设置环境变量<br><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFw4ICM9axnNmF0hriaVdzGFkw04rhxv4kibV9jcBbhxOayLOVeNudtblkrJMG8sZuDXEibDS1JkqLzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>Devstack 的安装目录下有个 openrc 文件。source 该文件就可以配置 CLI 的环境变量。这里我们传入了两个参数，第一个参数是 OpenStack 用户名 admin；第二个参数是 Project 名 admin</p>
</li>
<li><p>执行 image 创建命令</p>
</li>
</ol>
<blockquote>
<p>glance image-create –name cirros –file /tmp/cirros-0.3.4-x86_64-disk.img –disk-format qcow2 –container-format bare –progress</p>
</blockquote>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFw4ICM9axnNmF0hriaVdzGF77o6825q5KpNs4oLOWecxXOYCgAT23sxJ8TSgwKKyMsskibAmhxeibtA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在创建 image 的 CLI 参数中我们用 –progress 让其显示文件上传的百分比 %，是不是比 Web UI更直观呢？</p>
<p>在 /opt/stack/data/glance/images/ 下查看新的 Image<br><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFw4ICM9axnNmF0hriaVdzGFSCgUvvRBK3EuJuoOFNbYavs1Jppa12wdtel2mblzHH4tgt682kqp4g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="计算Nova"><a href="#计算Nova" class="headerlink" title="计算Nova"></a>计算Nova</h1><p>Compute Service Nova 是 OpenStack 最核心的服务，负责维护和管理云环境的计算资源。OpenStack 作为 IaaS 的云操作系统，虚拟机生命周期管理也就是通过 Nova 来实现的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5FlecmqKgwxsIhShOn3DcoSGyyCKDnQINagzSrmpUHdBNDz5pROg4b8t2c9Bw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>在上图中可以看到，Nova 处于 Openstak 架构的中心，其他组件都为 Nova 提供支持： Glance 为 VM 提供 image ；Cinder 和 Swift 分别为 VM 提供块存储和对象存储； Neutron 为 VM 提供网络连接。Nova 架构如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5FlecmqHNp317xLg3wSRZdbM0zMbKzXmplOrWpVEvqNZvCm37LmcbbCPdLMFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>Nova 的架构比较复杂，包含很多组件。 这些组件以子服务（后台 deamon 进程）的形式运行，可以分为以下几类：</p>
<ol>
<li><strong>API</strong></li>
</ol>
<p><strong>nova-api</strong></p>
<p>接收和响应客户的 API 调用。 除了提供 OpenStack 自己的API，nova-api 还支持 Amazon EC2 API。 也就是说，如果客户以前使用 Amazon EC2，并且用 EC2 的 API 开发了些工具来管理虚机，那么如果现在要换成 OpenStack，这些工具可以无缝迁移到 OpenStack，因为 nova-api 兼容 EC2 API，无需做任何修改。</p>
<ol start="2">
<li><strong>Compute Core</strong></li>
</ol>
<p>**nova-scheduler<br>**</p>
<p>虚机调度服务，负责决定在哪个计算节点上运行虚机</p>
<p>**nova-compute<br>**</p>
<p>管理虚机的核心服务，通过调用 Hypervisor API 实现虚机生命周期管理</p>
<p><strong>Hypervisor</strong><br>计算节点上跑的虚拟化管理程序，虚机管理最底层的程序。 不同虚拟化技术提供自己的 Hypervisor。 常用的 Hypervisor 有 KVM，Xen， VMWare 等</p>
<p>**nova-conductor<br>**nova-compute 经常需要更新数据库，比如更新虚机的状态。 出于安全性和伸缩性的考虑，nova-compute 并不会直接访问数据库，而是将这个任务委托给 nova-conductor，这个我们后面详细讨论。</p>
<ol start="3">
<li><strong>Console Interface</strong></li>
</ol>
<p>**nova-console<br>**用户可以通过多种方式访问虚机的控制台：<br>nova-novncproxy，基于 Web 浏览器的 VNC 访问<br>nova-spicehtml5proxy，基于 HTML5 浏览器的 SPICE 访问<br>nova-xvpnvncproxy，基于 Java 客户端的 VNC 访问</p>
<p>**nova-consoleauth<br>**负责对访问虚机控制台请求提供 Token 认证</p>
<p>**nova-cert<br>**</p>
<p>提供 x509 证书支持</p>
<p><strong>Database</strong></p>
<p>Nova 会有一些数据需要存放到数据库中，一般使用 MySQL。数据库安装在控制节点上。 Nova 使用命名为 “nova” 的数据库。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5FlecmqXXgZK8iasQUn19266AU5OjrBEBia04XWiayibdSEt9HuyicicfWSMmiaphaVA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol start="4">
<li><strong>Message Queue</strong></li>
</ol>
<p>在前面我们了解到 Nova 包含众多的子服务，这些子服务之间需要相互协调和通信。为解耦各个子服务，Nova 通过 Message Queue 作为子服务的信息中转站。 所以在架构图上我们看到了子服务之间没有直接的连线，是通过 Message Queue 联系的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5Flecmq1MnOd7sk1MQ9qaqGnblVDIO3AWldVC272H8moOq1jWOrXc9vKNEtLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>OpenStack 默认是用 RabbitMQ 作为 Message Queue。 MQ 是 OpenStack 的核心基础组件，我们后面也会详细介绍。</p>
<h3 id="Nova物理部署方案"><a href="#Nova物理部署方案" class="headerlink" title="Nova物理部署方案"></a>Nova物理部署方案</h3><p>前面大家已经看到 Nova 由很多子服务组成，我们也知道 OpenStack 是一个分布式系统，可以部署到若干节点上，那么接下来大家可能就会问：Nova 的这些服务在物理上应该如何部署呢？</p>
<p>对于 Nova，这些服务会部署在两类节点上：计算节点和控制节点。</p>
<p>计算节点上安装了 Hypervisor，上面运行虚拟机。 由此可知：</p>
<ol>
<li>只有 nova-compute 需要放在计算节点上。</li>
<li>其他子服务则是放在控制节点上的。</li>
</ol>
<p>下面我们可以看看实验环境的具体部署情况。 通过在计算节点和控制节点上运行 ps -elf|grep nova 来查看运行的 nova 子服务</p>
<p><strong>计算节点</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4T4YbLP6QicpCdZVb7E9rMQV42cQM5icDonQ52Ria5Wc9Pla3YBWqHdqeDg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>计算节点 devstack-compute1 上只运行了 nova-compute 子服务</p>
<p><strong>控制节点</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TGzZZyOaLQ0rKQ4z32uSOoZal6VPLVKMVAdhSS2hAurER56ctOjT30A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>控制节点 devstack-controller 上运行了若干 nova-* 子服务</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TDwBbic4NWnDw7lWXWuAsH5ibS5JP9dWR7q0oaVxCzKM1yD0IXNmJOicWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RabbitMQ 和 MySQL 也是放在控制节点上的。可能细心的同学已经发现我们的控制节点上也运行了 nova-compute。 这实际上也就意味着 devstack-controller 既是一个控制节点，同时也是一个计算节点，也可以在上面运行虚机。</p>
<p>这也向我们展示了 OpenStack 这种分布式架构部署上的灵活性： 可以将所有服务都放在一台物理机上，作为一个 All-in-One 的测试环境； 也可以将服务部署在多台物理机上，获得更好的性能和高可用。</p>
<p>另外，也可以用 nova service-list 查看 nova-* 子服务都分布在哪些节点上</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TnljsTN8FSxnMLQkHNM7azuDgZZQLoIGgSy4D8HxlLlCjKQuib7BBsiaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="从虚拟机创建流程看-nova-子服务如何协同工作"><a href="#从虚拟机创建流程看-nova-子服务如何协同工作" class="headerlink" title="从虚拟机创建流程看 nova-* 子服务如何协同工作"></a>从虚拟机创建流程看 nova-* 子服务如何协同工作</h3><p>从学习 Nova 的角度看，虚机创建是一个非常好的场景，涉及的 nova-* 子服务很全，下面是流程图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TRWKlXWqV4VregAMebcImDmjicJBaMskoSOz7Qxvn0tQUGpovezyusibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol>
<li><p>客户（可以是 OpenStack 最终用户，也可以是其他程序）向 API（nova-api）发送请求：“帮我创建一个虚机”</p>
</li>
<li><p>API 对请求做一些必要处理后，向 Messaging（RabbitMQ）发送了一条消息：“让 Scheduler 创建一个虚机”</p>
</li>
<li><p>Scheduler（nova-scheduler）从 Messaging 获取到 API 发给它的消息，然后执行调度算法，从若干计算节点中选出节点 A</p>
</li>
<li><p>Scheduler 向 Messaging 发送了一条消息：“在计算节点 A 上创建这个虚机”</p>
</li>
<li><p>计算节点 A 的 Compute（nova-compute）从 Messaging 中获取到 Scheduler 发给它的消息，然后在本节点的 Hypervisor 上启动虚机。</p>
</li>
<li><p>在虚机创建的过程中，Compute 如果需要查询或更新数据库信息，会通过 Messaging 向 Conductor（nova-conductor）发送消息，Conductor 负责数据库访问。</p>
</li>
</ol>
<p>以上是创建虚机最核心的步骤，当然省略了很多细节，我们会在后面的章节详细讨论。 这几个步骤向我们展示了 nova-* 子服务之间的协作的方式，也体现了 OpenStack 整个系统的分布式设计思想，掌握这种思想对我们深入理解 OpenStack 会非常有帮助。</p>
<h3 id="OpenStack通用设计思路"><a href="#OpenStack通用设计思路" class="headerlink" title="OpenStack通用设计思路"></a>OpenStack通用设计思路</h3><p><strong>API 前端服务</strong></p>
<p>每个 OpenStack 组件可能包含若干子服务，其中必定有一个 API 服务负责接收客户请求。</p>
<p>以 Nova 为例，nova-api 作为 Nova 组件对外的唯一窗口，向客户暴露 Nova 能够提供的功能。 当客户需要执行虚机相关的操作，能且只能向 nova-api 发送 REST 请求。 这里的客户包括终端用户、命令行和 OpenStack 其他组件。</p>
<p>设计 API 前端服务的好处在于：</p>
<ol>
<li>对外提供统一接口，隐藏实现细节</li>
<li>API 提供 REST 标准调用服务，便于与第三方系统集成</li>
<li>可以通过运行多个 API 服务实例轻松实现 API 的高可用，比如运行多个 nova-api 进程</li>
</ol>
<p><strong>Scheduler 调度服务</strong></p>
<p>对于某项操作，如果有多个实体都能够完成任务，那么通常会有一个 scheduler 负责从这些实体中挑选出一个最合适的来执行操作。</p>
<p>在前面的例子中，Nova 有多个计算节点。 当需要创建虚机时，nova-scheduler 会根据计算节点当时的资源使用情况选择一个最合适的计算节点来运行虚机。</p>
<p>调度服务好比是开发团队中的项目经理，当接到新的开发任务后，项目经理会评估任务的难度，考察团队成员目前的工作负荷和技能水平，然后将任务分配给最合适的开发人员。除了 Nova，块服务组件 Cinder 也有 scheduler 子服务，后面我们会详细讨论。</p>
<p><strong>Worker 工作服务</strong></p>
<p>调度服务只管分配任务，真正执行任务的是 Worker 工作服务。在 Nova 中，这个 Worker 就是 nova-compute 了。 将 Scheduler 和 Worker 从职能上进行划分使得 OpenStack 非常容易扩展：</p>
<ol>
<li><p>当计算资源不够了无法创建虚机时，可以增加计算节点（增加 Worker）</p>
</li>
<li><p>当客户的请求量太大调度不过来时，可以增加 Scheduler</p>
</li>
</ol>
<p><strong>Driver 框架</strong></p>
<p>OpenStack 作为开放的 Infrastracture as a Service 云操作系统，支持业界各种优秀的技术。这些技术可能是开源免费的，也可能是商业收费的。 这种开放的架构使得 OpenStack 能够在技术上保持先进性，具有很强的竞争力，同时又不会造成厂商锁定（Lock-in）。</p>
<p>那 OpenStack 的这种开放性体现在哪里呢？</p>
<p>一个重要的方面就是采用基于 Driver 的框架。以 Nova 为例，OpenStack 的计算节点支持多种 Hypervisor。 包括 KVM, Hyper-V, VMWare, Xen, Docker, LXC 等。Nova-compute 为这些 Hypervisor 定义了统一的接口，hypervisor 只需要实现这些接口，就可以 driver 的形式即插即用到 OpenStack 中。 下面是 nova driver 的架构示意图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXweGlUiaBQz6jNXOAe1QnB3V4OGqsVQkPDUJQHicvTlx1lMNNeMxXWuasQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 nova-compute 的配置文件 /etc/nova/nova.conf 中由 compute_driver 配置项指定该计算节点使用哪种 Hypervisor 的 driver</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXwY03evSaDhos36slFHU9jNC3ibs5jhgF8PKcCpvC3juHeqhyh29Wiaoibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">   </p>
<p>在我们的环境中因为是 KVM，所以配置的是 Libvirt 的 driver。</p>
<p>不知大家是否记得我们在学习 Glance 时谈到： OpenStack 支持多种 backend 来存放 image。 可以是本地文件系统，Cinder，Ceph，Swift 等。其实这也是一个 driver 架构。 只要符合 Glance 定义的规范，新的存储方式可以很方便的加入到 backend 支持列表中。在后面 Cinder 和 Neutron 中我们还会看到 driver 框架的应用。</p>
<p><strong>Messaging 服务</strong></p>
<p>在前面创建虚机的流程示意图中，我们看到 nova-* 子服务之间的调用严重依赖 Messaging。Messaging 是 nova-* 子服务交互的中枢。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXwZ1HkUPq0ctJUDhLOG6jibliaH2xXFdmdPUpFrE8PFjgzsfmFA9t7ECJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>以前没接触过分布式系统的同学可能会不太理解为什么不让 API 直接调用Scheduler，或是让Scheuler 直接调用 Compute，而是非要通过 Messaging 进行中转。 这里做一些解释。程序之间的调用通常分两种：同步调用和异步调用。</p>
<p><strong>同步调用</strong></p>
<p>API 直接调用 Scheduler 的接口是同步调用。 其特点是 API 发出请求后需要一直等待，直到 Scheduler 完成对 Compute 的调度，将结果返回给 API 后 API 才能够继续做后面的工作。</p>
<p><strong>异步调用</strong></p>
<p>API 通过 Messaging 间接调用 Scheduler 就是异步调用。 其特点是 API 发出请求后不需要等待，直接返回，继续做后面的工作。 Scheduler 从 Messaging 接收到请求后执行调度操作，完成后将结果也通过 Messaging 发送给 API。在 OpenStack 这类分布式系统中，通常采用异步调用的方式，其好处是：</p>
<ol>
<li><p>解耦各子服务。 子服务不需要知道其他服务在哪里运行，只需要发送消息给 Messaging 就能完成调用。</p>
</li>
<li><p>提高性能 异步调用使得调用者无需等待结果返回。这样可以继续执行更多的工作，提高系统总的吞吐量。</p>
</li>
<li><p>提高伸缩性 子服务可以根据需要进行扩展，启动更多的实例处理更多的请求，在提高可用性的同时也提高了整个系统的伸缩性。而且这种变化不会影响到其他子服务，也就是说变化对别人是透明的。</p>
</li>
</ol>
<p>在后面各章节，我们都能看到 Messaging 的应用。</p>
<p><strong>Database</strong></p>
<p>OpenStack 各组件需要维护自己的状态信息。比如 Nova 中有虚机的规格、状态，这些信息都是在数据库中维护的。 每个 OpenStack 组件在 MySQL 中有自己的数据库。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXwxQp6seHuX8ibGeqqCnu0EKCqiacKNvmlJ149MrdbdPOe1GmwEC3yEQPQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p><strong>小结</strong></p>
<p>Nova 是 OpenStack 中最重要的组件，也是很典型的组件。Nova 充分体现了 OpenStack 的设计思路。 理解了这种思路，再来学习 OpenStack 的其他组件就能够举一反三，清晰容易很多。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UxQAxoSIhr3SOv0ISGTtYw">https://mp.weixin.qq.com/s/UxQAxoSIhr3SOv0ISGTtYw</a></p>
<p>我们在后面 Cinder 和 Neutron 的学习中还会回顾这些设计思路。</p>
<h1 id="存储Cinder"><a href="#存储Cinder" class="headerlink" title="存储Cinder"></a>存储Cinder</h1><h3 id="Cinder框架"><a href="#Cinder框架" class="headerlink" title="Cinder框架"></a>Cinder框架</h3><p>从本节开始我们学习 OpenStack 的 Block Storage Service，Cinder。</p>
<p><strong>理解 Block Storage</strong></p>
<p>操作系统获得存储空间的方式一般有两种：</p>
<ol>
<li><p>通过某种协议（SAS,SCSI,SAN,iSCSI 等）挂接裸硬盘，然后分区、格式化、创建文件系统；或者直接使用裸硬盘存储数据（数据库）</p>
</li>
<li><p>通过 NFS、CIFS 等 协议，mount 远程的文件系统</p>
</li>
</ol>
<p>第一种裸硬盘的方式叫做 Block Storage（块存储），每个裸硬盘通常也称作 Volume（卷） 第二种叫做文件系统存储。NAS 和 NFS 服务器，以及各种分布式文件系统提供的都是这种存储。</p>
<p><strong>理解 Block Storage Service</strong></p>
<p>Block Storage Servicet 提供对 volume 从创建到删除整个生命周期的管理。从 instance 的角度看，挂载的每一个 Volume 都是一块硬盘。OpenStack 提供 Block Storage Service 的是 Cinder，其具体功能是：</p>
<ol>
<li><p>提供 REST API 使用户能够查询和管理 volume、volume snapshot 以及 volume type</p>
</li>
<li><p>提供 scheduler 调度 volume 创建请求，合理优化存储资源的分配</p>
</li>
<li><p>通过 driver 架构支持多种 back-end（后端）存储方式，包括 LVM，NFS，Ceph 和其他诸如 EMC、IBM 等商业存储产品和方案</p>
</li>
</ol>
<p><strong>Cinder 架构</strong></p>
<p>下图是 cinder 的逻辑架构图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CokOFtGNmp736wqAWfJwx8AnC714u6LtvHucmGWDZgNmFwe4G8G1Mww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>Cinder 包含如下几个组件：</p>
<p>**cinder-api<br>**接收 API 请求，调用 cinder-volume 。</p>
<p>**cinder-volume<br>**管理 volume 的服务，与 volume provider 协调工作，管理 volume 的生命周期。运行 cinder-volume 服务的节点被称作为存储节点。</p>
<p>**cinder-scheduler<br>**scheduler 通过调度算法选择最合适的存储节点创建 volume。</p>
<p>**volume provider<br>**数据的存储设备，为 volume 提供物理存储空间。 cinder-volume 支持多种 volume provider，每种 volume provider 通过自己的 driver 与cinder-volume 协调工作。</p>
<p>**Message Queue<br>**Cinder 各个子服务通过消息队列实现进程间通信和相互协作。因为有了消息队列，子服务之间实现了解耦，这种松散的结构也是分布式系统的重要特征。</p>
<p><strong>Database Cinder</strong> </p>
<p>有一些数据需要存放到数据库中，一般使用 MySQL。数据库是安装在控制节点上的，比如在我们的实验环境中，可以访问名称为“cinder”的数据库。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CxMKsjeAZqnGWvOs48icEiam9KM9ISoHT9uTOFeLPkFKsZY9wErc96JCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p><strong>物理部署方案</strong></p>
<p>Cinder 的服务会部署在两类节点上，控制节点和存储节点。我们来看看控制节点 devstack-controller 上都运行了哪些 cinder-* 子服务。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7Cu6zMeoesOEYtxhAWLeNicpqd2C8KYqnrtpv7aCz8P0M6MtichO7n7Txg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>cinder-api 和 cinder-scheduler 部署在控制节点上，这个很合理。</p>
<p>至于 cinder-volume 也在控制节点上可能有些同学就会迷糊了：cinder-volume 不是应该部署在存储节点上吗？</p>
<p>要回答这个问题，首先要搞清楚一个事实： OpenStack 是分布式系统，其每个子服务都可以部署在任何地方，只要网络能够连通。无论是哪个节点，只要上面运行了 cinder-volume，它就是一个存储节点，当然，该节点上也可以运行其他 OpenStack服务。</p>
<p>cinder-volume 是一顶存储节点帽子，cinder-api 是一顶控制节点帽子。在我们的环境中，devstack-controller 同时戴上了这两顶帽子，所以它既是控制节点，又是存储节点。当然，我们也可以用一个专门的节点来运行 cinder-volume。</p>
<p>这再一次展示了 OpenStack 分布式架构部署上的灵活性： 可以将所有服务都放在一台物理机上，用作一个 All-in-One 的测试环境；而在生产环境中可以将服务部署在多台物理机上，获得更好的性能和高可用。</p>
<p>RabbitMQ 和 MySQL 通常放在控制节点上。另外，也可以用 cinder service list 查看 cinder-* 子服务都分布在哪些节点上</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CtOib4cKjOdhrG6PZdicOGic55SywOK57tWwpBB3dVEcmS0L6neVIpKsicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>还有一个问题：volume provider 放在那里？</p>
<p>一般来讲，volume provider 是独立的。cinder-volume 使用 driver 与 volume provider 通信并协调工作。所以只需要将 driver 与 cinder-volume 放到一起就可以了。在 cinder-volume 的源代码目录下有很多 driver，支持不同的 volume provider。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CLK2oSbyLhJKjzJwxibb4MCicP4tQZzcn7rNKzMK3Z6lLtlFWSSYQTWjg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>后面我们会以 LVM 和 NFS 这两种 volume provider 为例讨论 cinder-volume 的使用，其他 volume provider 可以查看 OpenStack 的 configuration 文档。</p>
<p>下一节我们将讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587767&idx=1&sn=e3535a2ccf793e5591d633cbd9d5879c&chksm=8d30812eba470838464262dc60bed1b50c4ad63342a7dae3a7b1af08ab4effcd463efbbe7209&scene=21#wechat_redirect">Cinder 的这些组件如何协调工作</a>。</p>
<h3 id="Cinder-设计思想"><a href="#Cinder-设计思想" class="headerlink" title="Cinder 设计思想"></a>Cinder 设计思想</h3><p>上一节介绍了<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587138&idx=1&sn=eedfae7ccae28a5081342b29035cb578&scene=21#wechat_redirect"> Cinder 的架构</a>，这节讨论 Cinder 个组件如何协同工作及其设计思想。</p>
<p><strong>从 volume 创建流程看 cinder-* 子服务如何协同工作</strong></p>
<p>对于 Cinder 学习来说，Volume 创建是一个非常好的场景，涉及各个 cinder-* 子服务，下面是流程图。<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFDVXiaL6zITRP8Ol2r6gWEVQp6lA7mLyiaWPV9ORJicCAQOQcrNXvV1rWF5MbjkcgyrUO15eG7fxxKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol>
<li><p>客户（可以是 OpenStack 最终用户，也可以是其他程序）向 API（cinder-api）发送请求：“帮我创建一个 volume”</p>
</li>
<li><p>API 对请求做一些必要处理后，向 Messaging（RabbitMQ）发送了一条消息：“让 Scheduler 创建一个 volume”</p>
</li>
<li><p>Scheduler（cinder-scheduler）从 Messaging 获取到 API 发给它的消息，然后执行调度算法，从若干计存储点中选出节点 A</p>
</li>
<li><p>Scheduler 向 Messaging 发送了一条消息：“让存储节点 A 创建这个 volume”</p>
</li>
<li><p>存储节点 A 的 Volume（cinder-volume）从 Messaging 中获取到 Scheduler 发给它的消息，然后通过 driver 在 volume provider 上创建 volume。</p>
</li>
</ol>
<p>上面是创建虚机最核心的几个步骤，当然省略了很多细节，我们会在后面的章节详细讨论。</p>
<p><strong>Cinder 的设计思想</strong></p>
<p>Cinder 延续了 Nova 的以及其他组件的设计思想。</p>
<p><strong>API 前端服</strong>务</p>
<p>cinder-api 作为 Cinder 组件对外的唯一窗口，向客户暴露 Cinder 能够提供的功能，当客户需要执行 volume 相关的操作，能且只能向 cinder-api 发送 REST 请求。这里的客户包括终端用户、命令行和 OpenStack 其他组件。</p>
<p>设计 API 前端服务的好处在于：</p>
<ol>
<li>对外提供统一接口，隐藏实现细节</li>
<li>API 提供 REST 标准调用服务，便于与第三方系统集成</li>
<li>可以通过运行多个 API 服务实例轻松实现 API 的高可用，比如运行多个 cinder-api 进程</li>
</ol>
<p><strong>Scheduler 调度服务</strong></p>
<p>Cinder 可以有多个存储节点，当需要创建 volume 时，cinder-scheduler 会根据存储节点的属性和资源使用情况选择一个最合适的节点来创建 volume。</p>
<p>调度服务就好比是一个开发团队中的项目经理，当接到新的开发任务时，项目经理会根据任务的难度，每个团队成员目前的工作负荷和技能水平，将任务分配给最合适的开发人员。</p>
<p><strong>Worker 工作服务</strong></p>
<p>调度服务只管分配任务，真正执行任务的是 Worker 工作服务。</p>
<p>在 Cinder 中，这个 Worker 就是 cinder-volume 了。这种 Scheduler 和 Worker 之间职能上的划分使得 OpenStack 非常容易扩展：当存储资源不够时可以增加存储节点（增加 Worker）。 当客户的请求量太大调度不过来时，可以增加 Scheduler。</p>
<p><strong>Driver 框架</strong></p>
<p>OpenStack 作为开放的 Infrastracture as a Service 云操作系统，支持业界各种优秀的技术，这些技术可能是开源免费的，也可能是商业收费的。</p>
<p>这种开放的架构使得 OpenStack 保持技术上的先进性，具有很强的竞争力，同时又不会造成厂商锁定（Lock-in）。 那 OpenStack 的这种开放性体现在哪里呢？一个重要的方面就是采用基于 Driver 的框架。</p>
<p>以 Cinder 为例，存储节点支持多种 volume provider，包括 LVM, NFS, Ceph, GlusterFS，以及 EMC, IBM 等商业存储系统。 cinder-volume 为这些 volume provider 定义了统一的 driver 接口，volume provider 只需要实现这些接口，就可以 driver 的形式即插即用到 OpenStack 中。下面是 cinder driver 的架构示意图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFDVXiaL6zITRP8Ol2r6gWEVO8ia9mZVXLQvqohgOhQZgb2eZLIOMrgmibzAlR8PPfxmAl9w8DAj813Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 cinder-volume 的配置文件 /etc/cinder/cinder.conf 中 volume_driver 配置项设置该存储节点使用哪种 volume provider 的 driver，下面的示例表示使用的是 LVM。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFDVXiaL6zITRP8Ol2r6gWEVvA8S0REdgtpFn7eH9QmZuAHjX8ibYDmgzicY4OuAIdXTVJGvc1Zaw2Mg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>下一节我们将详细讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587763&idx=1&sn=1374e3e2bcc453b782f0eb8a78f46ad6&chksm=8d30812aba47083cbe1f0aa93b3eff408590397eb2c88fe040eafd15b04888d0d1d116405d18&scene=21#wechat_redirect">Cinder 的每一个组件</a>。</p>
<h3 id="Cinder-的组件"><a href="#Cinder-的组件" class="headerlink" title="Cinder 的组件"></a>Cinder 的组件</h3><p>从本节开始，我们将详细讲解 Cinder 的各个子服务。</p>
<h4 id="cinder-api"><a href="#cinder-api" class="headerlink" title="cinder-api"></a>cinder-api</h4><p><strong>cinder-api</strong></p>
<p>cinder-api 是整个 Cinder 组件的门户，所有 cinder 的请求都首先由 cinder-api 处理。cinder-api 向外界暴露若干 HTTP REST API 接口。在 keystone 中我们可以查询 cinder-api 的 endponits。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWNgTGP6APlAdTUic8iaUfJicUTmC2wxlgbI4U5YE0oeqlGn5HWRgo2k9Mw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>客户端可以将请求发送到 endponits 指定的地址，向 cinder-api 请求操作。 当然，作为最终用户的我们不会直接发送 Rest API 请求。OpenStack CLI，Dashboard 和其他需要跟 Cinder 交换的组件会使用这些 API。</p>
<p>cinder-api 对接收到的 HTTP API 请求会做如下处理：</p>
<ol>
<li>检查客户端传人的参数是否合法有效</li>
<li>调用 cinder 其他子服务的处理客户端请求</li>
<li>将 cinder 其他子服务返回的结果序列号并返回给客户端</li>
</ol>
<p>cinder-api 接受哪些请求呢？简单的说，只要是 Volume 生命周期相关的操作，cinder-api 都可以响应。大部分操作都可以在 Dashboard 上看到。</p>
<p>打开 Volume 管理界面</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWcA3ibeM5ibYRUtyDHUnMPDYdp6GBCiaeMJyS5U28G00yrVPibC6JlapZLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击下拉箭头，列表中就是 cinder-api 可执行的操作。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWsWcjBTZ10HDTQLCrJa9oaKG519iaibkxiazIdxPnDb8F6YXI1u28vvKlQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>cinder-scheduler</strong></p>
<p>创建 Volume 时，cinder-scheduler 会基于容量、Volume Type 等条件选择出最合适的存储节点，然后让其创建 Volume。这个部分比较多，我们下一次单独讨论。</p>
<p><strong>cinder-volume</strong></p>
<p>cinder-volume 在存储节点上运行，OpenStack 对 Volume 的操作，最后都是交给 cinder-volume 来完成的。cinder-volume 自身并不管理真正的存储设备，存储设备是由 volume provider 管理的。cinder-volume 与 volume provider 一起实现 volume 生命周期的管理。</p>
<p><strong>通过 Driver 架构支持多种 Volume Provider</strong></p>
<p>接着的问题是：现在市面上有这么多块存储产品和方案（volume provider），cinder-volume 如何与它们配合呢？</p>
<p>这就是我们之前讨论过的 Driver 架构。 cinder-volume 为这些 volume provider 定义了统一的接口，volume provider 只需要实现这些接口，就可以 Driver 的形式即插即用到 OpenStack 系统中。下面是 Cinder Driver 的架构示意图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWMdvTzYEk3Wng4wGlD0jXkCM5ultVo687vFCEW5YHCQtAT9aJTJhgQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们可以在 /opt/stack/cinder/cinder/volume/drivers/ 目录下查看到 OpenStack 源代码中已经自带了很多 volume provider 的 Driver：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdW4AcbwbM5qKA2GPmohXPecWhicS4azKTp0piachMicCfOibotFogmyFjmnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>存储节点在配置文件 /etc/cinder/cinder.conf 中用 volume_driver 选项配置使用的driver：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWhtdibD5yEvCJq5oIs5AYbOKPOwpplIyibpQJKDZ0SQYSy4CXsVJgu8SQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里 LVM 是我们使用的 volume provider。</p>
<p><strong>定期向 OpenStack 报告计算节点的状态</strong></p>
<p>在前面 cinder-scheduler 会用到 CapacityFilter 和 CapacityWeigher，它们都是通过存储节点的空闲容量来做筛选。 那这里有个问题：Cinder 是如何得知每个存储节点的空闲容量信息的呢？</p>
<p>答案就是：<strong>cinder-volume 会定期向 Cinder 报告</strong>。</p>
<p>从 cinder-volume 的日志 /opt/stack/logs/c-vol.log 可以发现每隔一段时间，cinder-volume 就会报告当前存储节点的资源使用情况。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWIvR1gI2IuO4vUajEQdXodwLMGGuzYN0FibZuXVL1Hvc3eQSTriaiazrQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>因为在我们的实验环境中存储节点使用的是 LVM，所以在上面的日志看到存储节点通过“vgs”和”lvs”这两个命令获取 LVM 的容量使用信息。</p>
<p><strong>实现 volume 生命周期管理</strong></p>
<p>Cinder 对 volume 的生命周期的管理最终都是通过 cinder-volume 完成的，包括 volume 的 create、extend、attach、snapshot、delete 等，后面我们会详细讨论。下一节我们将详细讨论 cinder-scheduler 如何筛选 cinder-volume。</p>
<h4 id="cinder-schduler"><a href="#cinder-schduler" class="headerlink" title="cinder-schduler"></a>cinder-schduler</h4><p>上一节我们详细讨论了 cinder-api 和 cinder-volume，今天讨论另一个重要的 Cinder 组件 cinder-scheduler。</p>
<p>创建 Volume 时，cinder-scheduler 会基于容量、Volume Type 等条件选择出最合适的存储节点，然后让其创建 Volume。下面介绍 cinder-scheduler 是如何实现这个调度工作的。</p>
<p>在 /etc/cinder/cinder.conf 中，cinder 通过 scheduler_driver， scheduler_default_filters 和 scheduler_default_weighers 这三个参数来配置 cinder-scheduler。</p>
<p><strong>Filter scheduler</strong></p>
<p>Filter scheduler 是 cinder-scheduler 默认的调度器。</p>
<blockquote>
<p>scheduler_driver=cinder.scheduler.filter_scheduler.FilterScheduler</p>
</blockquote>
<p>与 Nova 一样，Cinder 也允许使用第三方 scheduler，配置 scheduler_driver 即可。</p>
<p>scheduler 调度过程如下：</p>
<ol>
<li>通过过滤器（filter）选择满足条件的存储节点（运行 cinder-volume）</li>
<li>通过权重计算（weighting）选择最优（权重值最大）的存储节点。</li>
</ol>
<p>可见，cinder-scheduler 的运行机制与 nova-scheduler 完全一样。</p>
<p><strong>Filter</strong></p>
<p>当 Filter scheduler 需要执行调度操作时，会让 filter 对存储节点进行判断，filter 返回 True 或者 False。cinder.conf 中 scheduler_default_filters 选项指定 filter scheduler 使用的 filter，默认值为：</p>
<blockquote>
<p>scheduler_default_filters = AvailabilityZoneFilter, CapacityFilter, CapabilitiesFilter</p>
</blockquote>
<p>Filter scheduler 将按照上面的顺序依次过滤：</p>
<p>AvailabilityZoneFilter</p>
<p>为提高容灾性和提供隔离服务，可以将存储节点和计算节点划分到不同的 Availability Zone 中。例如把一个机架上的机器划分在一个 Availability Zone 中。OpenStack 默认有一个命名为“Nova”的 Availability Zone，所有的节点初始都是放在“Nova”中。用户可以根据需要创建自己的 Availability Zone。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQ843WbfXuLQ6DRgZs2Q1exiahGWI7VxXLxwbAJZZdtAT32CEcBDqVIXA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>创建 Volume 时，需要指定 Volume 所属的 Availability Zone。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQw12TOdvw9kZoh3pXicxQgTU14hqBOlJBEW0eUeYT49DeCFjcqzFgFag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>cinder-scheduler 在做 filtering 时，会使用 AvailabilityZoneFilter 将不属于指定 Availability Zone 的存储节点过滤掉。</p>
<p>CapacityFilter</p>
<p>创建 Volume 时，用户会指定 Volume 的大小。CapacityFilter 的作用是将存储空间不能满足 Volume 创建需求的存储节点过滤掉。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQYaztxrefL4qKpgtTVVgB8ia2EKg3ic1hf6n6sIHNgxbIo3LqEGIn88Lw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>CapabilitiesFilter</p>
<p>不同的 Volume Provider 有自己的特性（Capabilities），比如是否支持 thin provision 等。Cinder 允许用户创建 Volume 时通过 Volume Type 指定需要的 Capabilities。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQV1bHaphZrryjz3qf68GepQ1dic0F2FVzhVWVFAibp0iavC7SCLsFNWO3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Volume Type 可以根据需要定义若干 Capabilities，详细描述 Volume 的属性。VolumeVolume Type 的作用与 Nova 的 flavor 类似。</p>
<p>Volume Type 在 Admin -&gt; System -&gt; Volume 菜单里管理</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQ0icjtiat2Tu6qj31O4ibZuYqQsrgSYH6G6bLeZvjfmgPG5XmRw3GiaGW0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过 Volume Type 的 Extra Specs 定义 Capabilities</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQl1yS1ZUIUKfMhBq0hQf4icezugxpVbZDj4DrTRLngahRYtMlibb6iaq8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Extra Specs 是用 Key-Value 的形式定义。 不同的 Volume Provider 支持的 Extra Specs 不同，需要参考 Volume Provider 的文档。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQn0Bttt8QrfiaibhlExOQic9mtjwSVibWqWwujMv7qDhFm6ics2EpztZwDcQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>上图所示的 Volume Type 只有一个 Extra Specs “volume_backend_name”，这是最重要也是必须的 Extra Specs。</p>
<p>cinder-volume 会在自己的配置文件 /etc/cinder/cinder.conf 中设置“volume_backend_name”这个参数，其作用是为存储节点的 Volume Provider 命名。这样，CapabilitiesFilter 就可以通过 Volume Type 的“volume_backend_name”筛选出指定的 Volume Provider。</p>
<p>不同的存储节点可以在各自的 cinder.conf 中配置相同的 volume_backend_name，这是允许的。因为虽然存储节点不同，但它们可能使用的是一种 Volume Provider。</p>
<p>如果在第一步 filtering 环节选出了多个存储节点，那么接下来的 weighting 环节会挑选出最合适的一个节点。</p>
<p><strong>Weighter</strong></p>
<p>Filter Scheduler 通过 scheduler_default_weighers 指定计算权重的 weigher，默认为 CapacityWeigher。</p>
<blockquote>
<p>scheduler_default_weighers = CapacityWeigher</p>
</blockquote>
<p>如命名所示，CapacityWeigher 基于存储节点的空闲容量计算权重值，空闲最多的胜出。下一节我们将开始通过各种场景学习 Cinder。</p>
<h1 id="网络Neutron"><a href="#网络Neutron" class="headerlink" title="网络Neutron"></a>网络Neutron</h1><h3 id="Neutron概述"><a href="#Neutron概述" class="headerlink" title="Neutron概述"></a>Neutron概述</h3><p>从今天开始，我们将学习 OpenStack 的 Networking Service，Neutron。</p>
<p>Neutron 的难度会比前面所有模块都大一些，内容也多一些。为了帮助大家更好的掌握 Neutorn，CloudMan 也会分析地更详细一些。</p>
<p><strong>Neutron 概述</strong></p>
<p>传统的网络管理方式很大程度上依赖于管理员手工配置和维护各种网络硬件设备；而云环境下的网络已经变得非常复杂，特别是在多租户场景里，用户随时都可能需要创建、修改和删除网络，网络的连通性和隔离不已经太可能通过手工配置来保证了。</p>
<p>如何快速响应业务的需求对网络管理提出了更高的要求。传统的网络管理方式已经很难胜任这项工作，而“软件定义网络（software-defined networking, SDN）”所具有的灵活性和自动化优势使其成为云时代网络管理的主流。</p>
<p>Neutron 的设计目标是实现“网络即服务（Networking as a Service）”。为了达到这一目标，在设计上遵循了基于 SDN 实现网络虚拟化的原则，在实现上充分利用了 Linux 系统上的各种网络相关的技术。</p>
<p>在这一章，我们将讨论 Neutron 的功能和它的各个组件，学习部署和配置 OpenStack 网络的不同方法，会涉及软件和硬件设备多个层面。</p>
<p><strong>Neutron 功能</strong></p>
<p>Neutron 为整个 OpenStack 环境提供网络支持，包括二层交换，三层路由，负载均衡，防火墙和 VPN 等。Neutron 提供了一个灵活的框架，通过配置，无论是开源还是商业软件都可以被用来实现这些功能。</p>
<p>二层交换 Switching</p>
<p>Nova 的 Instance 是通过虚拟交换机连接到虚拟二层网络的。Neutron 支持多种虚拟交换机，包括 Linux 原生的 Linux Bridge 和 Open vSwitch。 Open vSwitch（OVS）是一个开源的虚拟交换机，它支持标准的管理接口和协议。</p>
<p>利用 Linux Bridge 和 OVS，Neutron 除了可以创建传统的 VLAN 网络，还可以创建基于隧道技术的 Overlay 网络，比如 VxLAN 和 GRE（Linux Bridge 目前只支持 VxLAN）。在后面章节我们会学习如何使用和配置 Linux Bridge 和 Open vSwitch。</p>
<p>三层路由 Routing</p>
<p>Instance 可以配置不同网段的 IP，Neutron 的 router（虚拟路由器）实现 instance 跨网段通信。router 通过 IP forwarding，iptables 等技术来实现路由和 NAT。我们将在后面章节讨论如何在 Neutron 中配置 router 来实现 instance 之间，以及与外部网络的通信。</p>
<p>负载均衡 Load Balancing</p>
<p>Openstack 在 Grizzly 版本第一次引入了 Load-Balancing-as-a-Service（LBaaS），提供了将负载分发到多个 instance 的能力。LBaaS 支持多种负载均衡产品和方案，不同的实现以 Plugin 的形式集成到 Neutron，目前默认的 Plugin 是 HAProxy。我们会在后面章节学习 LBaaS 的使用和配置。</p>
<p>防火墙 Firewalling</p>
<p>Neutron 通过下面两种方式来保障 instance 和网络的安全性。</p>
<p>Security Group </p>
<p>通过 iptables 限制进出 instance 的网络包。</p>
<p>Firewall-as-a-Service<br>WaaS，限制进出虚拟路由器的网络包，也是通过 iptables 实现。</p>
<p>后面章节会详细讨论 Security 和 FWaaS。下一节我们会讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587694&idx=1&sn=7d844a30662b9af11de26d7f4322e9c9&chksm=8d3080f7ba4709e12ea3c32c314cb5b93c3e23d751cda63114234821f9946ef5c4d3a4880f25&scene=21#wechat_redirect">Neutron 网络涉及的一些基本概念</a>，便于后面深入学习。</p>
<h3 id="Neutron网络基本概念"><a href="#Neutron网络基本概念" class="headerlink" title="Neutron网络基本概念"></a>Neutron网络基本概念</h3><p>上次我们讨论了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587201&idx=1&sn=d35b7e5932adf85fdcb744e9d91d6f8d&scene=21#wechat_redirect">Neutron 提供的功能</a>，今天我们学习 Neutron 模块几个重要的概念。Neutron 管理的网络资源包括 Network，subnet 和 port，下面依次介绍。</p>
<p><strong>network</strong></p>
<p>network 是一个隔离的二层广播域。Neutron 支持多种类型的 network，包括 local, flat, VLAN, VxLAN 和 GRE。</p>
<p><strong>local</strong><br>local 网络与其他网络和节点隔离。local 网络中的 instance 只能与位于同一节点上同一网络的 instance 通信，local 网络主要用于单机测试。</p>
<p><strong>flat</strong><br>flat 网络是无 vlan tagging 的网络。flat 网络中的 instance 能与位于同一网络的 instance 通信，并且可以跨多个节点。</p>
<p><strong>vlan</strong><br>vlan 网络是具有 802.1q tagging 的网络。vlan 是一个二层的广播域，同一 vlan 中的 instance 可以通信，不同 vlan 只能通过 router 通信。vlan 网络可跨节点，是应用最广泛的网络类型。</p>
<p><strong>vxlan</strong><br>vxlan 是基于隧道技术的 overlay 网络。vxlan 网络通过唯一的 segmentation ID（也叫 VNI）与其他 vxlan 网络区分。vxlan 中数据包会通过 VNI 封装成 UDP 包进行传输。因为二层的包通过封装在三层传输，能够克服 vlan 和物理网络基础设施的限制。</p>
<p><strong>gre</strong><br>gre 是与 vxlan 类似的一种 overlay 网络。主要区别在于使用 IP 包而非 UDP 进行封装。</p>
<p>不同 network 之间在二层上是隔离的。</p>
<p>以 vlan 网络为例，network A 和 network B 会分配不同的 VLAN ID，这样就保证了 network A 中的广播包不会跑到 network B 中。当然，这里的隔离是指二层上的隔离，借助路由器不同 network 是可能在三层上通信的。</p>
<p>network 必须属于某个 Project（ Tenant 租户），Project 中可以创建多个 network。 network 与 Project 之间是 1对多 关系。</p>
<p><strong>subnet</strong></p>
<p>subnet 是一个 IPv4 或者 IPv6 地址段。instance 的 IP 从 subnet 中分配。每个 subnet 需要定义 IP 地址的范围和掩码。</p>
<p>network 与 subnet 是 1对多 关系。一个 subnet 只能属于某个 network；一个 network 可以有多个 subnet，这些 subnet 可以是不同的 IP 段，但不能重叠。下面的配置是有效的：</p>
<p>network A  subnet A-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>​          subnet A-b: 10.10.2.0/24  {“start”: “10.10.2.1”, “end”: “10.10.2.50”}</p>
<p>但下面的配置则无效，因为 subnet 有重叠</p>
<p>networkA   subnet A-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>​          subnet A-b: 10.10.1.0/24  {“start”: “10.10.1.51”, “end”: “10.10.1.100”}</p>
<p>这里不是判断 IP 是否有重叠，而是 subnet 的 CIDR 重叠（都是 10.10.1.0/24）。但是，如果 subnet 在不同的 network 中，CIDR 和 IP 都是可以重叠的，比如</p>
<p>network A  subnet A-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>networkB   subnet B-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>这里大家不免会疑惑： 如果上面的IP地址是可以重叠的，那么就可能存在具有相同 IP 的两个 instance，这样会不会冲突？ 简单的回答是：不会！</p>
<p>具体原因： 因为 Neutron 的 router 是通过 Linux network namespace 实现的。network namespace 是一种网络的隔离机制。通过它，每个 router 有自己独立的路由表。上面的配置有两种结果：</p>
<ol>
<li><p>如果两个 subnet 是通过同一个 router 路由，根据 router 的配置，只有指定的一个 subnet 可被路由。</p>
</li>
<li><p>如果上面的两个 subnet 是通过不同 router 路由，因为 router 的路由表是独立的，所以两个 subnet 都可以被路由。</p>
</li>
</ol>
<p>这里只是先简单做个说明，我们会在后面三层路由的章节详细分析这种场景。</p>
<p><strong>port</strong></p>
<p>port 可以看做虚拟交换机上的一个端口。port 上定义了 MAC 地址和 IP 地址，当 instance 的虚拟网卡 VIF（Virtual Interface） 绑定到 port 时，port 会将 MAC 和 IP 分配给 VIF。</p>
<p>subnet 与 port 是 1对多 关系。一个 port 必须属于某个 subnet；一个 subnet 可以有多个 port。</p>
<p><strong>小节</strong></p>
<p>下面总结了 Project，Network，Subnet，Port 和 VIF 之间关系。</p>
<p>Project 1 : m Network 1 : m Subnet 1 : m Port 1 : 1 VIF m : 1 Instance</p>
<p>下一节我们讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587691&idx=1&sn=c71b110dade71c3e120ec6b2389b3e33&chksm=8d3080f2ba4709e44eb08c55223e141f7ed0e069ebd6f770b7770665e00ff72d48ce41596a0b&scene=21#wechat_redirect">Neutron 的架构</a>。</p>
<h3 id="Neutron的架构"><a href="#Neutron的架构" class="headerlink" title="Neutron的架构"></a>Neutron的架构</h3><p>前面我们讨论了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587204&idx=1&sn=9d4b36188bfd91a896d68062dad4ee83&scene=21#wechat_redirect">Neutron 的基本概念</a>，今天我们开始分析 Neutron 的架构。</p>
<p><strong>Neutron 架构</strong></p>
<p>与 OpenStack 的其他服务的设计思路一样，Neutron 也是采用分布式架构，由多个组件（子服务）共同对外提供网络服务。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEZ5ovWJOuB1iaq0vRiaplgJtus2jUWMVcnHbgjteEHz4rJoCsotcrR0C3hUoWiaC7DfpOqleG8lRVibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Neutron 由如下组件构成：</p>
<p>**Neutron Server<br>**对外提供 OpenStack 网络 API，接收请求，并调用 Plugin 处理请求。</p>
<p>**Plugin<br>**处理 Neutron Server 发来的请求，维护 OpenStack 逻辑网络状态， 并调用 Agent 处理请求。</p>
<p>**Agent<br>**处理 Plugin 的请求，负责在 network provider 上真正实现各种网络功能。</p>
<p>**network provider<br>**提供网络服务的虚拟或物理网络设备，例如 Linux Bridge，Open vSwitch 或者其他支持 Neutron 的物理交换机。</p>
<p>**Queue<br>**Neutron Server，Plugin 和 Agent 之间通过 Messaging Queue 通信和调用。</p>
<p>**Database<br>**存放 OpenStack 的网络状态信息，包括 Network, Subnet, Port, Router 等。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEZ5ovWJOuB1iaq0vRiaplgJtEbDQkCyia1o8QZwqWOJgmmDlrbN454daWqqvaRjbKZqu117AjDscfZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Neutron 架构非常灵活，层次较多，目的是：</p>
<ol>
<li><p>为了支持各种现有或者将来会出现的优秀网络技术。</p>
</li>
<li><p>支持分布式部署，获得足够的扩展性。</p>
</li>
</ol>
<p>通常鱼和熊掌不能兼得，虽然获得了这些优势，但这样使得 Neutron 更加复杂，更不容易理解。 后面我们会详细讨论 Neutron 的各个组件，但在这之前，非常有必要先通过一个例子了解这些组件各自的职责以及是如何协同工作。</p>
<p>以创建一个 VLAN100 的 network 为例，假设 network provider 是 linux bridge， 流程如下：</p>
<blockquote>
<ol>
<li><p>Neutron Server 接收到创建 network 的请求，通过 Message Queue（RabbitMQ）通知已注册的 Linux Bridge Plugin。</p>
</li>
<li><p>Plugin 将要创建的 network 的信息（例如名称、VLAN ID等）保存到数据库中，并通过 Message Queue 通知运行在各节点上的 Agent。</p>
</li>
<li><p>Agent 收到消息后会在节点上的物理网卡（比如 eth2）上创建 VLAN 设备（比如 eth2.100），并创建 bridge （比如 brqXXX） 桥接 VLAN 设备。</p>
</li>
</ol>
</blockquote>
<p>关于 linux bridge 如何实现 VLAN 大家可以参考本教程“预备知识-&gt;网络虚拟化”的相关章节。这里进行几点说明：</p>
<ol>
<li><p>plugin 解决的是 What 的问题，即网络要配置成什么样子？而至于如何配置 How 的工作则交由 agent 完成。</p>
</li>
<li><p>plugin，agent 和 network provider 是配套使用的，比如上例中 network provider 是 linux bridge，那么就得使用 linux bridge 的 plungin 和 agent；如果 network provider 换成了 OVS 或者物理交换机，plugin 和 agent 也得替换。</p>
</li>
<li><p>plugin 的一个主要的职责是在数据库中维护 Neutron 网络的状态信息，这就造成一个问题：所有 network provider 的 plugin 都要编写一套非常类似的数据库访问代码。为了解决这个问题，Neutron 在 Havana 版本实现了一个 ML2（Modular Layer 2）plugin，对 plgin 的功能进行抽象和封装。有了 ML2 plugin，各种 network provider 无需开发自己的 plugin，只需要针对 ML2 开发相应的 driver 就可以了，工作量和难度都大大减少。ML2 会在后面详细讨论。</p>
</li>
<li><p>plugin 按照功能分为两类： core plugin 和 service plugin。core plugin 维护 Neutron 的 netowrk, subnet 和 port 相关资源的信息，与 core plugin 对应的 agent 包括 linux bridge, OVS 等； service plugin 提供 routing, firewall, load balance 等服务，也有相应的 agent。后面也会分别详细讨论。</p>
</li>
</ol>
<p>以上是Neutron的逻辑架构，下一节我们讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587687&idx=1&sn=adf2078fa91f552a23dd406bf9c0d30d&chksm=8d3080feba4709e8fca066ec1371c51f9b3a89229cfeb81f886e6895f0c2509a29e840ab6d19&scene=21#wechat_redirect">Neutron 的物理部署方案</a>。</p>
<h3 id="Neutron-物理部署方案"><a href="#Neutron-物理部署方案" class="headerlink" title="Neutron 物理部署方案"></a>Neutron 物理部署方案</h3><p>前面我们讨论了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587207&idx=1&sn=2ad3cff789378312144d41ca2e9c1dc9&scene=21#wechat_redirect">Neutron 的架构</a>，本节讨论 Neutron 的物理部署方案：不同节点部署不同的 Neutron 服务组件。</p>
<p><strong>方案1：控制节点 + 计算节点</strong></p>
<p>在这个部署方案中，OpenStack 由控制节点和计算节点组成。</p>
<p><strong>控制节点</strong><br>部署的服务包括：neutron server, core plugin 的 agent 和 service plugin 的 agent。</p>
<p><strong>计算节点</strong><br>部署 core plugin 的agent，负责提供二层网络功能。</p>
<p>这里有几点需要说明： </p>
<p>\1. core plugin 和 service plugin 已经集成到 neutron server，不需要运行独立的 plugin 服务。</p>
<p>\2. 控制节点和计算节点都需要部署 core plugin 的 agent，因为通过该 agent 控制节点与计算节点才能建立二层连接。</p>
<p>\3. 可以部署多个控制节点和计算节点。</p>
<p><img src="/2022/06/09/OpenStack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>方案2：控制节点 + 网络节点 + 计算节点</strong></p>
<p>在这个部署方案中，OpenStack 由控制节点，网络节点和计算节点组成。</p>
<p>**控制节点<br>**</p>
<p>部署 neutron server 服务。</p>
<p>**网络节点<br>**部署的服务包括：core plugin 的 agent 和 service plugin 的 agent。</p>
<p>**计算节点<br>**部署 core plugin 的agent，负责提供二层网络功能。</p>
<p>这个方案的要点是将所有的 agent 从控制节点分离出来，部署到独立的网络节点上。</p>
<ol>
<li><p>控制节点只负责通过 neutron server 响应 API 请求。</p>
</li>
<li><p>由独立的网络节点实现数据的交换，路由以及 load balance等高级网络服务。</p>
</li>
<li><p>可以通过增加网络节点承担更大的负载。</p>
</li>
<li><p>可以部署多个控制节点、网络节点和计算节点。</p>
</li>
</ol>
<p>该方案特别适合规模较大的 OpenStack 环境。</p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz/Hia4HVYXRicqHuicQalCOiaMzJkIfDGxicQibEt6Yiat5ia1Nae2zkDn7AnFDflibI8bHgibtV4EmGD8eXhycKbVU4FApZvg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="图片"></p>
<p>以上就是 Neutron 两种典型的部署方案，下一节我们开始讨论 Neutron 的各个服务组件。首先学习 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587683&idx=1&sn=3c5cadd759831abf596d53859cb64b9d&chksm=8d3080faba4709ec386d03890f7ccec74a9adfb69a943466626428b237d4a3929e372496e8db&scene=21#wechat_redirect">Neutron Server</a> 。</p>
<h3 id="Neutron-Server-分层模型"><a href="#Neutron-Server-分层模型" class="headerlink" title="Neutron Server 分层模型"></a>Neutron Server 分层模型</h3><p>本节开始讨论 Neutron 的各个服务组件，首先学习 Neutron Server 。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqG2kaGXyYgYWVaMZBrLruk6LYphLicwibym5k79oEPDPAlrVCY9aQ9bDiahZQ2YTNZ8Ee6XgXqnhSGKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>上图是 Neutron Server 的分层结构，至上而下依次为：</p>
<p>**Core API<br>**对外提供管理 network, subnet 和 port 的 RESTful API。</p>
<p>**Extension API<br>**对外提供管理 router, load balance, firewall 等资源 的 RESTful API。</p>
<p>**Commnon Service<br>**认证和校验 API 请求。</p>
<p>**Neutron Core<br>**Neutron server 的核心处理程序，通过调用相应的 Plugin 处理请求。</p>
<p>**Core Plugin API<br>**定义了 Core Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Core Plgin。</p>
<p>**Extension Plugin API<br>**定义了 Service Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Service Plgin。</p>
<p>**Core Plugin<br>**实现了 Core Plugin API，在数据库中维护 network, subnet 和 port 的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 network。</p>
<p>**Service Plugin<br>**实现了 Extension Plugin API，在数据库中维护 router, load balance, security group 等资源的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 router。</p>
<p>归纳起来，Neutron Server 包括两部分：<br>\1. 提供 API 服务。<br>\2. 运行 Plugin。</p>
<p>即 <strong>Neutron Server = API + Plugins</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqG2kaGXyYgYWVaMZBrLruk6fRic3xJzD7tJjhr2g0OXKJaOz6DNopZv0JiaibdzBBNcZ4GJsOHh8JpQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>明白了 Neutron Server 的分层模型，我们就更容易理解 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587682&idx=1&sn=bd57acc0560ce9bcdcc7781ed24067df&chksm=8d3080fbba4709ed1dd5ba820daa2c845d1aff1d4cd5670b74337df386f3fbf2544ab5fb65c0&scene=21#wechat_redirect">Neutron 是如何支持多种 network provider</a>。这一点我们放到下节详细讨论。</p>
<h1 id="如何使用-OpenStack-CLI"><a href="#如何使用-OpenStack-CLI" class="headerlink" title="如何使用 OpenStack CLI"></a>如何使用 OpenStack CLI</h1><p>OpenStack 服务都有自己的 CLI。</p>
<p>命令很好记，就是服务的名字，比如 Glance 就是 glance，Nova 就是 nova。</p>
<p>但 Keystone 比较特殊，现在是用 openstack 来代替老版的 keystone 命令。 比如查询用户列表，如果用 keystone user-list</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoZ0O7zQTVVic7H0DDiccziaL8ZD3yc8yicn8D7j02Rr9I1G3MxZ2tIGJkvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>会提示 keystone 已经 deprecated 了。 用 openstack 命令代替</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoY8lTica2iayAOzjcLnl7hcTKZMlXkg281SgwOxTFLvFAg4icLkJlREGQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>不同服务用的命令虽然不同，但这些命令使用方式却非常类似，可以举一反三。</p>
<p>\1. 执行命令之前，需要设置环境变量。</p>
<p>这些变量包含用户名、Project、密码等； 如果不设置，每次执行命令都必须设置相关的命令行参数</p>
<p>\2. 各个服务的命令都有增、删、改、查的操作</p>
<p>其格式是</p>
<blockquote>
<p>CMD <obj>-create [parm1] [parm2]…<br>CMD <obj>-delete [parm]<br>CMD <obj>-update [parm1] [parm2]…<br>CMD <obj>-list CMD <obj>-show [parm]</obj></obj></obj></obj></obj></p>
</blockquote>
<p>例如 glance 管理的是 image，那么:<br>CMD 就是 glance，obj 就是 image，对应的命令就有</p>
<blockquote>
<p>glance image-create<br>glance image-delete<br>glance image-update<br>glance image-list<br>glance image-show</p>
</blockquote>
<p>再比如 neutron 负责管理网络和子网，那么：<br>CMD 就是 neutron；obj 就是 net 和 subnet 对应的命令就有</p>
<p>网络相关操作</p>
<blockquote>
<p>neutron net-create<br>neutron net -delete<br>neutron net -update<br>neutron net -list<br>neutron net –show</p>
</blockquote>
<p>子网相关操作</p>
<blockquote>
<p>neutron subnet-create<br>neutron subnet -delete<br>neutron subnet -update<br>neutron subnet -list<br>neutron subnet–show</p>
</blockquote>
<p>有的命令 <obj> 可以省略，比如 nova 下面的操作都是针对 instance</obj></p>
<blockquote>
<p>nova boot<br>nova delete<br>nova list nova show</p>
</blockquote>
<p>\3. 每个对象都有 ID</p>
<p>delete，show 等操作都以 ID 为参数，例如</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxosDD7iaX5dVUBApKyE8J5Y6wzrJdoL8LRaicZUOibNGEsT4nwex8wtPia7g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>\4. 可用 help 查看命令的用法</p>
<p>除了 delete，show 等操作只需要 ID 一个参数，其他操作可能需要更多的参数，用 help 查看所需的参数，格式是</p>
<blockquote>
<p>CMD help [SUB-CMD]</p>
</blockquote>
<p>例如查看 glance 都有哪些 SUB-CMD</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoiaouoAy9x9HeoGbAlbxeZV1icICxlOggtu8TQDjYngjbQaCbDUwkrMMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>查看 glance image-update 的用法</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoC6wkrs2JreTTXg8acclN6D0QWgo1PBKibG9mXe2VkiaAJD0tUcibFsn4g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p><strong>如何 Troubleshooting</strong></p>
<p>OpenStack 排查问题的方法主要是通过日志，Service 都有自己单独的日志。Glance 主要有两个日志，glance_api.log 和 glance_registry.log，保存在 /opt/stack/logs 目录里。devstack 的 screen 窗口已经帮我们打开了这两个日志，可以直接查看</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoHB1eic8Am009h7Yic2gice9UAZwjYickt0LGDBLPnfiawMPjyVQWzR24l6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>g-api 窗口显示 glance-api 日志，记录 REST API 调用情况。<br>g-reg 窗口显示 glance-registry 日志，记录 Glance 服务处理请求的过程以及数据库操作。</p>
<p>如果需要得到最详细的日志信息，可以在 /etc/glance/*.conf 中打开 debug 选项。 devstack 默认已经打开了 debug。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxo4z8oFPdchEt1zJian8icia6mzphEE8FtzvicMflwHwh9PKLicpvsWprVFQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>在非 devstack 安装中，日志在 /var/log/glance/ 目录里。</p>
<p>packstack –allinone –os-neutron-l2-agent=openvswitch –os-neutron-ml2-mechanism-drivers=openvswitch –os-neutron-ml2-tenant-network-types=vxlan –os-neutron-ml2-type-drivers=vxlan,flat –provision-demo=n –os-neutron-ovs-bridge-mappings=extnet:br-ex –os-neutron-ovs-bridge-interfaces=br-ex:eno1 –keystone-admin-passwd=’cnlab.net’ –provision-demo=n  –nova-libvirt-virt-type=kvm –os-swift-storage-size=100G –cinder-volumes-size=500G</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/03/02/Octave%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/Octave%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Octave基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 14:52:47" itemprop="dateCreated datePublished" datetime="2022-03-02T14:52:47+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-23 09:31:02" itemprop="dateModified" datetime="2022-03-23T09:31:02+08:00">2022-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Basic-operation-基础操作"><a href="#Basic-operation-基础操作" class="headerlink" title="Basic operation 基础操作"></a>Basic operation 基础操作</h1><p>算数运算：加减乘除； ==；~=；</p>
<p>逻辑运算：&amp;&amp;   -AND；  ||   -OR； </p>
<p>字符串： EX： a = ‘Hello world!’</p>
<p>disp函数： EX： disp( sprintf(‘ %0.2f’ ),variable )  %保留variable小数点后两位</p>
<p>矩阵： A = [1 2；2 3；4 5]</p>
<p>V = 1: 0.2: 2     %会生成一个增量为0.2的从1到2的 1行_列的矩阵; 如果中间不填，默认增量是1；</p>
<p>ones函数：ones（3，2）  %生成一个3行两列的 值都是1的矩阵； 同理zeros（）也是</p>
<p>rand（m，n）函数：随机在0-1范围内生成m*n矩阵的值</p>
<p>randn（m，n）函数：随机生成的数符合高斯分布/正态分布</p>
<p>hist（）：绘制直方图</p>
<p>eye( n )  : 生成n阶单位矩阵</p>
<p>size( ) : 返回矩阵的大小，返回的也是一个1行2列的矩阵；</p>
<p>size（A，1 or 2）：返回矩阵的行或列</p>
<p>help命令： 如 help eye；就可以获得eye函数的用法</p>
<h1 id="Moving-Data-Around-移动数据过来"><a href="#Moving-Data-Around-移动数据过来" class="headerlink" title="Moving Data Around 移动数据过来"></a>Moving Data Around 移动数据过来</h1><p><strong>load file.dat</strong></p>
<p><strong>load ( ‘file.dat ‘ )</strong></p>
<p>who函数： 展示目前工作空间中的所有变量</p>
<p>whos函数：更详细的展示变量的size,bytes</p>
<p>clear(variable): 删除某个变量</p>
<p>save  filename.mat v; : 将v保存为filename.mat的名字</p>
<p>or save filename.txt v -ascii;</p>
<p>查看矩阵元素的值：</p>
<p>如 A=[1 2；3 4；5 6]</p>
<p>A（2，2） ans = 4;   A(2,:) ans= 3, 4      % “:”代表着某行或某列所有的元素</p>
<p>A([1 3] , :) ans = 1 2; 5 6        % 1,3行的所有列元素</p>
<p>也可利用这个单独给某列赋值：</p>
<p>A（：，2） = [12 ；11； 10]</p>
<p>A = [A, [11;22;33]]                   %Add  a new column vector</p>
<p>A（：） 可以把所有元素变成一个变量</p>
<p>[ A B] 将两个行相等的矩阵放一起</p>
<p>[A ; B] 将列相等的矩阵竖置</p>
<h1 id="Plotting-Data-绘制数据"><a href="#Plotting-Data-绘制数据" class="headerlink" title="Plotting Data 绘制数据"></a>Plotting Data 绘制数据</h1><p><strong>常用命令：</strong></p>
<p>plot（x,y(x)）; </p>
<p>xlabel ( ‘ ‘ );   ylabel ( ‘ ‘ ) ;</p>
<p>legend( ‘ ‘ , ‘ ‘ );</p>
<p>title( ‘ ‘ )</p>
<p>print -dpng ‘filename.png’;</p>
<p>figure(1): plot(t ,y1)</p>
<p>figure(2): plot(t,y2)</p>
<p>subplot(1,2,1);</p>
<p>polar(thera , r): 绘制极坐标</p>
<p>cart2pol: 将直角坐标系转化为极坐标系</p>
<p>pol2cart: 极坐标转化为直角坐标系          ex： [x，y] = pol2cart（theta，r）</p>
<blockquote>
<p>误差棒图： errorbar（x，y，error）</p>
</blockquote>
<p><strong>向量图形：</strong></p>
<ol>
<li>箭头图</li>
</ol>
<p>quiver(U,V)   U,V 都是二维矩阵；</p>
<ol start="2">
<li>罗盘图</li>
</ol>
<p>compass（x，y）   ； </p>
<p><strong>三维图形：</strong></p>
<p>plot3（x，y，z）；</p>
<p>mesh();</p>
<p>peaks();</p>
<p>meshgrid( ) 将一维变成二维</p>
<h3 id="图形修饰处理"><a href="#图形修饰处理" class="headerlink" title="图形修饰处理"></a>图形修饰处理</h3><ol>
<li>坐标轴处理   —-    daspect</li>
<li>mesh();   hidden on / off</li>
<li>视角处理： view(az/方位角, el/仰角)</li>
</ol>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p>F =  getframe( )</p>
<p>movie(F, num_)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/02/28/docker%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/docker%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Docker学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 20:12:35" itemprop="dateCreated datePublished" datetime="2022-02-28T20:12:35+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-26 15:14:47" itemprop="dateModified" datetime="2022-08-26T15:14:47+08:00">2022-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Docker教程：<a target="_blank" rel="noopener" href="https://docker-curriculum.com/">https://docker-curriculum.com/</a></p>
<p>K8S教程：<a target="_blank" rel="noopener" href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45">https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiayi Liang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiayi Liang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiayi Liang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
