<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiayi8991.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="JiayiSpace">
<meta property="og:url" content="https://jiayi8991.github.io/index.html">
<meta property="og:site_name" content="JiayiSpace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jiayi Liang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jiayi8991.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JiayiSpace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JiayiSpace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">CUDA编程基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-29 09:30:44 / 修改时间：15:59:00" itemprop="dateCreated datePublished" datetime="2022-08-29T09:30:44+08:00">2022-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载引用于：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34587739">https://zhuanlan.zhihu.com/p/34587739</a></p>
</blockquote>
<h1 id="关于CUDA"><a href="#关于CUDA" class="headerlink" title="关于CUDA"></a>关于CUDA</h1><p>2006年，NVIDIA公司发布了<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/">CUDA</a>，CUDA是建立在NVIDIA的CPUs上的一个通用并行计算平台和编程模型，基于CUDA编程可以利用GPUs的并行计算引擎来更加高效地解决比较复杂的计算难题。近年来，GPU最成功的一个应用就是深度学习领域，基于GPU的并行计算已经成为训练深度学习模型的标配。</p>
<p>GPU并不是一个独立运行的计算平台，而需要与CPU协同工作，可以看成是CPU的协处理器，因此当我们在说GPU并行计算时，其实是指的基于CPU+GPU的异构计算架构。在异构计算架构中，GPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为为主机端（host），而GPU所在位置称为设备端（device），如下图所示。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1.png">  </p>
<p>可以看到GPU包括更多的运算核心，其特别适合数据并行的计算密集型任务，如大型矩阵运算，而CPU的运算核心较少，但是其可以实现复杂的逻辑运算，因此其适合控制密集型任务。另外，CPU上的线程是重量级的，上下文切换开销大，但是GPU由于存在很多核心，其线程是轻量级的。因此，基于CPU+GPU的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，而GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2.png">  </p>
<p>CUDA是NVIDIA公司所开发的GPU编程模型，它提供了GPU编程的简易接口，基于CUDA编程可以构建基于GPU计算的应用程序。CUDA提供了对其它编程语言的支持，如C/C++，Python，Fortran等语言，这里我们选择CUDA C/C++接口对CUDA编程进行讲解。</p>
<h1 id="CUDA编程基础"><a href="#CUDA编程基础" class="headerlink" title="CUDA编程基础"></a>CUDA编程基础</h1><p>在给出CUDA的编程实例之前，这里先对CUDA编程模型中的一些概念及基础知识做个简单介绍。CUDA编程模型是一个异构模型，需要CPU和GPU协同工作。在CUDA中，<strong>host</strong>和<strong>device</strong>是两个重要的概念，我们用host指代CPU及其内存，而用device指代GPU及其内存。CUDA程序中既包含host程序，又包含device程序，它们分别在CPU和GPU上运行。同时，host与device之间可以进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行流程如下：</p>
<ol>
<li>分配host内存，并进行数据初始化；</li>
<li>分配device内存，并从host将数据拷贝到device上；</li>
<li>调用CUDA的核函数在device上完成指定的运算；</li>
<li>将device上的运算结果拷贝到host上；</li>
<li>释放device和host上分配的内存。</li>
</ol>
<p>上面流程中最重要的一个过程是调用CUDA的核函数来执行并行计算，<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23kernels">kernel</a>是CUDA中一个重要的概念，<strong>kernel是在device上线程中并行执行的函数</strong>，<strong>核函数用<code>__global__</code>符号声明，在调用时需要用<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定kernel要执行的线程数量，在CUDA中，每一个线程都要执行核函数，并且每个线程会分配一个唯一的线程号thread ID，这个ID值可以通过核函数的内置变量<code>threadIdx</code>来获得</strong>。</p>
<p>由于GPU实际上是异构模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词开区别host和device上的函数，主要的三个函数类型限定词如下：</p>
<ul>
<li><code>__global__</code>：<strong>在device上执行，从host中调用</strong>（一些特定的GPU也可以从device上调用），返回类型必须是<code>void</code>，不支持可变参数参数，不能成为类成员函数。注意用<code>__global__</code>定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。</li>
<li><code>__device__</code>：在device上执行，单仅可以从device中调用，不可以和<code>__global__</code>同时用。</li>
<li><code>__host__</code>：在host上执行，仅可以从host上调用，一般省略不写，不可以和<code>__global__</code>同时用，但可和<code>__device__</code>，此时函数会在device和host都编译。</li>
</ul>
<p>要深刻理解kernel，必须要对kernel的线程层次结构有一个清晰的认识。</p>
<p>首先GPU上很多并行化的轻量级线程。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个<strong>网格</strong>（grid），同一个网格上的线程共享相同的全局内存空间，grid是线程结构的第一层次，而网格又可以分为很多<strong>线程块</strong>（block），一个线程块里面包含很多线程，这是第二个层次。线程两层组织结构如下图所示，这是一个gird和block均为2-dim的线程组织。grid和block都是定义为<code>dim3</code>类型的变量，<code>dim3</code>可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此grid和block可以灵活地定义为1-dim，2-dim以及3-dim结构，对于图中结构（主要水平方向为x轴），定义的grid和block如下所示，kernel在调用时也必须通过<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23execution-configuration">执行配置</a><code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定kernel所使用的线程数及结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/3.png"> </p>
<p>所以，一个线程需要两个内置的坐标变量（blockIdx，threadIdx）来唯一标识，它们都是<code>dim3</code>类型变量，其中blockIdx指明线程所在grid中的位置，而threaIdx指明线程所在block中的位置，如图中的Thread (1,1)满足：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadIdx.x = <span class="number">1</span></span><br><span class="line">threadIdx.y = <span class="number">1</span></span><br><span class="line">blockIdx.x = <span class="number">1</span></span><br><span class="line">blockIdx.y = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>一个线程块上的线程是放在同一个流式多处理器（SM)上的，但是单个SM的资源有限，这导致线程块中的线程数是有限制的，现代GPUs的线程块可支持的线程数可达1024个。</p>
<p>有时候，我们要知道一个线程在blcok中的全局ID，此时就必须还要知道block的组织结构，这是通过线程的内置变量blockDim来获得。它获取线程块各个维度的大小。对于一个2-dim的block (Dx,Dy) ，线程 (x,y) 的ID值为 (x+y∗Dx) ，如果是3-dim的block (Dx,Dy,Dz) ，线程 (x,y,z) 的ID值为 (x+y∗Dx+z∗Dx∗Dy) 。另外线程还有内置变量gridDim，用于获得网格块各个维度的大小。</p>
<p>kernel的这种线程组织结构天然适合vector,matrix等运算，如我们将利用上图2-dim结构实现两个矩阵的加法，每个线程负责处理每个位置的两个元素相加，代码如下所示。线程块大小为(16, 16)，然后将N*N大小的矩阵均分为不同的线程块来执行加法运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kernel定义</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; j &lt; N) </span><br><span class="line">        C[i][j] = A[i][j] + B[i][j]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Kernel 线程配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>; </span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span><br><span class="line">    <span class="comment">// kernel调用</span></span><br><span class="line">    MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外这里简单介绍一下CUDA的内存模型，如下图所示。</p>
<p>可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。内存结构涉及到程序优化，这里不深入探讨它们。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/4.png">  </p>
<p>还有重要一点，你需要对GPU的硬件实现有一个基本的认识。上面说到了kernel的线程组织层次，那么一个kernel实际上会启动很多线程，这些线程是逻辑上并行的，但是在物理层却并不一定。这其实和CPU的多线程有类似之处，多线程如果没有多核支持，在物理层也是无法实现并行的。但是好在GPU存在很多CUDA核心，充分利用CUDA核心可以充分发挥GPU的并行计算能力。</p>
<p>GPU硬件的一个核心组件是SM，前面已经说过，SM是英文名是 Streaming Multiprocessor，翻译过来就是流式多处理器。</p>
<p>SM的核心组件包括CUDA核心，共享内存，寄存器等，SM可以并发地执行数百个线程，并发能力就取决于SM所拥有的资源数。当一个kernel被执行时，它的gird中的线程块被分配到SM上，一个线程块只能在一个SM上被调度。SM一般可以调度多个线程块，这要看SM本身的能力。那么有可能一个kernel的各个线程块被分配多个SM，所以grid只是逻辑层，而SM才是执行的物理层。</p>
<p>SM采用的是<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23simt-architecture">SIMT</a> (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（warps)，线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为GPU规定线程束中所有线程在同一周期执行相同的指令，线程束分化会导致性能下降。当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。这是因为资源限制，SM要为每个线程块分配共享内存，而也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。</p>
<p>总之，就是网格和线程块只是逻辑划分，一个kernel的所有线程其实在物理层是不一定同时并发的。所以kernel的grid和block的配置不同，性能会出现差异，这点是要特别注意的。还有，由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/5.png">  </p>
<p>在进行CUDA编程前，可以先检查一下自己的GPU的硬件配置，这样才可以有的放矢，可以通过下面的程序获得GPU的配置属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dev = <span class="number">0</span>;</span><br><span class="line">  cudaDeviceProp devProp;</span><br><span class="line">  CHECK(cudaGetDeviceProperties(&amp;devProp, dev));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用GPU device &quot;</span> &lt;&lt; dev &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; devProp.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SM的数量：&quot;</span> &lt;&lt; devProp.multiProcessorCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个线程块的共享内存大小：&quot;</span> &lt;&lt; devProp.sharedMemPerBlock / <span class="number">1024.0</span> &lt;&lt; <span class="string">&quot; KB&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个线程块的最大线程数：&quot;</span> &lt;&lt; devProp.maxThreadsPerBlock &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个EM的最大线程数：&quot;</span> &lt;&lt; devProp.maxThreadsPerMultiProcessor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;每个SM的最大线程束数：&quot;</span> &lt;&lt; devProp.maxThreadsPerMultiProcessor / <span class="number">32</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出如下</span></span><br><span class="line">  使用GPU device <span class="number">0</span>: GeForce GT <span class="number">730</span></span><br><span class="line">  SM的数量：<span class="number">2</span></span><br><span class="line">  每个线程块的共享内存大小：<span class="number">48</span> KB</span><br><span class="line">  每个线程块的最大线程数：<span class="number">1024</span></span><br><span class="line">  每个EM的最大线程数：<span class="number">2048</span></span><br><span class="line">  每个EM的最大线程束数：<span class="number">64</span></span><br></pre></td></tr></table></figure>



<h1 id="向量加法实例"><a href="#向量加法实例" class="headerlink" title="向量加法实例"></a>向量加法实例</h1><p>知道了CUDA编程基础，我们就来个简单的实战，利用CUDA编程实现两个向量的加法，在实现之前，先简单介绍一下CUDA编程中内存管理API。首先是在device上分配内存的cudaMalloc函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="keyword">void</span>** devPtr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数和C语言中的malloc类似，但是在device上申请一定字节大小的显存，其中devPtr是指向所分配内存的指针。同时要释放分配的内存使用cudaFree函数，这和C语言中的free函数对应。另外一个重要的函数是负责host和device之间数据通信的cudaMemcpy函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count, cudaMemcpyKind kind)</span></span></span><br></pre></td></tr></table></figure>

<p>其中src指向数据源，而dst是目标区域，count是复制的字节数，其中kind控制复制的方向：cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost及cudaMemcpyDeviceToDevice，如cudaMemcpyHostToDevice将host上数据拷贝到device上。</p>
<p>现在我们来实现一个向量加法的实例，这里grid和block都设计为1-dim，首先定义kernel如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个向量加法kernel，grid和block均为一维</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span>* x, <span class="keyword">float</span> * y, <span class="keyword">float</span>* z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取全局索引</span></span><br><span class="line">    <span class="keyword">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="comment">// 步长</span></span><br><span class="line">    <span class="keyword">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; n; i += stride)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中stride是整个grid的线程数，有时候向量的元素数很多，这时候可以将在每个线程实现多个元素（元素总数/线程总数）的加法，相当于使用了多个grid来处理，这是一种<a href="https://link.zhihu.com/?target=https://devblogs.nvidia.com/cuda-pro-tip-write-flexible-kernels-grid-stride-loops/">grid-stride loop</a>方式，不过下面的例子一个线程只处理一个元素，所以kernel里面的循环是不执行的。下面我们具体实现向量加法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> nBytes = N * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="comment">// 申请host内存</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    x = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    y = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    z = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">10.0</span>;</span><br><span class="line">        y[i] = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请device内存</span></span><br><span class="line">    <span class="keyword">float</span> *d_x, *d_y, *d_z;</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_x, nBytes);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_y, nBytes);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_z, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将host数据拷贝到device</span></span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)d_x, (<span class="keyword">void</span>*)x, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)d_y, (<span class="keyword">void</span>*)y, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((N + blockSize.x - <span class="number">1</span>) / blockSize.x)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    add &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(d_x, d_y, d_z, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将device得到的结果拷贝到host</span></span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)z, (<span class="keyword">void</span>*)d_z, nBytes, cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(z[i] - <span class="number">30.0</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最大误差: &quot;</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放device内存</span></span><br><span class="line">    cudaFree(d_x);</span><br><span class="line">    cudaFree(d_y);</span><br><span class="line">    cudaFree(d_z);</span><br><span class="line">    <span class="comment">// 释放host内存</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="built_in">free</span>(y);</span><br><span class="line">    <span class="built_in">free</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们的向量大小为1&lt;&lt;20，而block大小为256，那么grid大小是4096，kernel的线程层级结构如下图所示：</p>
<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/6.png">  </p>
<p>使用nvprof工具可以分析kernel运行情况，结果如下所示，可以看到kernel函数费时约1.5ms。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvprof cuda9.exe</span><br><span class="line">==7244== NVPROF is profiling process 7244, command: cuda9.exe</span><br><span class="line">最大误差: 4.31602e+008</span><br><span class="line">==7244== Profiling application: cuda9.exe</span><br><span class="line">==7244== Profiling result:</span><br><span class="line">            Type  Time(%)      Time     Calls       Avg       Min       Max  Name</span><br><span class="line"> GPU activities:   67.57%  3.2256ms         2  1.6128ms  1.6017ms  1.6239ms  [CUDA memcpy HtoD]</span><br><span class="line">                   32.43%  1.5478ms         1  1.5478ms  1.5478ms  1.5478ms  add(float*, float*, float*, int)</span><br></pre></td></tr></table></figure>

<p>你调整block的大小，对比不同配置下的kernel运行情况，我这里测试的是当block为128时，kernel费时约1.6ms，而block为512时kernel费时约1.7ms，当block为64时，kernel费时约2.3ms。看来不是block越大越好，而要适当选择。</p>
<p>在上面的实现中，我们需要单独在host和device上进行内存分配，并且要进行数据拷贝，这是很容易出错的。好在CUDA 6.0引入统一内存（<a href="https://link.zhihu.com/?target=http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23um-unified-memory-programming-hd">Unified Memory</a>）来避免这种麻烦，简单来说就是统一内存使用一个托管内存来共同管理host和device中的内存，并且自动在host和device中进行数据传输。CUDA中使用cudaMallocManaged函数分配托管内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocManaged</span><span class="params">(<span class="keyword">void</span> **devPtr, <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>利用统一内存，可以将上面的程序简化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> nBytes = N * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请托管内存</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;x, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;y, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;z, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">10.0</span>;</span><br><span class="line">        y[i] = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((N + blockSize.x - <span class="number">1</span>) / blockSize.x)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    add &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(x, y, z, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(z[i] - <span class="number">30.0</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最大误差: &quot;</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    cudaFree(x);</span><br><span class="line">    cudaFree(y);</span><br><span class="line">    cudaFree(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之前的代码，使用统一内存更简洁了，值得注意的是kernel执行是与host异步的，由于托管内存自动进行数据传输，这里要用cudaDeviceSynchronize()函数保证device和host同步，这样后面才可以正确访问kernel计算的结果。</p>
<h1 id="矩阵乘法实例"><a href="#矩阵乘法实例" class="headerlink" title="矩阵乘法实例"></a>矩阵乘法实例</h1><p>最后我们再实现一个稍微复杂一些的例子，就是两个矩阵的乘法，设输入矩阵为 A 和 B ，要得到 C=A×B 。实现思路是每个线程计算 C 的一个元素值 Ci,j ，对于矩阵运算，应该选用grid和block为2-D的。首先定义矩阵的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵类型，行优先，M(row, col) = *(M.elements + row * M.width + col)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">float</span> *elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/29/CUDA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/7.png">  </p>
<p>然后实现矩阵乘法的核函数，这里我们定义了两个辅助的<code>__device__</code>函数分别用于获取矩阵的元素值和为矩阵元素赋值，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取矩阵A的(row, col)元素</span></span><br><span class="line"><span class="function">__device__ <span class="keyword">float</span> <span class="title">getElement</span><span class="params">(Matrix *A, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A-&gt;elements[row * A-&gt;width + col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为矩阵A的(row, col)元素赋值</span></span><br><span class="line"><span class="function">__device__ <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(Matrix *A, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A-&gt;elements[row * A-&gt;width + col] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵相乘kernel，2-D，每个线程计算一个元素</span></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">matMulKernel</span><span class="params">(Matrix *A, Matrix *B, Matrix *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> Cvalue = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">int</span> row = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line">	<span class="keyword">int</span> col = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A-&gt;width; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Cvalue += getElement(A, row, i) * getElement(B, i, col);</span><br><span class="line">	&#125;</span><br><span class="line">	setElement(C, row, col, Cvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们采用统一内存编写矩阵相乘的测试实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    Matrix *A, *B, *C;</span><br><span class="line">    <span class="comment">// 申请托管内存</span></span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;A, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;B, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;C, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    <span class="keyword">int</span> nBytes = width * height * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;A-&gt;elements, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;B-&gt;elements, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;C-&gt;elements, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    A-&gt;height = height;</span><br><span class="line">    A-&gt;width = width;</span><br><span class="line">    B-&gt;height = height;</span><br><span class="line">    B-&gt;width = width;</span><br><span class="line">    C-&gt;height = height;</span><br><span class="line">    C-&gt;width = width;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A-&gt;elements[i] = <span class="number">1.0</span>;</span><br><span class="line">        B-&gt;elements[i] = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">32</span>, <span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((width + blockSize.x - <span class="number">1</span>) / blockSize.x, </span></span></span><br><span class="line"><span class="params"><span class="function">        (height + blockSize.y - <span class="number">1</span>) / blockSize.y)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    matMulKernel &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(A, B, C);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; ++i)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(C-&gt;elements[i] - <span class="number">2</span> * width));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最大误差: &quot;</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里矩阵大小为，设计的线程的block大小为(32, 32)，那么grid大小为(32, 32)，最终测试结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nvprof cuda9.exe</span><br><span class="line">==<span class="number">16304</span>== NVPROF is profiling process <span class="number">16304</span>, command: cuda9.exe</span><br><span class="line">最大误差: <span class="number">0</span></span><br><span class="line">==<span class="number">16304</span>== Profiling application: cuda9.exe</span><br><span class="line">==<span class="number">16304</span>== Profiling result:</span><br><span class="line">            Type  Time(%)      Time     Calls       Avg       Min       Max  Name</span><br><span class="line"> GPU activities:  <span class="number">100.00</span>%  <span class="number">1.32752</span>s         <span class="number">1</span>  <span class="number">1.32752</span>s  <span class="number">1.32752</span>s  <span class="number">1.32752</span>s  matMulKernel(Matrix*, Matrix*, Matrix*)</span><br><span class="line">      API calls:   <span class="number">83.11</span>%  <span class="number">1.32762</span>s         <span class="number">1</span>  <span class="number">1.32762</span>s  <span class="number">1.32762</span>s  <span class="number">1.32762</span>s  cudaDeviceSynchronize</span><br><span class="line">                   <span class="number">13.99</span>%  <span class="number">223.40</span>ms         <span class="number">6</span>  <span class="number">37.233</span>ms  <span class="number">37.341u</span>s  <span class="number">217.66</span>ms  cudaMallocManaged</span><br><span class="line">                    <span class="number">2.81</span>%  <span class="number">44.810</span>ms         <span class="number">1</span>  <span class="number">44.810</span>ms  <span class="number">44.810</span>ms  <span class="number">44.810</span>ms  cudaLaunch</span><br><span class="line">                    <span class="number">0.08</span>%  <span class="number">1.3300</span>ms        <span class="number">94</span>  <span class="number">14.149u</span>s       <span class="number">0</span>ns  <span class="number">884.64u</span>s  cuDeviceGetAttribute</span><br><span class="line">                    <span class="number">0.01</span>%  <span class="number">199.03u</span>s         <span class="number">1</span>  <span class="number">199.03u</span>s  <span class="number">199.03u</span>s  <span class="number">199.03u</span>s  cuDeviceGetName</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">10.009u</span>s         <span class="number">1</span>  <span class="number">10.009u</span>s  <span class="number">10.009u</span>s  <span class="number">10.009u</span>s  cuDeviceTotalMem</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">6.5440u</span>s         <span class="number">1</span>  <span class="number">6.5440u</span>s  <span class="number">6.5440u</span>s  <span class="number">6.5440u</span>s  cudaConfigureCall</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">3.0800u</span>s         <span class="number">3</span>  <span class="number">1.0260u</span>s     <span class="number">385</span>ns  <span class="number">1.5400u</span>s  cudaSetupArgument</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">2.6940u</span>s         <span class="number">3</span>     <span class="number">898</span>ns     <span class="number">385</span>ns  <span class="number">1.5390u</span>s  cuDeviceGetCount</span><br><span class="line">                    <span class="number">0.00</span>%  <span class="number">1.9250u</span>s         <span class="number">2</span>     <span class="number">962</span>ns     <span class="number">385</span>ns  <span class="number">1.5400u</span>s  cuDeviceGet</span><br><span class="line"></span><br><span class="line">==<span class="number">16304</span>== Unified Memory profiling result:</span><br><span class="line">Device <span class="string">&quot;GeForce GT 730 (0)&quot;</span></span><br><span class="line">   Count  Avg Size  Min Size  Max Size  Total Size  Total Time  Name</span><br><span class="line">    <span class="number">2051</span>  <span class="number">4.0000</span>KB  <span class="number">4.0000</span>KB  <span class="number">4.0000</span>KB  <span class="number">8.011719</span>MB  <span class="number">21.20721</span>ms  Host To Device</span><br><span class="line">     <span class="number">270</span>  <span class="number">45.570</span>KB  <span class="number">4.0000</span>KB  <span class="number">1.0000</span>MB  <span class="number">12.01563</span>MB  <span class="number">7.032508</span>ms  Device To Host</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C语言复习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-31 11:36:14" itemprop="dateCreated datePublished" datetime="2022-07-31T11:36:14+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 19:43:47" itemprop="dateModified" datetime="2022-08-02T19:43:47+08:00">2022-08-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><p>C语言格式特点：</p>
<ol>
<li>习惯用 小写字母，<strong>大小写敏感</strong></li>
<li>不使用行号，<strong>无程序行概念</strong></li>
<li>可使用空行和空格</li>
<li>常用<strong>锯齿形</strong>书写格式</li>
</ol>
<blockquote>
<p>注释可以用 // 或者 /*     */ </p>
</blockquote>
<p><img src="/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="image-20220731115703687">  </p>
<h1 id="数据类型、运算符和表达式"><a href="#数据类型、运算符和表达式" class="headerlink" title="数据类型、运算符和表达式"></a>数据类型、运算符和表达式</h1><h2 id="C的数据类型"><a href="#C的数据类型" class="headerlink" title="C的数据类型"></a>C的数据类型</h2><p><img src="/2022/07/31/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png">  </p>
<p><strong>数据类型决定：</strong></p>
<ol>
<li>数据占内存字节数</li>
<li>数据取值范围</li>
<li>可以进行的操作</li>
</ol>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><blockquote>
<p>常量：在程序运行中，不能被改变的量</p>
<ul>
<li>整型，实型，字符型，字符串</li>
<li>符号常量：用某种符号来表示某个常量，称之为符号常量<ul>
<li>#define PRICE 30  //用PRICE代表30</li>
<li><strong>不可以再给符号常量进行赋值</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>变量：<strong>变量</strong>是指在程序运行时其值可以改变的量。</p>
<ul>
<li>变量的功能就是存储数据。</li>
<li>C规定，标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串，并且其第一个字符必须是字母或下划线。且不能与C语言的关键字重名。<ul>
<li>标识符使用规则：</li>
<li>(1)<strong>标准C不限制标识符的长度，但它受各种版本的C语言编译系统限制，同时也受到具体机器的限制</strong>。例如在某版本C中规定标识符前八位有效，当两个标识符前八位相同时，则被认为是同一个标识符。<br>(2)在标识符中，<strong>大小写是有区别的</strong>。例如CLANG和Clang 是两个不同的标识符。<br>(3)标识符虽然可由程序员随意定义，但标识符是用于标识某个量的符号。因此，命名应尽量有相应的意义，以便阅读理解，做到“顾名思义”。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>C语言的基本数据类型为：整型、字符型、实数型。</p>
<p>这些类型按其在计算机中的存储方式可被分为两个系列，即<strong>整数(integer)类型</strong>和<strong>浮点数(floating-point)类型</strong>。 </p>
<p>这三种类型之下分别是：short、int、long、char、float、double这六个关键字再加上两个符号说明符signed和unsigned就基本表示了C语言的最常用的数据类型。</p>
<p>下面列出了在32位操作系统下常见编译器下的数据类型大小及表示的数据范围：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>类型关键字</th>
<th>占字节数</th>
<th>其他叫法</th>
<th>表示的数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>字符型</td>
<td>char</td>
<td>1</td>
<td>signed char</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>无符号字符型</td>
<td>unsigned char</td>
<td>1</td>
<td>none</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4</td>
<td>signed int</td>
<td>-2,147,483,648 ~ 2,147,483,647</td>
</tr>
<tr>
<td>无符号整型</td>
<td>unsigned int</td>
<td>4</td>
<td>unsigned</td>
<td>0 ~ 4,294,967,295</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2</td>
<td>short int</td>
<td>-32,768 ~ 32,767</td>
</tr>
<tr>
<td>无符号短整型</td>
<td>unsigned short</td>
<td>2</td>
<td>unsigned short int</td>
<td>0 ~ 65,535</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>4</td>
<td>long int</td>
<td>-2,147,483,648 ~ 2,147,483,647</td>
</tr>
<tr>
<td>无符号长整型</td>
<td>unsigned long</td>
<td>4</td>
<td>unsigned long</td>
<td>0 ~ 4,294,967,295</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>float</td>
<td>4</td>
<td>none</td>
<td>3.4E +/- 38 (7 digits)</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double</td>
<td>8</td>
<td>none</td>
<td>1.7E +/- 308 (15 digits)</td>
</tr>
<tr>
<td>长双精度浮点数</td>
<td>long double</td>
<td>10</td>
<td>none</td>
<td>1.2E +/- 4932 (19 digits)</td>
</tr>
</tbody></table>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>在C语言中，为了定义变量、表达语句功能和对一些文件进行预处理，还必须用到一些具有特殊意义的字符，这就是关键字，我们用户自己定义的变量函数名等要注意不可以与关键字同名。</p>
<table>
<thead>
<tr>
<th>C语言中的32个关键字</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>int</td>
<td>struct</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>switch</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>register</td>
<td>typedef</td>
</tr>
<tr>
<td>char</td>
<td>extern</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>const</td>
<td>float</td>
<td>short</td>
<td>unsigned</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>signed</td>
<td>void</td>
</tr>
<tr>
<td>default</td>
<td>goto</td>
<td>sizeof</td>
<td>volatile</td>
</tr>
<tr>
<td>do</td>
<td>if</td>
<td>static</td>
<td>while</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table>
<thead>
<tr>
<th>运算符类型</th>
<th>运算符表示</th>
<th>运算符用法</th>
</tr>
</thead>
<tbody><tr>
<td>赋值运算符</td>
<td>=</td>
<td>将值赋给 “=” 左侧变量</td>
</tr>
<tr>
<td>算数运算符</td>
<td>+，-，*，/，%</td>
<td>注意：除法中，整数的除法会丢掉小数部分；取模运算两侧必须为整数，取出来的为余数</td>
</tr>
<tr>
<td>sizeof运算符</td>
<td>sizeof()</td>
<td><strong>sizeof</strong>是C语言的32个关键字之一，并非“函数”(我们会后面介绍)，也叫<strong>长度(求字节)运算符</strong>，sizeof是一种<strong>单目运算符</strong>，<em>以字节为单位返回某操作数的大小，用来求某一类型变量的长度</em>。其运算对象可以是任何<strong>数据类型</strong>或<strong>变量</strong>。</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>逻辑与&amp;&amp;、逻辑或||、逻辑非！</td>
<td>其中逻辑与&amp;&amp;是<strong>双目运算符</strong>，即需要运算符两边都要有表达式，且两边表达式都为真，此表达式才为真；                     逻辑||也是<strong>双目运算符</strong>，要求左右两边的表达式只要有一个为真整体就为真。                                                      逻辑非! 运算符是<strong>单目运算符</strong>，只需右边跟一个表达式，表示取反的意思，即原先真的取反则为假，原先假的取反则为真</td>
</tr>
<tr>
<td>？：条件运算符</td>
<td>表达式1?表达式2:表达式3</td>
<td>首先计算表达式1的值，看看是真还是假，也就是成立还是不成立，如果表达式1成立，那么这个三目运算符整体的值就是表达式2的值，否则（也就是表达式1不成立），这个三目运算符整体的值就是表达式3的值</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;, &lt; , ==, &gt;=, &lt;=, !=</td>
<td>关系运算符的比较结果是<strong>逻辑值</strong>，即非真即假，也就是非1即0;     ex. 1 &gt;= 2 的值为 0</td>
</tr>
</tbody></table>
<h2 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h2><p>​        <strong>表达式(expression)<strong>是由</strong>运算符</strong>和<strong>操作数</strong>组合构成的（回忆一下，<strong>操作数是运算符操作的对象</strong>）。</p>
<p>​        最简单的表达式即一个单独的操作数，以此作为基础可以建立复杂的表达式，比如下面这些：</p>
<blockquote>
<p>3+2<br>a=(2+b/3)/5<br>x=i++<br>m=2*5</p>
</blockquote>
<p>​        正如看到的一样，操作数可以是<strong>常量</strong>，也可以是<strong>变量</strong>，亦可以是他们的组合。一些表达式是多个较小的表达式的组合，这些小的表达式称为**子表达式(subexpression)**。</p>
<p>​        **语句(statement)**是构造程序的基本部分。</p>
<p>​        **程序(program)**是一系列带有某种必须的标点语句集合。一个语句是一条完整的计算机指令。在C中，语句用结束处的一个分号标示。</p>
<p>例如：c=3这只是一个表达式（它可能是一个较大语句的一个部分），而c=3;则是一个语句。<br>想必您应该已经看到了，没错，表达式后面加一个分号即构成了一条C语句（它们被称为<strong>表达式语句</strong>）</p>
<h1 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h1><h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf()函数"></a>printf()函数</h2><p><strong>printf函数</strong>叫做<strong>格式输出函数</strong>，其功能是按照用户指定的格式，把指定的数据输出到屏幕上，printf函数的格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输出表项);</span><br></pre></td></tr></table></figure>



<p>格式控制字符串有两种：<strong>格式字符串</strong>和<strong>非格式字符串</strong>。非格式字符串在输出的时候原样打印；格式字符串是以%打头的字符串，在“%”后面跟不同格式字符，用来说明输出数据的类型、形式、长度、小数位数等。格式字符串的形式为：</p>
<blockquote>
<p><strong>% [输出最小宽度] [.精度] [长度] 类型</strong></p>
<p>例： </p>
<p>float  a = 3.1415;</p>
<p>printf (“%3.2f \n”, a );</p>
<p>结果：</p>
</blockquote>
<p>例如：%d格式符表示用十进制整形格式输出，%f表示用实型格式输出，%5.2f格式表示输出宽度为5(包括小数点)，并包含2位小数。</p>
<p><strong>常用的输出格式</strong>及含义如下：</p>
<table>
<thead>
<tr>
<th>格式字符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>d , i</td>
<td>以十进制形式输出有符号整数(正数不输出符号)</td>
</tr>
<tr>
<td>O</td>
<td>以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr>
<td>x</td>
<td>以十六进制形式输出无符号整数(不输出前缀0x)</td>
</tr>
<tr>
<td>U</td>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<td>f</td>
<td>以小数形式输出单、双精度类型实数</td>
</tr>
<tr>
<td>e</td>
<td>以指数形式输出单、双精度实数</td>
</tr>
<tr>
<td>g</td>
<td>以%f或%e中较短输出宽度的一种格式输出单、双精度实数</td>
</tr>
<tr>
<td>C</td>
<td>输出单个字符</td>
</tr>
<tr>
<td>S</td>
<td>输出字符串</td>
</tr>
</tbody></table>
<h2 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h2><p><strong>scanf函数</strong>称为<strong>格式输入函数</strong>，即按照格式字符串的格式，从键盘上把数据输入到指定的变量之中。scanf函数的调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;格式控制字符串&quot;</span>,输入项地址列表);</span><br></pre></td></tr></table></figure>



<p>其中，<strong>格式控制字符串</strong>的作用与printf函数相同，但不能显示非格式字符串，也就是不能显示提示字符串。地址表项中的地址给出各变量的地址，地址是由地址运算符“&amp;”后跟变量名组成的。</p>
<p>scanf函数中格式字符串的构成与printf函数基本相同，但使用时有几点不同。</p>
<p>(1)格式说明符中，可以指定数据的宽度，但不能指定数据的精度。例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a；</span><br><span class="line"><span class="built_in">scanf</span>(“%<span class="number">10f</span>”，&amp;a); <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">scanf</span>(“%<span class="number">10.2f</span>”,&amp;a); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>(2)输入long类型数据时必须使用%ld，输入double数据必须使用%lf或%le</p>
<p>(3)附加格式说明符“*”使对应的输入数据不赋给相应的变量</p>
<p>scanf()函数所用的转换说明符与printf()所用的几乎完全相同。主要区别在于printf()把%f、%e、%E、%g、%G同时用于float类型和double类型，而scanf()只是把他们用于float类型，而用于double类型时要求使用l(字母l)修饰符。</p>
<table>
<thead>
<tr>
<th>转换说明符</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>把输入解释成一个字符</td>
</tr>
<tr>
<td>%d</td>
<td>把输入解释成一个有符号十进制整数</td>
</tr>
<tr>
<td>%e,%f,%g,%a</td>
<td>把输入解释成一个浮点数(%a是C99的标准)</td>
</tr>
<tr>
<td>%E,%F,%G,%A</td>
<td>把输入解释成一个浮点数(%A是C99的标准)</td>
</tr>
<tr>
<td>%i</td>
<td>把输入解释成一个有符号十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>把输入解释成一个有符号的八进制整数</td>
</tr>
<tr>
<td>%p</td>
<td>把输入解释成一个指针(一个地址)</td>
</tr>
<tr>
<td>%s</td>
<td>把输入解释成一个字符串：输入的内容以第一个非空白字符作为开始，并且包含直到下一个空白字符的全部字符</td>
</tr>
<tr>
<td>%u</td>
<td>把输入解释成一个无符号十进制整数</td>
</tr>
<tr>
<td>%x,%X</td>
<td>把输入解释称一个有符号十六进制整数</td>
</tr>
</tbody></table>
<p>​    </p>
<p>*<strong>修饰符</strong>在scanf中()的用法：</p>
<p>*在scanf()中提供截然不同的服务，当把它放在%和说明符字母之间时，它使函数跳过相应的输入项目。请参考程序事例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用*跳过scanf接收的数字*/</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter three number:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span> ,&amp;num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The last number is %d\n&quot;</span>,num);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>gcc下运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please enter three number:</span><br><span class="line">2014 2015 2016</span><br><span class="line">The last number is 2016</span><br></pre></td></tr></table></figure>



<p>关于scanf()的<strong>返回值</strong>：</p>
<p>scanf()函数返回成功读入的项目的个数。如果它没有读取任何项目（比如它期望接收一个数字而您却输入的一个非数字字符时就会发生这种情况），scanf()返回0。</p>
<p>当它检测到“文件末尾”(end of file)时，它返回EOF(EOF在是文件stdio.h中的定义好的一个特殊值，一般，#define指令将EOF的值定义为-1)。当您学过循环之后，或在参加ACM这样的比赛及使用在线评测系统的时候会经常用到这种写法。</p>
<h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if语句选择结构"><a href="#if语句选择结构" class="headerlink" title="if语句选择结构"></a>if语句选择结构</h2><p><strong>if else选择程序结构</strong>用于判断给定的条件，根据判断条件的成立与否来控制程序的流程。选择结构有<strong>单选择</strong>、<strong>双选择</strong>和<strong>多选择</strong>3种形式，单选择结构用<strong>if语句</strong>实现。</p>
<p><strong>形式一：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) <span class="comment">/*若条件成立则实行花括号里的语句，反之则不执行*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>形式二：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) <span class="comment">/*若表达式成立则执行语句1，否则执行语句2*/</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//语句1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//语句2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>形式三：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)       <span class="comment">/*如果表达式成立，执行语句1否则继续判断表达式2*/</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//语句1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>) <span class="comment">/*如果表达式成立，执行语句2否则继续判断表达式3*/</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//语句2 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>) <span class="comment">/*如果表达式成立，则执行语句3否则继续判断下一个表达式*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//语句3; </span></span><br><span class="line">&#125; <span class="comment">//… … </span></span><br><span class="line"><span class="keyword">else</span>            <span class="comment">/*如果以上表达式都不成立 则执行语句4*/</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//语句4 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句"></a>switch case语句</h2><p>​        <strong>switch语句</strong>的执行过程为：首先计算表达式的值，然后依次与常量表达式依次进行比较，若表达式的值与某常量表达式相等，则从该常量表达式处开始执行，直到switch语句结束。若所有的常量表达式的值均不等于表达式的值，则从<strong>default</strong>处开始执行。一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)         <span class="comment">/*首先计算表达式的值*/</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>; </span><br><span class="line">	<span class="keyword">case</span> 常量表达式<span class="number">3</span>:语句<span class="number">3</span>; </span><br><span class="line">	<span class="comment">// ……   </span></span><br><span class="line">	<span class="keyword">case</span> 常量表达式n:语句n;</span><br><span class="line">	<span class="keyword">default</span>:语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">switch</span>(value)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">printf</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">&quot;two&quot;</span>);  <span class="comment">// break； 从这里跳出</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">&quot;three&quot;</span>)；</span><br><span class="line">  <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>break</strong>，顾名思义，跳出的意思，仅用于跳出<strong>switch结构</strong>或<strong>循环结构</strong>，用于提前结束switch结构或循环。</p>
</blockquote>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h2><p>​        <strong>while语句</strong>创建一个循环，<strong>该循环在判断表达式为假(或0)之前重复执行</strong>。while语句是一个<strong>入口条件(entry-condition)循环</strong>，在进行一次循环之前决定是否要执行循环。因此有可能一次也不执行。</p>
<p>循环的语句部分可以是一个<strong>简单语句</strong>或一个<strong>复合语句</strong>。</p>
<p><strong>while循环</strong>其一般式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式) </span><br><span class="line">&#123; </span><br><span class="line">	循环体语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在表达式为假(或0)之前重复执行循环体语句部分</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><p>​        <strong>do while语句</strong>创建一个循环，它在判断表达式为假(或0)之前重复执行。do while语句是一个<strong>退出条件循环</strong>，<strong>在执行一次循环之后才决定是否要再次执行循环</strong>，因此循环至少要被执行一次。循环的语句部分可以是一个<strong>简单语句</strong>或一个<strong>复合语句</strong></p>
<p><strong>do while循环</strong>其一般式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体语句 </span><br><span class="line">	&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<p>在表达式为假(或0)之前重复执行循环体语句</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>​        <strong>for语句</strong>使用由分号隔开的三个控制表达式来控制循环过程。初始化表达式只在开始执行循环语句之前执行一次。如果判断表达式为真(或非0)就执行一次循环。然后计算更新表达式并再次检查判断表达式的值。for语句是一个<strong>入口条件循环</strong>，在进行一次循环之前决定是否要执行循环，因此有可能循环一次也不执行。循环的语句部分可以是一个<strong>简单语句</strong>或一个<strong>复合语句</strong>。</p>
<p><strong>for循环</strong>其一般式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式;判断表达式;更新表达式)</span><br><span class="line">&#123;</span><br><span class="line">	循环体语句 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环在判断表达式为假(或0)之前重复执行</p>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>​        <strong>continue</strong>，顾名思义，是继续的意思，它<strong>仅用于循环</strong>中，用于<strong>提前结束本次循环</strong>，即跨过continue后面的循环语句，提前进入下次循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将<span class="number">100</span>以内的偶数相加</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum)</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>​        C源程序是由<strong>函数</strong>组成的。</p>
<p>​        最简单的程序有一个主函数main()，但实用程序往往由多个函数组成，由主函数调用其他函数，其他函数也可以互相调用。</p>
<p>​        <strong>函数</strong>是C源程序的基本模块，程序的许多功能是通过对函数模块的调用来实现的，学会编写和调用函数可以提高编程效率。</p>
<p><strong>函数的定义：</strong></p>
<blockquote>
<p><strong>返回值类型 函数名（形参表说明）     /* 函数首部 */</strong></p>
<p><strong>{</strong></p>
<p>​        <strong>说明语句    /* 函数体 */</strong></p>
<p>​        <strong>执行语句</strong></p>
<p><strong>}</strong></p>
</blockquote>
<p>对上面的定义形式进行以下说明：<br>(1)“<strong>返回值类型</strong>”是指函数返回值的类型。<strong>函数返回值不能是数组，也不能是函数</strong>，除此之外任何合法的数据类型都可以是函数的类型，如：int，long，float，char等。函数类型可以省略，当不指明函数类型时，系统默认的是整型。</p>
<p>(2)函数名是用户自定义的<strong>标识符</strong>，在C语言函数定义中不可省略，须符合C语言对标识符的规范，用于标识函数，并用该标识符调用函数。另外函数名本身也有值，它代表了该函数的入口地址，使用指针调用函数时，将用到此功能。</p>
<p>(3)形参又称为“<strong>形式参数</strong>”。形参表是用逗号分隔的一组变量说明，包括形参的类型和形参的标识符，其作用是指出每一个形参的类型和形参的名称，当调用函数时，接收来自主调函数的数据，确定各参数的值。</p>
<p>(4)用{ }括起来的部分是函数的主体，称为<strong>函数体</strong>。函数体是一段程序，确定该函数应完成的规定的运算，应执行的规定的动作，集中体现了函数的功能。函数内部应有自己的<strong>说明语句</strong>和<strong>执行语句</strong>，但函数内定义的变量不可以与形参同名。花括号{ }是不可以省略的。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><blockquote>
<p>主调函数使用被调函数的功能，称为<strong>函数调用</strong>。</p>
</blockquote>
<p>在C语言中，只有在<strong>函数调用</strong>时，函数体中定义的功能才会被执行。C语言中，<strong>函数调用</strong>的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(类型 形参,类型 形参...);</span><br></pre></td></tr></table></figure>



<p>对无参函数调用时则无实际参数表。</p>
<p>实际参数表中的参数可以是<strong>常数、变量或其他构造类型数据及表达式</strong>，各实参之间用逗号分隔。</p>
<p>在C语言中，可以用以下几种方式<strong>调用函数</strong>。</p>
<p>​        (1)<strong>函数表达式</strong>：函数作为表达式中的一项出现在表达式中，以函数返回值参与表达式的运算。这种方式要求函数是有返回值的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z=max(x,y);</span><br></pre></td></tr></table></figure>

<p>是一个赋值表达式，把max的返回值赋予变量z。</p>
<p>​        (2)<strong>函数语句</strong>：函数调用的一般形式加上分号即构成函数语句，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br></pre></td></tr></table></figure>

<p>都是以函数语句的方式调用函数。</p>
<p>​        (3)<strong>函数实参</strong>：函数作为另一个函数调用的实际参数出现。这种情况是把该函数的返回值作为实参进行传送，因此要求该函数必须是有返回值的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max(x,y));<span class="comment">/*把max调用的返回值作为printf函数的实参*/</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​        <strong>在主调函数中调用某函数之前应对该被调函数进行声明</strong>，在主调函数中对被调函数进行声明的目的是使编译系统知道被调函数返回值的类型，以便在主调函数中按此种类型对返回值进行相应的处理。其一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 被调函数名(类型 形参,类型 形参...);</span><br></pre></td></tr></table></figure>

<p>​        需要注意的是，<strong>函数的声明</strong>和<strong>函数的定义</strong>有本质上的不同，主要区别在以下两个方面：</p>
<p>(1)函数的定义是编写一段程序，应有函数的具体功能语句——<strong>函数体</strong>，而函数的声明仅是向编译系统的一个说明，不含具体的执行动作。</p>
<p>(2)在程序中，函数的定义只能有一次，而函数的声明可以有多次。</p>
<h2 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h2><p>​        在C语言中，<strong>变量</strong>是对程序中数据所占内存空间的一种抽象定义，定义变量时，用户定义变量的名、变量的类型，这些都是变量的操作属性。<em>不仅可以通过变量名访问该变量，系统还通过该标识符确定变量在内存中的位置。</em></p>
<p>​        在计算机中，保存变量当前值的<strong>存储单元</strong>有两类，一类是内存，另一类是CPU的寄存器。</p>
<p>​        变量的存储类型关系到变量的存储位置，C语言中定义了4种存储属性，即**自动变量(auto)、外部变量(extern)、静态变量(static)和寄存器变量(register)**，它关系到变量在内存中的存放位置，由此决定了变量的保留时间和变量的作用范围。</p>
<p>​        变量的保留时间又称为<strong>生存期</strong>，从时间角度，可将变量分为<strong>静态存储</strong>和<strong>动态存储</strong>两种情况：</p>
<p>（1）<strong>静态存储</strong>是指变量存储在内存的静态存储区，在编译时就分配了存储空间，在整个程序的运行期间，该变量占有固定的存储单元，程序结束后，这部分空间才释放，变量的值在整个程序中始终存在。</p>
<p>（2）<strong>动态存储</strong>是指变量存储在内存的动态存储区，在程序的运行过程中，只有当变量所在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值只在函数调用期存在。</p>
<p>​        变量的作用范围又称为<strong>作用域</strong>，从空间角度，可以将变量分为<strong>全局变量</strong>和<strong>局部变量</strong>：</p>
<p>（1）<strong>局部变量</strong>是在一个函数或复合语句内定义的变量，它仅在函数或复合语句内有效，编译时，编译系统不为局部变量分配内存单元，而是在程序运行过程中，当局部变量所在的函数被调用时，编译系统根据需要，临时分配内存，调用结束，空间释放。</p>
<p>（2）<strong>全局变量</strong>是在函数之外定义的变量，其作用范围为从定义处开始到本文件结束，编译时，编译系统为其分配固定的内存单元，在程序运行的自始至终都占用固定单元。</p>
<h2 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h2><p>​        <strong>函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的，数据存储在动态存储区中</strong>。</p>
<p>​        函数中的形参和在函数中定义的变量（包括在复合语句中定义的变量）都属此类，在调用该函数时系统会给它们分配存储空间，在函数调用结束时就自动释放这些存储空间，这类局部变量称为<strong>自动变量</strong>。</p>
<p>自动变量用<strong>关键字auto</strong>进行存储类别的声明，例如声明一个自动变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">	auto int b,c=3; /*定义b,c为自动变量*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a是函数fun()的形参，b、c是自动变量，并对c赋初值3。执行完fun()函数后，自动释放a、b、c所占的存储单元。</p>
<h2 id="extern外部变量"><a href="#extern外部变量" class="headerlink" title="extern外部变量"></a>extern外部变量</h2><p>​        <strong>外部变量</strong>，即<strong>全局变量</strong>，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。</p>
<ol>
<li><p>如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件末尾。</p>
</li>
<li><p>如果在定义点之前的函数想引用该外部变量，则应该在引用之前用<strong>关键字extern</strong>对该变量进行“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
</li>
</ol>
<p>​    通常的，用extern声明外部变量，扩展程序文件中的作用域</p>
<h2 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h2><p>​        有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定局部变量为<strong>静态局部变量</strong>，用<strong>关键字static</strong>进行声明。</p>
<p>​        通过用static类型声明后的变量，<strong>其变量的内存空间位于内存的全局静态区</strong>，仅会<strong>初始化一次</strong>，这是一个非常重要的特性，请大家通过如下的程序理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a = a*<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a = %d \n&quot;</span>, a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    fun();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:     </span><br><span class="line"><span class="comment">//这个结果的原因在于，每次a的值是接着上一次函数调用的值继续运算的，并非每次都初始化从5开始计算，这就是static的特性，请大家好好理解</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">a=<span class="number">20</span></span><br><span class="line">a=<span class="number">40</span></span><br><span class="line">a=<span class="number">80</span></span><br><span class="line">a=<span class="number">160</span></span><br><span class="line">a=<span class="number">320</span></span><br><span class="line">a=<span class="number">640</span></span><br><span class="line">a=<span class="number">1280</span></span><br><span class="line">a=<span class="number">2560</span></span><br><span class="line">a=<span class="number">5120</span></span><br></pre></td></tr></table></figure>



<h2 id="register寄存器变量"><a href="#register寄存器变量" class="headerlink" title="register寄存器变量"></a>register寄存器变量</h2><p>​        为提高效率，C语言允许将局部变量的值存放在CPU的寄存器中，这种变量叫做<strong>寄存器变量</strong>，用<strong>关键字register</strong>声明。使用寄存器变量需要注意以下几点：</p>
<ol>
<li><strong>只有局部自动变量和形式参数可以作为寄存器变量</strong></li>
<li>一个计算机系统中的寄存器数目有限，<strong>不能定义任意多个寄存器变量</strong></li>
<li><strong>不能使用取地址运算符“&amp;”求寄存器变量的地址</strong></li>
</ol>
<p>例如如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a=<span class="number">0</span>; <span class="comment">//将变量a存储在寄存器上</span></span><br></pre></td></tr></table></figure>



<p>在C语言发展迭代的今天，当我们尝试用regiter声明一个变量时，编译器很可能会根据情况，把”register”忽略掉，需要大家知晓这一情况。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>​        数组是同类型有序数据的集合，可以为这些数据的集合起一个名字，称为<strong>数组名</strong>。该集合中的各个数据项称为<strong>数组元素</strong>，每个元素可用数组名和下标表示。</p>
<p>​        <strong>一维数组</strong>(姑且先叫一维数组)的定义和使用：</p>
<p>​        在C语言中使用数组必须先进行定义，一维数组的定义方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 数组名 [常量表达式];</span><br></pre></td></tr></table></figure>



<p>​        其中<strong>类型说明符</strong>是任意一种<strong>基本数据类型 或 构造数据类型</strong>，它定义了全体数组成员的数据类型，可以发现要比我们定义N个元素要方便的多了，如果把一个元素看作一个点，那么一维数组就像一条线。</p>
<p>​        名是用户定义的<strong>数组标识符</strong>，方括号中的常量表达式表示数据元素的个数，也称为<strong>数组的长度</strong>。需要注意的是，数组中的元素下标是从0开始计算的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">//定义一个数组名为a，存储100个int类型的数组，其元素分别是a[0]~a[99]</span></span><br><span class="line"><span class="keyword">float</span> b[<span class="number">10</span>];<span class="comment">//数组名为b的，存储10个float类型的数组，其元素分别是b[0]~b[9]</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">256</span>]; <span class="comment">//定义一个数组名为c的字符型数组，长度为256，其元素分别是c[0]~c[255]</span></span><br></pre></td></tr></table></figure>

<p>​        当在函数中只定义数组时，数组里的值和函数里定义一个变量的值一样，都是未初始化过的，我们也可以定义的时候并初始化赋值，并且，当给部分元素赋初值的时候，未被赋值的元素将自动赋值为0，更细一些，int类型未被赋值的元素为0，浮点型为小数类型，而字符类型则为’\0’，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//定义一个整型数组a，前5个元素即赋值为1，2，3，4，5，后95个元素值值全部为0</span></span><br><span class="line"><span class="keyword">float</span> b[<span class="number">10</span>]=&#123;&#125;<span class="number">1.1</span>, <span class="number">2</span>,<span class="number">2</span>, <span class="number">0.0</span>&#125;; <span class="comment">//定义float数组b并对全部float类型的元素都分别赋值</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">256</span>] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span>&#125;; <span class="comment">//定义一个数组名为c的字符型数组，并对前9个元素进行赋值，其余元素全部为&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>​        一维数组是呈线性排布的，如果我们需要比如矩阵这样的结构时，该怎么办？一个最直观的想法就是每一行都用一个一维数组存放，那么有几行，就需要几个一维数组。等等，还记得上节课的点与线的关系吗？那矩阵这种结构就是线与面的关系！丹尼斯·里奇同样为我们提供了<strong>二维数组</strong>（<strong>多维数组</strong>）这样的东西，很好地解决了这个问题。</p>
<p><strong>二维数组的定义</strong><br>类型说明符 数组名[] [];</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">/*定义一个整形二维数组a，有3行4列共12个元素分别为：a[0][0] a[0][1] a[0][2] a[0][3]</span></span><br><span class="line"><span class="comment">a[1][0] a[1][1] a[1][2] a[1][3]</span></span><br><span class="line"><span class="comment">a[2][0] a[2][1] a[2][2] a[2][3]*/</span></span><br><span class="line"><span class="keyword">char</span> arry[<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">//定义一个字符型二维数组arry，有10行10列，依次为arry[0][0]~arry[9][9]共100个元素</span></span><br></pre></td></tr></table></figure>



<p><strong>二维数组的初始化</strong></p>
<p>二维数组可以用以下两种方式初始化赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;,&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>&#125;&#125;; <span class="comment">//定义一个三行四列的二维数组，按行赋值</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>&#125;;  <span class="comment">//定义一个三行四列的二维数组并对其中的12（3*4）个元素进行赋值</span></span><br></pre></td></tr></table></figure>

<p>您可能会想，为什么第二种也可以？这样的话，定义int a 【3][4]和定义int a[12]有什么区别呢？</p>
<ul>
<li>真相是：二维数组与一维数组一样在内存中的存储也是按照线性排布的</li>
</ul>
<h2 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h2><p>​        用来存放字符的数组称为<strong>字符数组</strong>。字符数组的各个元素依次存放字符串的各字符，字符数组的数组名代表该数组的<strong>首地址</strong>，这为处理字符串中个别字符和引用整个字符串提供了极大的方便。</p>
<p>字符数组的定义形式与前面介绍的数值数组相同，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>];		</span><br></pre></td></tr></table></figure>



<p>字符数组也允许在定义时进行初始化赋值，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>]=&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; h &#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;a&#x27;</span>， <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>对字符数组的各个元素逐个赋值后，各元素的值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">0</span>]= ``<span class="string">&#x27;c&#x27;</span>``,c[<span class="number">1</span>]= ``<span class="string">&#x27;h&#x27;</span>``,c[<span class="number">2</span>]= ``<span class="string">&#x27;i&#x27;</span>``,c[<span class="number">3</span>]= ``<span class="string">&#x27;n&#x27;</span>``,c[<span class="number">4</span>]= ``<span class="string">&#x27;a&#x27;</span>``,c[<span class="number">5</span>]= ``<span class="string">&#x27;\0&#x27;</span>``;</span><br></pre></td></tr></table></figure>



<p>其中,‘\0’为<strong>字符串结束符</strong>。如果不对c[5]赋任何值，‘\0’会由系统自动添加。字符数组也可采用字符串常量的赋值方式，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[]=&#123;<span class="string">&quot;china&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>熟悉了C语言中字符串的存储表达方式之后，大家可以扩展学习：</p>
<p><a target="_blank" rel="noopener" href="https://www.dotcpp.com/course/579">字符串的常见处理函数</a>，包括strcmp、strcpy、strlen、strcat等等，增加字符串的处理能力。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>​        在学习指针之前，我们先弄清楚一个概念：<strong>地址</strong></p>
<p>​        何谓地址？在内存（注意：我们这里提到的内存并不是人们常说的计算机的物理内存，而是虚拟的逻辑内存空间）中，简单地说：地址就是可以唯一标识某一点的一个编号，即一个数字！我们都见过尺子，我们统一以毫米为单位，一把长1000毫米的尺子，其范围区间为0~999，而我们可以准确的找到35毫米、256毫米处的位置。</p>
<p>​        同样的道理，内存也如此，也是像尺子一样线性排布，只不过这个范围略大，在我们最广泛使用的32位操作系统下，是从0~4,294,967,295之间，而地址就是这之中的的一个编号而已，习惯上，在计算机里地址我们常常用其对应的十六进制数来表示，比如0x12ff7c这样。</p>
<p>​        在我们的C程序中，每一个定义的变量，在内存中都占有一个内存单元，比如int类型占四个字节，char类型占一个字节等等，每个字节都在0~4,294,967,295之间都有一个对应的编号，C语言允许在程序中使用变量的地址，并可以通过地址运算符”&amp;”得到变量的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>]=&#123;<span class="string">&quot;clanguage&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;int address:0x %x,value:%d\n&quot;</span>,&amp;a[i],a[i]);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;char address:0x%x,value:%c\n&quot;</span>,&amp;b[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff360,value:<span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff364,value:<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff368,value:<span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff36c,value:<span class="number">4</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff370,value:<span class="number">5</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff374,value:<span class="number">6</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff378,value:<span class="number">7</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff37c,value:<span class="number">8</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff380,value:<span class="number">9</span></span><br><span class="line"><span class="keyword">int</span> address:<span class="number">0</span>x efbff384,value:<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff356,value:c</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff357,value:l</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff358,value:a</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff359,value:n</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35a,value:g</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35b,value:u</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35c,value:a</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35d,value:g</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35e,value:e</span><br><span class="line"><span class="keyword">char</span> address:<span class="number">0</span>x efbff35f,value:x00</span><br></pre></td></tr></table></figure>

<h2 id="指针定义和使用"><a href="#指针定义和使用" class="headerlink" title="指针定义和使用"></a>指针定义和使用</h2><p>​        简单地讲，地址就是逻辑内存上的编号，而指针虽然也表示一个编号，也是一个地址。但两者性质却不相同。一个代表了常量，另一个则是变量。就好比内存是一把尺子，而指针就是尺子上面的游标，可以左右移动，它某一个时刻是指向一个地方的，这就是<strong>指针变量</strong>。</p>
<blockquote>
<p>对指针变量定义的一般形式为：<br>                类型说明符 *变量名;</p>
</blockquote>
<p>其中，这里的与前面的类型说明符共同说明这是一个指针变量，类型说明符表示该指针变量<strong>所指向的变量</strong>为何种数据类型，变量名即为定义的<strong>指针变量名</strong>。除此之外，C还提供运算符获取地址上对应的值，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">2014</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;num;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num Address = 0x%x,num=%d\n&quot;</span>,&amp;num,num);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x, *p = %d\n&quot;</span>),p,*p;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*&amp;num);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line"> <span class="comment">/* num Address = 0xefbff348,num=2014</span></span><br><span class="line"><span class="comment"> 		p = 0xefbff348, *p = 2014</span></span><br><span class="line"><span class="comment"> 		2014   */</span></span><br></pre></td></tr></table></figure>

<p>​        现在假设有一个 char 类型的变量 c，它存储了字符 ‘K’（ASCII码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190114/1IG34354-0.png" alt="img">   </p>
<p>​        <code>*</code>是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带<code>*</code>。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上<code>*</code>，后边可以像使用普通变量一样来使用指针变量。也就是说，**定义指针变量时必须带<code>*</code>，给指针变量赋值时不能带<code>*</code>**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义普通变量</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">99.5</span>, b = <span class="number">10.6</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;@&#x27;</span>, d = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="comment">//定义指针变量</span></span><br><span class="line"><span class="keyword">float</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">char</span> *p2 = &amp;c;</span><br><span class="line"><span class="comment">//修改指针变量的值</span></span><br><span class="line">p1 = &amp;b;</span><br><span class="line">p2 = &amp;d;</span><br></pre></td></tr></table></figure>

<p>​        假设变量 a、b、c、d 的地址分别为 0X1000、0X1004、0X2000、0X2004，下面的示意图很好地反映了 p1、p2 指向的变化：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190114/1IG3J50-1.jpg" alt="img">  </p>
<p>​    </p>
<p>值得一提的是，由于<strong>指针存放的都是地址</strong>，在364位操作系统下都在0~4,294,967,295这个数区间内，所以，<strong>在64位操作系统下，任何类型的指针变量都占8个字节</strong>！  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        <span class="keyword">char</span> *p1;</span><br><span class="line">        <span class="keyword">float</span> *p2;</span><br><span class="line">        <span class="keyword">double</span> *p3;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">INFO</span> *<span class="title">p4</span>;</span>   <span class="comment">//struct INFO类型为结构体类型 我们将会在后面的章节中讲解</span></span><br><span class="line">        <span class="keyword">void</span> *p5;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;int point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;char point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p1));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;float point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p2));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;double point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p3));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;struct point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p4));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;void point size is :%d\n&quot;</span>,<span class="keyword">sizeof</span>(p5));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line"><span class="keyword">int</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="keyword">char</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="keyword">float</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="keyword">double</span> point size is :<span class="number">8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">size</span> <span class="title">is</span> :</span><span class="number">8</span></span><br><span class="line"><span class="keyword">void</span> point size is :<span class="number">8</span></span><br></pre></td></tr></table></figure>



<h2 id="数组和指针的区别和联系"><a href="#数组和指针的区别和联系" class="headerlink" title="数组和指针的区别和联系"></a>数组和指针的区别和联系</h2><p>​        前面我们已经知道，通过数组下标可以确定数组元素在数组中的<strong>顺序</strong>和<strong>存储地址</strong>。由于每个数组元素相当于一个变量，因此<strong>指针变量</strong>可以指向数组中的元素，也就是说可以用指针方式访问数组中的元素。</p>
<p>​        对一个指向数组元素的指针变量的定义和赋值方法，与指针变量相同，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; ``<span class="comment">/*定义a为包含10个整型数据的数组*/</span></span><br><span class="line"><span class="keyword">int</span> *p; ``<span class="comment">/*定义p为指向整型变量的指针*/</span></span><br><span class="line">p=&amp;a[<span class="number">0</span>]; ``<span class="comment">/*把a[0]元素的地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure>

<p> C语言规定，数组名代表数组的首地址，也就是第0号元素的地址。因此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=a; <span class="comment">/* 等价于p=&amp;a[0]; */</span></span><br><span class="line"><span class="keyword">int</span> *p=a; <span class="comment">/* 等价于int *p=&amp;a[0]; */</span></span><br></pre></td></tr></table></figure>



<p>对于指向首地址的指针p，p+i(或a+i)就是数组元素a[i]的地址，*(p+i)( 或*(a+i) )就是a[i]的值。</p>
<p>如果指针变量p已指向数组中的某一个元素，则p+1指向同一数组中的下一个元素。</p>
<p>引入指针变量后，就可以用以下两种方法来访问<strong>数组元素</strong>：<br>(1)<strong>下标法</strong>，即用a[i]形式访问数组元素，在前面介绍数组时都是采用这种方法。<br>(2)<strong>指针法</strong>，即采用*(a+i)或*(p+i)形式，用间接访问的方法来访问数组元素，其中a是数组名，p是指向数组的指针变量，其初值p=a。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> *p=a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;P Value:%d   a Value :%d\n&quot;</span>,*(p++),*(a+i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">  <span class="comment">/* P Value:1   a Value :1</span></span><br><span class="line"><span class="comment">P Value:2   a Value :2</span></span><br><span class="line"><span class="comment">P Value:3   a Value :3</span></span><br><span class="line"><span class="comment">P Value:4   a Value :4</span></span><br><span class="line"><span class="comment">P Value:5   a Value :5</span></span><br><span class="line"><span class="comment">P Value:6   a Value :6</span></span><br><span class="line"><span class="comment">P Value:7   a Value :7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>注意输出的两种方式，指针可以通过++或–并修改自身值的方式移动，然而数组名本身值不可以被更改。</p>
<h2 id="字符串与指针的用法"><a href="#字符串与指针的用法" class="headerlink" title="字符串与指针的用法"></a>字符串与指针的用法</h2><p>前面我们已经讨论过字符数组与字符串，<strong>字符指针</strong>也可以指向一个字符串，可以用字符串常量对字符指针进行<strong>初始化</strong>，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;www.dotcpp.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这是对字符指针进行初始化。此时，字符指针指向一个字符串常量的<strong>首地址</strong>。</p>
<p>还可以用字符数组来存放字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[ ] = <span class="string">&quot;Welcome to dotcpp.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个语句中，string是数组名，代表字符数组的首地址。因此可以通过数组名string来访问字符串。</p>
<p>字符串指针和字符串数组两种方式都可以访问字符串，但它们有着本质的区别：字符指针str是个变量，可以改变str使它指向不同的字符串，但不能改变str所指向的字符串常量的值。而string是一个数组，可以改变数组中保存的内容。应注意字符串指针和字符串数组的区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;www.dotcpp.com&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[]=<span class="string">&quot;Welcome to dotcpp.com&quot;</span>;</span><br><span class="line">    str[<span class="number">0</span>]=<span class="string">&#x27;C&#x27;</span>; <span class="comment">//试图修改str指向的常量区的字符串内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">错误的做法❌</span><br></pre></td></tr></table></figure>



<h1 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h1><h2 id="struct结构体的定义和使用"><a href="#struct结构体的定义和使用" class="headerlink" title="struct结构体的定义和使用"></a>struct结构体的定义和使用</h2><p><strong>结构体</strong>与数组类似，都是由若干分量组成的，与数组不同的是，结构体的成员可以是不同类型，可以通过成员名来访问结构体的元素。</p>
<p><strong>结构体的定义</strong>说明了它的组成成员，以及每个成员的数据类型。定义一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名 </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  数据类型 成员名 <span class="number">1</span>; ``  ``</span><br><span class="line">  数据类型 成员名 <span class="number">2</span>; ``  ``</span><br><span class="line">  ...... ``  ``</span><br><span class="line">  数据类型 成员名 n; ``</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构的定义说明了变量在结构中的存在格式，要使用该结构就必须说明结构类型的变量。<strong>结构变量说明</strong>的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名称 结构变量名;</span></span><br></pre></td></tr></table></figure>



<p>定义结构体便是定义了一种由成员组成的复合类型，而用这种类型说明了一个变量才会产生具体的实体。与说明基本数据类型的变量一样，系统会按照结构定义时的内部组成，为说明的结构变量分配内存空间。<strong>结构变量的成员在内存中占用连续的存储区域，所占内存大小为结构中每个成员的长度之和。</strong></p>
<p>我们可以将变量student1说明为address类型的结构变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span> <span class="title">student1</span>;</span></span><br></pre></td></tr></table></figure>

<p>虽然，结构体作为若干成员的集合是一个整体，但在使用结构时，不仅要对结构的整体进行操作，还经常要访问结构中的每一个成员。在程序中<strong>使用结构中成员</strong>的方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构变量名.成员名称</span><br></pre></td></tr></table></figure>

<p>如student1.tel表示结构变量student1的电话信息。</p>
<p>和其他类型的变量一样，结构变量也可以进行初始化。<strong>结构初始化</strong>的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名 结构变量 =</span> &#123; 初始化数据 <span class="number">1</span>, ...... 初始化数据 n &#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span> <span class="title">A</span>;</span></span><br><span class="line">    A.num = <span class="number">2014</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(A.str,<span class="string">&quot;Welcome to dotcpp.com&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This year is %d %s\n&quot;</span>,A.num,A.str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p><strong>结构体数组</strong>是一个数组，其数组的每一个元素都是<strong>结构体类型</strong>。</p>
<p>在实际应用中，经常用结构体数组来表示具有相同数据结构的一个群体，如一个班的学生档案，一个车间职工的工资表等。</p>
<p>定义结构体数组和结构体变量相仿，只需说明它为数组类型即可。比如定义一个结构体数组student，包含3个元素：student[0]、student[1]、student[2]，每个数组元素都具有struct address的结构形式，并对该结构体数组进行初始化赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>]; <span class="comment">/*姓名，字符数组作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">char</span> street[<span class="number">40</span>]; <span class="comment">/*街道*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tel; <span class="comment">/*电话，无符号长整型作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> zip; <span class="comment">/*邮政编码*/</span></span><br><span class="line">&#125;student[<span class="number">3</span>]=&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Zhang&quot;</span>,<span class="string">&quot;Road NO.1&quot;</span>,<span class="number">111111</span>,<span class="number">4444</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot; Road NO.2&quot;</span>,<span class="number">222222</span>,<span class="number">5555</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Li&quot;</span>,<span class="string">&quot; Road NO.3&quot;</span>,<span class="number">333333</span>,<span class="number">6666</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="结构体指针及具体操作"><a href="#结构体指针及具体操作" class="headerlink" title="结构体指针及具体操作"></a>结构体指针及具体操作</h2><p><strong>结构体指针</strong>即指向结构体的指针。</p>
<p>当一个指针用来指向一个结构体变量时，称之为<strong>结构体指针变量</strong>。结构体指针变量中的值是所指向的结构变量的首地址，通过结构指针即可访问该结构变量。这与数组指针和函数指针的情况是相同的。结构体指针变量定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名 *结构指针变量名</span></span><br></pre></td></tr></table></figure>



<p>定义之后，就可以像之前学过的指针一样，将结构体类型的变量赋值给这个指针即可，后面就可以用这个指针间接的访问结构体了，需要注意的是，不用于结构体变量用点（**.<strong>）来访问成员的方法，结构体指针是通过箭头（</strong>-&gt;**）来访问的，下面给大家一个完整的例子来学习。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>]; <span class="comment">/*姓名，字符数组作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">char</span> street[<span class="number">40</span>]; <span class="comment">/*街道*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tel; <span class="comment">/*电话，无符号长整型作为结构体中的成员*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> zip; <span class="comment">/*邮政编码*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> <span class="title">A</span>[3]=</span>&#123;&#123;<span class="string">&quot;Zhang&quot;</span>,<span class="string">&quot;Road NO.1&quot;</span>,<span class="number">111111</span>,<span class="number">4444</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang&quot;</span>,<span class="string">&quot; Road NO.2&quot;</span>,<span class="number">222222</span>,<span class="number">5555</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Li&quot;</span>,<span class="string">&quot; Road NO.3&quot;</span>,<span class="number">333333</span>,<span class="number">6666</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> *<span class="title">p</span>;</span></span><br><span class="line">    p=&amp;A[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s %u %u\n&quot;</span>,p-&gt;name,p-&gt;street,p-&gt;tel,p-&gt;zip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">  Zhang Road NO<span class="number">.1</span> <span class="number">111111</span> <span class="number">4444</span></span><br></pre></td></tr></table></figure>

<h2 id="typedef用法详解"><a href="#typedef用法详解" class="headerlink" title="typedef用法详解"></a>typedef用法详解</h2><p>在C语言中，除系统定义的标准类型和用户自定义的结构体、共用体等类型之外，还可以使用类型说明语句typedef定义新的类型来代替已有的类型。typedef语句的一般形式是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 已定义的类型 新的类型;</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTEGER; ``<span class="comment">/*指定用 INTEGER 代表 int 类型*/</span>``</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> REAL; ``<span class="comment">/*指定用 REAL 代表 float 类型*/</span></span><br></pre></td></tr></table></figure>



<p>在具有上述<strong>typedef语句</strong>的程序中，下列语句就是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j; <span class="comment">/*与 INTEGER i,j;*/</span>``</span><br><span class="line"><span class="keyword">float</span> pi; <span class="comment">/*与 REAL pi;*/</span></span><br></pre></td></tr></table></figure>



<p>当然typedef的最常用的作用就是给<strong>结构体变量</strong>重命名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;INFO;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">INFO</span> <span class="title">A</span>;</span></span><br><span class="line">    INFO B; <span class="comment">//通过typedef重命名后的名字INFO与struct _INFO完全等价！</span></span><br><span class="line">    A.num = <span class="number">2014</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(A.str,<span class="string">&quot;Welcome to dotcpp.com&quot;</span>);</span><br><span class="line">    B=A;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T1his year is %d %s\n&quot;</span>,A.num,A.str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This year is %d %s\n&quot;</span>,B.num,B.str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="enum枚举类型详解"><a href="#enum枚举类型详解" class="headerlink" title="enum枚举类型详解"></a>enum枚举类型详解</h2><p>C语言中还有一种特殊的类型：<strong>枚举类型</strong>，它可以让代码更简介、更易读，通过<strong>关键字enum</strong>实现，一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就会定义了一个“枚举名”的枚举类型，其值为枚举元素1（即0）、枚举元素2（即1）…（依次递增）</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>​        一直以来，我们学习C语言都是数据的处理，这些数据都是在内存中的。一旦程序结束，程序结束退出，数据也将灰飞烟灭。<strong>文件操作</strong>的实现将帮助我们把数据存储到文件中，既硬盘上的文件，如我们所熟知的txt格式，或其他各种后缀的文件，避免程序结束后数据丢失，实现存储数据的功能，甚至充当“<strong>数据库</strong>”的功能。</p>
<p>​        下面为大家C语言中操作文件的流程与方法。</p>
<p>​        在C语言中，除了我们认识的文件，还是系统设备都将视为文件来看待。对于文件的操作分为三个步骤：</p>
<p>第一步：<strong>打开文件</strong></p>
<ul>
<li>需要用到<strong>fopen函数</strong>来实现，这一步作用主要是建立程序和文件的关系，获取文件在内存中的文件指针，方便后面两步</li>
</ul>
<p>第二步：<strong>读写文件</strong></p>
<ul>
<li>读写文件分为<strong>fprintf</strong>、<strong>fscanf</strong>或者<strong>fwrite</strong>、<strong>fread</strong>或者<strong>fputs</strong>、<strong>getss</strong>等多组函数来实现</li>
<li>每组函数都分别是写和读文件。就像我们熟知的printf和scanf这组输入输出文件一样，这不过这里的读写不是向屏幕，而是向文件</li>
</ul>
<p>第三步：<strong>关闭文件</strong></p>
<ul>
<li>关闭文件则需要<strong>fclose函数</strong>实现。这一步则是切断文件指针和文件的关联，避免误操作。如果未关闭文件就对文件进行读写删除等操作，就是出现类似“正在被使用，无法修改”的提示</li>
</ul>
<h2 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h2><p>在C语言中，对文件操作之前，首先需要打开文件，使用的函数是<strong>fopen函数</strong>，它的作用是<strong>打开文件</strong>，获取该文件的文件指针，方便后续操作。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>



<p>可以看得出来，该函数需要两个字符串类型的参数，第一个是<strong>文件名</strong>，既要操作的文件对象。第二个是<strong>打开方式</strong>，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写还是追加等等等等，具体类型如下表，可以根据情况使用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>r+</td>
<td>以读/写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td>rb+</td>
<td>以读/写方式打开一个二进制文件，只允许读/写数据。</td>
</tr>
<tr>
<td>rt+</td>
<td>以读/写方式打开一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>w</td>
<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>
</tr>
<tr>
<td>a</td>
<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td>
</tr>
<tr>
<td>a+</td>
<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td>
</tr>
<tr>
<td>wb</td>
<td>以只写方式打开或新建一个二进制文件，只允许写数据。</td>
</tr>
<tr>
<td>wb+</td>
<td>以读/写方式打开或新建一个二进制文件，允许读和写。</td>
</tr>
<tr>
<td>wt+</td>
<td>以读/写方式打开或新建一个文本文件，允许读和写。</td>
</tr>
<tr>
<td>at+</td>
<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td>
</tr>
<tr>
<td>ab+</td>
<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td>
</tr>
</tbody></table>
<p>函数的返回值则表示打开成功后的文件指针，格式为<strong>FILE类型</strong>，是一个结构体类型，供后面使用，如果打开失败，则返回NULL。</p>
<p>比如：如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据，那么我们可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp=fopen(<span class="string">&quot;d:\\abc.dat&quot;</span>,<span class="string">&quot;r&quot;</span>)<span class="comment">//后面通过fp指针开始读文件</span></span><br></pre></td></tr></table></figure>



<p>值得说明的是：</p>
<ol>
<li><p>该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。</p>
</li>
<li><p>路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作<strong>转义字符</strong>处理，因此要用两个反斜杠才能表示一个。</p>
</li>
<li><p>一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！</p>
</li>
</ol>
<h2 id="fprintf-函数-写文件"><a href="#fprintf-函数-写文件" class="headerlink" title="fprintf()函数-写文件"></a>fprintf()函数-写文件</h2><p>上一节，我们学会了打开文件之后，如果打开模式是写，那么可以用<strong>fprintf函数</strong>来进行写，下面来介绍fprintf函数，它的原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE * stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, [argument])</span></span></span><br></pre></td></tr></table></figure>



<p>该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数<strong>文件指针</strong>，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;www.dotcpp.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这句代码的意思是将字符串”<a href="http://www.dotcpp.com&quot;以%s的格式写入fp所指向的文件中。">www.dotcpp.com&quot;以%s的格式写入fp所指向的文件中。</a></p>
<table>
<thead>
<tr>
<th>控制符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%d 或 %i</td>
<td>有符号十进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>使用 e 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td>%E</td>
<td>使用 E 字符的科学科学记数法（尾数和指数）</td>
</tr>
<tr>
<td>%f</td>
<td>十进制浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>自动选择 %e 或 %f 中合适的表示法</td>
</tr>
<tr>
<td>%G</td>
<td>自动选择 %E 或 %f 中合适的表示法</td>
</tr>
<tr>
<td>%o</td>
<td>有符号八进制</td>
</tr>
<tr>
<td>%s</td>
<td>字符的字符串</td>
</tr>
<tr>
<td>%u</td>
<td>无符号十进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>无符号十六进制整数</td>
</tr>
<tr>
<td>%X</td>
<td>无符号十六进制整数（大写字母）</td>
</tr>
<tr>
<td>%p</td>
<td>指针地址</td>
</tr>
<tr>
<td>%n</td>
<td>无输出</td>
</tr>
<tr>
<td>%</td>
<td>字符</td>
</tr>
</tbody></table>
<p>更多的格式可以参照<a target="_blank" rel="noopener" href="https://www.dotcpp.com/course/14">printf的用法</a>中的格式，可以通用。</p>
<p>而返回值为<strong>整型</strong>，如果写入成功则返回写入字符的格式，否则返回一个<strong>负数</strong>。</p>
<p>需要注意理解的是，fprintf函数虽然和printf函数很像，表示输出，但准确说是是<strong>写入</strong>的意思，是指程序向文件里写，要清楚数据的流向。</p>
<h2 id="scanf-函数-读文件"><a href="#scanf-函数-读文件" class="headerlink" title="scanf()函数-读文件"></a>scanf()函数-读文件</h2><p>如同printf与scanf的关系一样，fprintf和fscanf也是如此，fprintf负责向文件里写数据，<strong>fscanf函数</strong>则可以从文件里读数据，它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *format[,argument...])</span></span>;</span><br></pre></td></tr></table></figure>



<p>作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数<strong>文件指针</strong>，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">fscanf</span> (fp, <span class="string">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>

<p>则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中。</p>
<p>更多fscanf的格式如下表：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>读入一个十进制整数</td>
</tr>
<tr>
<td>%i</td>
<td>读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25</td>
</tr>
<tr>
<td>%u</td>
<td>读入一个无符号十进制整数</td>
</tr>
<tr>
<td>%f %F %g %G</td>
<td>用来输入实数，可以用小数形式或指数形式输入</td>
</tr>
<tr>
<td>%x %x</td>
<td>读入十六进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>读入八进制整数</td>
</tr>
<tr>
<td>%s</td>
<td>直到遇到一个空格字符（空格字符可以是空白、换行和制表符）</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符</td>
</tr>
</tbody></table>
<h2 id="fwrite-函数-写文件"><a href="#fwrite-函数-写文件" class="headerlink" title="fwrite()函数-写文件"></a>fwrite()函数-写文件</h2><p>到目前位置，我们已经学习了C语言读写文件的函数fprintf和fscanf函数，除了这对格式化文件读写函数之外，还有很多。今天介绍的<strong>fwrite函数</strong>就是写文件的函数，它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>



<p>可以看到这个函数的<strong>参数</strong>有四个：</p>
<p>第一个ptr是要写入的数据的<strong>头指针</strong>，无符号类型；</p>
<p>第二个参数size是<strong>大小</strong>，表示每个写入元素的大小，单位是字节；</p>
<p>第三个参数nmemb是<strong>个数</strong>，以上一个参数为单位的个数；</p>
<p>第四个参数stream就是<strong>文件指针</strong>，表示往哪里写。</p>
<p>至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;``  </span><br><span class="line">	FILE fp;   </span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">&quot;www.dotcpp.com&quot;</span>;   </span><br><span class="line">	fp =  fopen(<span class="string">&quot;dotcpp.dat&quot;</span>, <span class="string">&quot;w&quot;</span>); </span><br><span class="line">  fwrite(str, <span class="keyword">sizeof</span>(str) , <span class="number">1</span>, fp );</span><br><span class="line">	fclose(fp); </span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了dotcpp.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的dotcpp.dat文件对比。</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li><p>预处理命令可以改变程序设计环境，提高编程效率，它们并不是C语言本身的组成部分，不能直接对它们进行编译，必须在对程序进行编译之前，先对程序中这些特殊的命令进行“预处理”。</p>
</li>
<li><p>经过预处理后，程序就不再包括预处理命令了，最后再由编译程序对预处理之后的源程序进行编译处理，得到可供执行的目标代码。</p>
</li>
<li><p>C语言提供的预处理功能有三种，分别为宏定义、文件包含和条件编译，下面将对它们进行简单介绍。</p>
</li>
</ul>
<h2 id="宏定义define的用法"><a href="#宏定义define的用法" class="headerlink" title="宏定义define的用法"></a>宏定义define的用法</h2><blockquote>
<p>宏定义在C语言源程序中允许用一个标识符来表示一个字符串，称为“宏”，被定义为“宏”的标识符称为“宏名”。</p>
</blockquote>
<p>​        在编译预处理时，对程序中所有出现的宏名，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。宏定义是由源程序中的宏定义命令完成的，宏代换是由预处理程序自动完成的。在C语言中，宏分为有参数和无参数两种。无参宏的宏名后不带参数，其定义的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 字符串;</span><br></pre></td></tr></table></figure>



<p>其中“#”表示这是一条预处理命令（在C语言中凡是以“#”开头的均为预处理命令）<strong>“define”为宏定义命令，“标识符”为所定义的宏名，“字符串”可以是常数、表达式、格式串等</strong>。</p>
<p>符号常量的定义就是一种无参宏定义。<br>此外，常常对程序中反复使用的表达式进行宏定义。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define M (y*y+3*y);</span><br></pre></td></tr></table></figure>

<p>它的作用是指定标识符M来代替表达式(y* y+3*y)。</p>
<p>在编写源程序时，所有的(y* y+3* y)都可由M代替，而对源程序进行编译时，将先由预处理程序进行宏代换，即用(y* y+3* y)表达式去置换所有的宏名M，然后再进行编译。</p>
<p>C语言允许宏带有参数。在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对于带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。</p>
<p>带参宏定义的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 宏名(形参表) 字符串;</span><br></pre></td></tr></table></figure>

<p>在字符串中含有各个形参。</p>
<p>带参宏调用的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宏名(实参表);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(y) y*y+3*y<span class="comment">/*宏定义*/</span></span></span><br><span class="line">......</span><br><span class="line">k=M(<span class="number">5</span>);  <span class="comment">/*宏调用*/</span></span><br></pre></td></tr></table></figure>

<p>……<br>在上面的宏调用时，用实参5去代替形参y，经预处理宏展开后的语句为：<br>k=5<em>5+3</em>5;</p>
<h2 id="include的用法"><a href="#include的用法" class="headerlink" title="include的用法"></a>include的用法</h2><p><strong>文件包含</strong><br>文件包含是C预处理程序的另一个重要功能，文件包含命令行的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;文件名&quot;</span></span></span><br><span class="line">或者</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。</p>
<p>在程序设计中，文件包含是很有用的。一个大的程序可以分为多个模块，由多个程序员分别编程，有些公用的符号常量或宏定义等可单独组成一个文件，在其他文件的开头用包含命令包含该文件即可使用。这样，可避免在每个文件开头都去书写那些公用量，从而节省时间，并减少出错。</p>
<p>这里对C语言的文件包含命令进行以下几点说明：</p>
<ol>
<li>包含命令中的文件名可以用<strong>双引号</strong>引起来，也可以用<strong>尖括号</strong>引起来。例如以下写法都是允许的：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是这两种形式是有区别的：</p>
<ul>
<li>使用尖括号表示在包含文件目录中去查找（包含目录是由系统的环境变量进行设置的，一般为系统头文件的默认存放目录，比如Linux系统在/usr/include目录下），而不在源文件的存放目录中查找；</li>
<li>使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找。用户编程时可根据自己文件所在的目录来选择某一种命令形式。</li>
</ul>
<ol start="2">
<li>一个include命令只能指定<strong>一个被包含文件</strong>，若有多个文件要包含，则需用多个include命令。</li>
</ol>
<ol start="3">
<li>文件包含允许<strong>嵌套</strong>，即在一个被包含的文件中又可以包含另一个文件。</li>
</ol>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><strong>条件编译</strong><br><strong>预处理程序</strong>提供了条件编译的功能，可以按不同的条件去编译不同的程序部分，因而产生不同的<strong>目标代码文件</strong>，这对于程序的移植和调试是很有用的。<strong>条件编译</strong>可分为三种形式。</p>
<p>第一种形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>它的功能是如果标识符已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。<br>如果没有程序段2（为空），本格式中的#else可以没有，即可以写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>第二种形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>与第一种形式的区别是将“ifdef”改为“ifndef”。它的功能是如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。这与第一种形式的功能正好相反。</p>
<p>第三种形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>它的功能是如果常量表达式的值为真（非0），则对程序段1进行编译，否则对程序段2进行编译。<br>因此可以使程序在不同的条件下完成不同的功能。</p>
<h2 id="其他与处理命令"><a href="#其他与处理命令" class="headerlink" title="其他与处理命令"></a>其他与处理命令</h2><p><strong>#error等其他常用预处理命令</strong></p>
<p>除了上面介绍的之外，C语言还有#error、#line、#pragma等其他常用的预处理命令，在很多C语言的程序中也是经常可见的，下面简单介绍一下它们。</p>
<p><strong>1. #error</strong><br>#error指令强制编译程序停止编译，它主要用于<strong>程序调试</strong>。#error指令的一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#error error-message</span><br></pre></td></tr></table></figure>

<p>注意：宏串error-message不用双引号引起来。遇到#error指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容。</p>
<p><strong>2. #line</strong><br>#line指令改变__LINE__和__FILE__的内容。__LINE__和__FILE__都是编译程序中<strong>预定义</strong>的标识符。__FILE__的内容是当前被编译源文件的文件名。</p>
<p>#line标识符__LINE__的内容是当前被编译代码行的行号，其一般形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#line number &quot;filename&quot;</span><br></pre></td></tr></table></figure>


<p>其中，number是正整数并变成__LINE__的新值；可选的“filename”是合法文件标识符并变成__FILE__的新值。#line主要用于调试和特殊应用。</p>
<p><strong>3. #pragma</strong><br>#pragma是编译程序实现时定义的指令，它允许由此向编译程序传入各种指令。例如：一个编译程序可能具有支持跟踪程序执行的选项，此时可以用#pragma语句选择该功能，编译程序忽略其不支持的#pragma选项。使用#pragma预处理命令可提高C源程序对编译程序的可移植性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/07/18/%E6%B5%85%E8%AF%86%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/18/%E6%B5%85%E8%AF%86%E5%B0%84%E7%94%B5%E5%A4%A9%E6%96%87/" class="post-title-link" itemprop="url">浅识射电天文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-18 11:45:24 / 修改时间：11:50:40" itemprop="dateCreated datePublished" datetime="2022-07-18T11:45:24+08:00">2022-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="射电天文学基础"><a href="#射电天文学基础" class="headerlink" title="射电天文学基础"></a>射电天文学基础</h1><h2 id="射电窗口"><a href="#射电窗口" class="headerlink" title="射电窗口"></a>射电窗口</h2><h2 id="一些基本定义"><a href="#一些基本定义" class="headerlink" title="一些基本定义"></a>一些基本定义</h2><h2 id="辐射转移"><a href="#辐射转移" class="headerlink" title="辐射转移"></a>辐射转移</h2><h2 id="黑体辐射和亮温度"><a href="#黑体辐射和亮温度" class="headerlink" title="黑体辐射和亮温度"></a>黑体辐射和亮温度</h2><h2 id="Nyquist原理和噪声温度"><a href="#Nyquist原理和噪声温度" class="headerlink" title="Nyquist原理和噪声温度"></a>Nyquist原理和噪声温度</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 23:12:50" itemprop="dateCreated datePublished" datetime="2022-06-20T23:12:50+08:00">2022-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-26 15:42:40" itemprop="dateModified" datetime="2022-08-26T15:42:40+08:00">2022-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><blockquote>
<p>参考书目：计算机网络–自顶向下 第七版</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://gaia.cs.umass.edu/kurose_ross/interactive">http://gaia.cs.umass.edu/kurose_ross/interactive</a> </p>
<p>端系统通过通信链路(communication link)和分组交换机(packet switch)连接到一起.</p>
<p><img src="/2022/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png">  </p>
<p>​        这里有许多类型的通信链路，它们由不同类型的物理媒体组成。这些物理媒体包括同轴电缆、铜线、光纤和无线电频谱。不同的链路能够以不同的速率传输 数据，链路的传输速率(transmission rate)以比特/秒(bit/s,或bps)度量。当一台端系 统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此 形成的信息包用计算机网络的术语来说称为分组(packet)。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p>
<p>​        分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。市面上流行着各种类型、各具特色的分组交换机，但在当今的因特网中，两种最著名的类型是路由器(router)和链路层交换机(link-layer switch)。这两种类型的交换机朝着最终目的地转发分组。链路层交换机通常用于接入网中，而路由器通常用于网络核心 中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径(route或path)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/06/09/OpenStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/OpenStack/" class="post-title-link" itemprop="url">OpenStack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-09 17:10:22" itemprop="dateCreated datePublished" datetime="2022-06-09T17:10:22+08:00">2022-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-13 16:10:10" itemprop="dateModified" datetime="2022-06-13T16:10:10+08:00">2022-06-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OpenStack-云计算平台学习与实践"><a href="#OpenStack-云计算平台学习与实践" class="headerlink" title="OpenStack 云计算平台学习与实践"></a>OpenStack 云计算平台学习与实践</h1><h1 id="云计算-和-OpenStack"><a href="#云计算-和-OpenStack" class="headerlink" title="云计算 和 OpenStack"></a>云计算 和 OpenStack</h1><blockquote>
<p>注：全文摘自CloudMan</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqF6TzeFS35dvTgauaRJ6AYOr7vOIFRNygXlHmjWfiaC9MicXIicZ5d44ibgyp96PPGbpBJ9bc62UMyD0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>IT系统架构的发展到目前为止大致可以分为3个阶段：</p>
<ol>
<li><p>物理机架构 这一阶段，应用部署和运行在物理机上。 比如企业要上一个ERP系统，如果规模不大，可以找3台物理机，分别部署Web服务器、应用服务器和数据库服务器。 如果规模大一点，各种服务器可以采用集群架构，但每个集群成员也还是直接部署在物理机上。 我见过的客户早期都是这种架构，一套应用一套服务器，通常系统的资源使用率都很低，达到20%的都是好的。</p>
</li>
<li><p>虚拟化架构 摩尔定律决定了物理服务器的计算能力越来越强，虚拟化技术的发展大大提高了物理服务器的资源使用率。 这个阶段，物理机上运行若干虚拟机，应用系统直接部署到虚拟机上。 虚拟化的好处还体现在减少了需要管理的物理机数量，同时节省了维护成本。</p>
</li>
<li><p>云计算架构 虚拟化提高了单台物理机的资源使用率，随着虚拟化技术的应用，IT环境中有越来越多的虚拟机，这时新的需求产生了： 如何对IT环境中的虚拟机进行统一和高效的管理。 有需求就有供给，云计算登上了历史舞台。</p>
</li>
</ol>
<p>计算（CPU/内存）、存储和网络是 IT 系统的三类资源。 通过云计算平台，这三类资源变成了三个池子 当需要虚机的时候，只需要向平台提供虚机的规格。 平台会快速从三个资源池分配相应的资源，部署出这样一个满足规格的虚机。 虚机的使用者不再需要关心虚机运行在哪里，存储空间从哪里来，IP是如何分配，这些云平台都搞定了。</p>
<p>云平台是一个面向服务的架构，按照提供服务的不同分为 IaaS、PaaS 和 SaaS。 请看下图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqF6TzeFS35dvTgauaRJ6AYOmLnZAQqNfOm6wVVZ8PhDVxK2F0c6G7k91R4JVrT5hDFaCrH8n5OI3Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<ul>
<li><strong>IaaS</strong>（Infrastructure as a Service）提供的服务是虚拟机。 IaaS 负责管理虚机的生命周期，包括创建、修改、备份、启停、销毁等。 使用者从云平台得到的是一个已经安装好镜像（操作系统+其他预装软件）的虚拟机。 使用者需要关心虚机的类型（OS）和配置（CPU、内存、磁盘），并且自己负责部署上层的中间件和应用。 IaaS 的使用者通常是数据中心的系统管理员。 典型的 IaaS 例子有 AWS、Rackspace、阿里云等。</li>
</ul>
<ul>
<li><strong>PaaS</strong>（Platform as a Service）提供的服务是应用的运行环境和一系列中间件服务（比如数据库、消息队列等）。 使用者只需专注应用的开发，并将自己的应用和数据部署到PaaS环境中。 PaaS负责保证这些服务的可用性和性能。 PaaS的使用者通常是应用的开发人员。 典型的 PaaS 有 Heroku、Google App Engine、IBM BlueMix 等。</li>
</ul>
<ul>
<li><strong>SaaS</strong>（Software as a Service）提供的是应用服务。 使用者只需要登录并使用应用，无需关心应用使用什么技术实现，也不需要关系应用部署在哪里。 SaaS的使用者通常是应用的最终用户。 典型的 SaaS 有 Google Gmail、Salesforce 等。</li>
</ul>
<blockquote>
<p>OpenStack is a cloud operating system that controls large pools of compute, storage, and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface.</p>
</blockquote>
<h1 id="OpenStack架构"><a href="#OpenStack架构" class="headerlink" title="OpenStack架构"></a>OpenStack架构</h1><p>OpenStack的核心：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqgAa9OJl30dqPYe5PbT3Ye6MdB4H0HLABVb2eZqkgLibkxNuxR7z4wgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<p>作为 IaaS 层的云操作系统，OpenStack 为虚机提供并管理三大类资源：计算、网络和存储。</p>
<p>这三个就是核心，所以我们的学习重点就是： 搞清楚 OpenStack 是如何对计算、网络和存储资源进行管理的。 在 20+ 模块中，管理这三类资源的核心模块其实不多，这几个模块就是我们的重点了。</p>
<p>要达到这个目的，我们自然需要研究 OpenStack 的整体架构。 架构里哪些核心模块负责管理计算资源、网络资源和存储资源？模块之间如何协调工作？ 同时我们会构建一个实验环境，进到各个模块的内部，通过实际操作真正理解和掌握 OpenStack。</p>
<p>OpenStack的架构：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcq1snxN7gKt4eV1Licgib1xSfEgQxkHykruS96YuiabakkL4gRwRkWrJYgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>中间菱形<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqe6TUoXLp9hkwWI4zDS7Np17dVv5ofHUK9iacibzAx5CuhVIPntEolJjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">是虚拟机，围绕 VM 的那些长方形代表 OpenStack 不同的模块（OpenStack 叫服务，后面都用服务这个术语），下面来分别介绍。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqOde9JicQFubwIP7qpIuCc3IUONoExsWkOzcviaLIPPwYnkm4ibiaenlSKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Nova：管理 VM 的生命周期，是 OpenStack 中最核心的服务。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqH0wYMryzypMrfAsbPicKYibgtgQW9xvZtD6xniaLicEmbKboYpHyicJTBgQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Neutron：为 OpenStack 提供网络连接服务，负责创建和管理L2、L3 网络，为 VM 提供虚拟网络和物理网络连接。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqmbLTpI7E2fnK7Zvdibdt6jR3geZ8099m4cHcVw1gDq9BGCG9U2gIlOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Glance：管理 VM 启动镜像，Nova 创建 VM 时将使用 Glance 提供的镜像。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqRV3kyJ5RosdVianHHP8yQ06elhjJhgnHPmekTOkOjP1wopmUOSdK7Rg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Cinder：为 VM 提供块存储服务。Cinder 提供的每一个 Volume 在 VM 看来就是一块虚拟硬盘，一般用作数据盘。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqbia1SvK6ib6gOPpfeNaj6KEiaaw2Q4IpYTNO02RibQ9aYNhdfAQ0xvrM6g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Swift：提供对象存储服务。VM 可以通过 RESTful API 存放对象数据。作为可选的方案，Glance 可以将镜像存放在 Swift 中；Cinder 也可以将 Volume 备份到 Swift 中。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqFic1hgb6ibhPR4rqdf1vkjye02icyWnC56yyCGtaONI6UACUIib4LHrvjw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Keystone：为 OpenStack 的各种服务提供认证和权限管理服务。简单的说，OpenStack 上的每一个操作都必须通过 Keystone 的审核。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqhHBGEcDMFEraRKSSBJINBIibf1gUy9RAOQfByCz5H3zOI3sKhRbqkWQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Ceilometer：提供 OpenStac k监控和计量服务，为报警、统计或计费提供数据。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqsGyPwjQvONfXEWhbsu1x3EqxYvqYicew2YnRqc3CLArjvlcV7uADwUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> Horizon：为 OpenStack 用户提供一个 Web 的自服务 Portal。</p>
<p>在上面的这些服务中，哪些是 OpenStack 的核心服务呢？ 核心服务就是如果没有它，OpenStack 就跑不起来。 很显然：</p>
<ol>
<li>Nova 管理计算资源，是核心服务。</li>
<li>Neutron 管理网络资源，是核心服务。</li>
<li>Glance 为 VM 提供 OS 镜像，属于存储范畴，是核心服务。</li>
<li>Cinder 提供块存储，VM怎么也得需要数据盘吧，是核心服务。</li>
<li>Swift 提供对象存储，不是必须的，是可选服务。</li>
<li>Keystone 认证服务，没它 OpenStack 转不起来，是核心服务。</li>
<li>Ceilometer 监控服务，不是必须的，可选服务。</li>
<li>Horizon 大家都需要一个操作界面吧。</li>
</ol>
<p>现在核心服务有了，接下来我们将镜头拉近点，看看核心服务内部的组成结构。</p>
<p><strong>Logical Architecture</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcq2Zgu4WuejxFZCJR6zPgspp7ibB81xX7Tic0tfrLpIrcwKLo31KZs8PeA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<p>在 Logical Architecture 中，可以看到每个服务又由若干组件组成。 以 Neutron 为例，包含</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFy6CxsBRVHeE5iatp5e5vcqA1GBGVtuNMU2yn5QshpDjrtMpCg6bxRS0qUyriaTk5wibul6AIRVibHrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<ol>
<li>Neutron Server、Neutron plugins 和 Neutron agents</li>
<li>Network provider</li>
<li>消息队列 Queue</li>
<li>数据库 Neutron Database</li>
</ol>
<p>在后面 Neutron 章节会展开学习这些组件。</p>
<p>这里想要强调一点： 上面是 Logical Architecture，描述的是 Neutron 服务各个组成部分以及各组件之间的逻辑关系。 而在实际的部署方案上，各个组件可以部署到不同的物理节点上。</p>
<p>OpenStack 本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署。 这种分布式特性让 OpenStack 具备极大的灵活性、伸缩性和高可用性。 当然从另一个角度讲，这也使得 OpenStack 比一般系统复杂，学习难度也更大。</p>
<p>![image-20220610142857117](/Users/jiayi/Library/Application Support/typora-user-images/image-20220610142857117.png) </p>
<h1 id="认证Keystone"><a href="#认证Keystone" class="headerlink" title="认证Keystone"></a>认证Keystone</h1><p>作为 OpenStack 的基础支持服务，Keystone 做下面这几件事情：</p>
<ol>
<li>管理用户及其权限</li>
<li>维护 OpenStack Services 的 Endpoint</li>
<li>Authentication（认证）和 Authorization（鉴权）</li>
</ol>
<p>学习 Keystone，得理解下面这些概念：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWa2KibqTdaff9tvEANsMjp0BCynsgfc70Xwsm27t8UadFCZDzfqVFrBRA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>User</strong></p>
<p>User 指代任何使用 OpenStack 的实体，可以是真正的用户，其他系统或者服务。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWawibNBibEX5aYMXl6FvDhyIqhAQibk4BDd3cYYnWhy2LkTNQc5WQVF1JJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当 User 请求访问 OpenStack 时，Keystone 会对其进行验证。Horizon 在 Identity-&gt;Users 管理 User</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWamX925ARyEMyX6RvkBuqsxM7lteia9XY7jPqW5LxCZXF9nzicsicvMFjEw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>除了 admin 和 demo，OpenStack 也为 nova、cinder、glance、neutron 服务创建了相应的 User。 admin 也可以管理这些 User。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWavEdMFN4jPkNTXDK54fAoM4XgI8ZBuItNTjDhuK6Vcr7ibZicZBDE5zOg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Credentials</strong></p>
<p>Credentials 是 User 用来证明自己身份的信息，可以是：</p>
<p>\1. 用户名/密码<br>\2. Token<br>\3. API Key<br>\4. 其他高级方式</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaF68soIpKKAxyicqzUU1liacwNeJ4gibtZph0Agw6cibyCdEhJoEunYib2ng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Authentication</strong></p>
<p>Authentication 是 Keystone 验证 User 身份的过程。User 访问 OpenStack 时向 Keystone 提交用户名和密码形式的 Credentials，Keystone 验证通过后会给 User 签发一个 Token 作为后续访问的 Credential。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaNLPLcmEFEBHH7Yvb3hAqBfoeksoQg8Rhc6umRhJZpFsEkP4ExvbgAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Token</strong></p>
<p>Token 是由数字和字母组成的字符串，User 成功 Authentication 后 Keystone 生成 Token 并分配给 User。</p>
<ol>
<li><p>Token 用做访问 Service 的 Credential</p>
</li>
<li><p>Service 会通过 Keystone 验证 Token 的有效性</p>
</li>
<li><p>Token 的有效期默认是 24 小时</p>
</li>
</ol>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaezgaPs2ygAsU0ibNcRHQqGmVMXlhic1QiclHFCNic9WGeibsdh60q1hfbVg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Project</strong></p>
<p>Project 用于将 OpenStack 的资源（计算、存储和网络）进行分组和隔离。</p>
<p>根据 OpenStack 服务的对象不同，Project 可以是一个客户（公有云，也叫租户）、部门或者项目组（私有云）。</p>
<p>这里请注意：</p>
<ol>
<li>资源的所有权是属于 Project 的，而不是 User。</li>
<li>在 OpenStack 的界面和文档中，Tenant / Project / Account 这几个术语是通用的，但长期看会倾向使用 Project</li>
<li>每个 User（包括 admin）必须挂在 Project 里才能访问该 Project 的资源。 一个User可以属于多个 Project。</li>
<li>admin 相当于 root 用户，具有最高权限</li>
</ol>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaQVuygKUakA7VnrutH5h0OmdUicZ3uUNVSSAtXQeQCH1yibiaQd0SWz1QQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Horizon 在 Identity-&gt;Projects 中管理 Project</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaicNVhtiaHt5Cgg7o2GrrtDVJHQiaGW7iagWCM0OYG1CQ7T17H0XW5YISng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过 Manage Members 将 User 添加到 Project</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWakxB3z8MicuPa8v9vymY5XZDjhZwEPPJsUI3608nMuoGicQjR30qWic3rQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWadKJp3AncCubsUSXTVq5hsKViaErAHeiciaicHjWDyuSfV71ExRnOWia0g1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Service</strong></p>
<p>OpenStack 的 Service 包括 Compute (Nova)、Block Storage (Cinder)、Object Storage (Swift)、Image Service (Glance) 、Networking Service (Neutron) 等。每个 Service 都会提供若干个 Endpoint，User 通过 Endpoint 访问资源和执行操作。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaI7wKjbq1vZCz6VZL9L1PWIHIVHRXHsibK1gMklFg9uibjsJnquWBiaJFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Endpoint</strong></p>
<p>Endpoint 是一个网络上可访问的地址，通常是一个 URL。Service 通过 Endpoint 暴露自己的 API。 Keystone 负责管理和维护每个 Service 的 Endpoint。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaoiabnooGYCurrphFx1H1ibHfVpUTeFY1Jqgh6cxy9xoM1PCz4IWzLAvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以使用下面的命令来查看 Endpoint。</p>
<blockquote>
<p># source devstack/openrc admin admin<br># openstack catalog list</p>
</blockquote>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWa4LOnib0Ev8fXLrGX0vCZJHVrFaLdkib9ibgrvyuKRRbBCsGhiaw4oZIoJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Role</strong></p>
<p>安全包含两部分：Authentication（认证）和 Authorization（鉴权）</p>
<p>Authentication 解决的是“你是谁？”的问题<br>Authorization 解决的是“你能干什么？”的问题</p>
<p>Keystone 借助 Role 实现 Authorization：</p>
<ol>
<li><p>Keystone定义Role<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWa4g1Lo2bT0Qr8icAANReoib7RGstCFT2CBtDeKOIoWRZ4gUO5vOum2w2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>可以为 User 分配一个或多个 Role，Horizon 的菜单为 Identity-&gt;Project-&gt;Manage Members<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaLZFW0PTibkq4N67D3FzvgQZmZTV4UAA19NQejTGvVnHlddpBul6zomw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>Service 决定每个 Role 能做什么事情 Service 通过各自的 policy.json 文件对 Role 进行访问控制。 下面是 Nova 服务 /etc/nova/policy.json 中的示例<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEd6YBwKj2W1WwdwqkscXWaCA7OcpYVDYSurGCPRtibLrq3xjKmSuicibeQicyDFv1svQp4Ycmmwcx2lQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ol>
<p>上面配置的含义是：对于 create、attach_network 和 attach_volume 操作，任何Role的 User 都可以执行； 但只有 admin 这个 Role 的 User 才能执行 forced_host 操作。</p>
<p>以下是Keystone运作的例子：</p>
<p><strong>第 1 步 登录</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxleSFk8sxVTUxuibcQyicibaSCTvbjlb0WxiaMBIR4icdhyic5mJ97oc8Ld6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当点击<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxwjzH7jyFGEYpbaGt3defG7DW9HnuHjhXRUtXw6208wflf6G6S541Vg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">时，OpenStack 内部发生了哪些事情？请看下面</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxbibiaxgJU3lPxbllrLobtc0O1unT1zau0hYJEFqkqpI3r4HU13ibP2x4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Token 中包含了 User 的 Role 信息</p>
<p><strong>第 2 步 显示操作界面</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxSibOG7PwlWGToOrxulMXx6XembGB2uKMlQCYOI3oEx88dakWAibBWmVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>请注意，顶部显示 admin 可访问的  Project 为 “admin” 和 “demo”。 其实在此之前发生了一些事情：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxbm2acjkegnZOcZk1r2e27Y2FyBiauRnNz0icV1TnsughYEflBVIBlKOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>同时，admin 可以访问 Intance, Volume, Image 等服务</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxdLKxHd2bmhsAl23Yv9T6icoT9qRmRom8kOPUrsw669CU49E2N0FgG4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是因为 admin 已经从 Keystone 拿到了各 Service 的 Endpoints</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxNjSVFicMrzicW9vT7hG6WZ81ohZxNFrS3OqNDwbVtP4Nd5CvRhTHzS8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>第 3 步 显示 image 列表</strong></p>
<p>点击 “Images”，会显示 image 列表</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSx9fNGZKjvHqCichIXPN0B1hTZd4rmPsCqPTGNQ0ueOmcA1ic35669Wsrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>背后发生了这些事：</p>
<p>首先 admin 将请求发送到 Glance 的 Endpoint</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxAtRkENfMOcEccZuKVEM9x5zZ8Zu9jvWeGJcBicPVNSQTOBmRFRHS5Ng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Glance 向 Keystone 询问 admin 身份是否有效</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxnVgRLtf0KjqeWQ1BeOR00kddTNgHJTYPFrbAqyxmiapHFotz4qr5Fdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>接下来 Glance 会查看 /etc/glance/policy.json 判断 admin 是否有查看 image 的权限</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHWhcQFiaKFEmUJcBtQ58fSxDwkYzcnY04u4XQ7XPvAbXxc2sHjpjsEOlPS0oSic7MIXwdCmQjoIsLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>权限判定通过，Glance 将 image 列表发给 admin。</p>
<h1 id="镜像Glance"><a href="#镜像Glance" class="headerlink" title="镜像Glance"></a>镜像Glance</h1><p>OpenStack 由 Glance 提供 Image 服务。</p>
<blockquote>
<p> <strong>理解 Image</strong></p>
</blockquote>
<p>要理解 Image Service，先得搞清楚什么是 Image 以及为什么要用 Image？</p>
<p>在传统 IT 环境下，安装一个系统要么从安装 CD 从头安装，要么用 Ghost 等克隆工具恢复。这两种方式有如下几个问题：</p>
<ol>
<li>如果要安装的系统多了效率就很低</li>
<li>时间长，工作量大</li>
<li>安装完还要进行手工配置，比如安装其他的软件，设置 IP 等</li>
<li>备份和恢复系统不灵活</li>
</ol>
<p>云环境下需要更高效的方案，这就是 Image。 Image 是一个模板，里面包含了基本的操作系统和其他的软件。</p>
<p>举例来说，有家公司需要为每位员工配置一套办公用的系统，一般需要一个 Win7 系统再加 MS office 软件。 OpenStack 是这么玩的：</p>
<ol>
<li><p>先手工安装好这么一个虚机</p>
</li>
<li><p>然后对虚机执行 snapshot，这样就得到了一个 image</p>
</li>
<li><p>当有新员工入职需要办公环境时，立马启动一个或多个该 image 的 instance（虚机）就可以了</p>
</li>
</ol>
<p>在这个过程中，第 1 步跟传统方式类似，需要手工操作和一定时间，但第 2、3 步非常快，全自动化，一般都是秒级别。而且 2、3 步可以循环做。 比如公司新上了一套 OA 系统，每个员工的 PC 上都得有客户端软件。 那么可以在某个现有虚机中先手工安装好 OA 客户端，然后执行 snapshot 操作，得到新的 image，以后可以就直接使用新 image 创建虚机了。另外，snapshot 还有备份的作用，能够非常方便的恢复系统。</p>
<blockquote>
<p><strong>理解Image Service</strong></p>
</blockquote>
<p>Image Service 的功能是管理 Image，让用户能够发现、获取和保存 Image。在 OpenStack 中，提供 Image Service 的是 Glance，其具体功能如下：</p>
<ol>
<li>提供 REST API 让用户能够查询和获取 image 的元数据和 image 本身</li>
<li>支持多种方式存储 image，包括普通的文件系统、Swift、Amazon S3 等</li>
<li>对 Instance 执行 Snapshot 创建新的 image</li>
</ol>
<h3 id="Glance架构"><a href="#Glance架构" class="headerlink" title="Glance架构"></a><strong>Glance架构</strong></h3><p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNTNNp6sY0DicaymCAuHMsAjvUrxuB9DdYiaFAPuVIHKYDxibUrXabCzUjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">  </p>
<p>上面是 Glance 的架构图</p>
<h4 id="glance-api"><a href="#glance-api" class="headerlink" title="glance-api"></a><strong>glance-api</strong></h4><p>glance-api 是系统后台运行的服务进程。 对外提供 REST API，响应 image 查询、获取和存储的调用。</p>
<p>glance-api 不会真正处理请求。 如果操作是与 image metadata（元数据）相关，glance-api 会把请求转发给 glance-registry； 如果操作是与 image 自身存取相关，glance-api 会把请求转发给该 image 的 store backend。</p>
<p>在控制节点上可以查看 glance-api 进程</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNytPPuKCkITlL30ac6LlgFGJMoqRCOEfdBCqbB5ffj6sFwWRibXXc4Rg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="glance-registry"><a href="#glance-registry" class="headerlink" title="glance-registry"></a><strong>glance-registry</strong></h4><p>glance-registry 是系统后台运行的服务进程。 负责处理和存取 image 的 metadata，例如 image 的大小和类型。在控制节点上可以查看 glance-registry 进程</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNkRicyFx3ALNxOKlicibuwxR01XWbJicajicF1yAAnCKVDIQMx4XrOuZACFA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Glance 支持多种格式的 image，包括</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNykY5eXxtnQiaUnHhMR7x2sAQ3sNd9VgptlVjMZib6GOZPkw21fnUuZOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a><strong>Database</strong></h4><p>Image 的 metadata 会保持到 database 中，默认是 MySQL。 在控制节点上可以查看 glance 的 database 信息</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNB38ZPb2w8xMVUs8XZZZ3aJ4TpIy7PTsv68Sg1WhhXQPeZJStAciaNKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="Store-backend"><a href="#Store-backend" class="headerlink" title="Store backend"></a><strong>Store backend</strong></h4><p>Glance 自己并不存储 image。 真正的 image 是存放在 backend 中的。 Glance 支持多种 backend，包括：</p>
<ol>
<li>A directory on a local file system（这是默认配置）</li>
<li>GridFS</li>
<li>Ceph RBD</li>
<li>Amazon S3</li>
<li>Sheepdog</li>
<li>OpenStack Block Storage (Cinder)</li>
<li>OpenStack Object Storage (Swift)</li>
<li>VMware ESX</li>
</ol>
<p>具体使用哪种 backend，是在 /etc/glance/glance-api.conf 中配置的<br>在我们的 devstack 环境中，image 存放在控制节点本地目录 /opt/stack/data/glance/images/ 中</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNiaU5wkNHXPNHlLNzLAyz8VricN8XxG7B6n0T8UupITiboz0oAWpeFJhaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其他 backend 的配置可参考<a target="_blank" rel="noopener" href="http://docs.openstack.org/liberty/config-reference/content/configuring-image-service-backends.html">http://docs.openstack.org/liberty/config-reference/content/configuring-image-service-backends.html</a></p>
<p>查看目前已经存在的 image</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPNYywoRibibobzDHUkibR1y1wexueDmQnDcelsa2jgv0Nnyt812kuVCFM5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>查看保存目录</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGf6K2mibNIzz9NGgW1sAfPN51bK22FuiaUicc4ES3WneFxvIfkj69rtCKtSzzvWDqlur3yL1QQsFiaFg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>每个 image 在目录下都对应有一个文件，文件以 image 的 ID 命名。</p>
<h3 id="CLI-创建-image"><a href="#CLI-创建-image" class="headerlink" title="CLI 创建 image"></a>CLI 创建 image</h3><p>cirros 这个 linux 镜像很小，通过 Web UI 上传很快，操作会很顺畅。但如果我们要上传的镜像比较大（比如好几个 G ），那么操作会长时间停留在上传的 Web 界面，我们也不知道目前到底处于什么状态。 对于这样的操作，CLI 是更好的选择。</p>
<ol>
<li><p>将 image 上传到控制节点的文件系统中，例如 /tmp/cirros-0.3.4-x86_64-disk.img</p>
</li>
<li><p>设置环境变量<br><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFw4ICM9axnNmF0hriaVdzGFkw04rhxv4kibV9jcBbhxOayLOVeNudtblkrJMG8sZuDXEibDS1JkqLzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>Devstack 的安装目录下有个 openrc 文件。source 该文件就可以配置 CLI 的环境变量。这里我们传入了两个参数，第一个参数是 OpenStack 用户名 admin；第二个参数是 Project 名 admin</p>
</li>
<li><p>执行 image 创建命令</p>
</li>
</ol>
<blockquote>
<p>glance image-create –name cirros –file /tmp/cirros-0.3.4-x86_64-disk.img –disk-format qcow2 –container-format bare –progress</p>
</blockquote>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFw4ICM9axnNmF0hriaVdzGF77o6825q5KpNs4oLOWecxXOYCgAT23sxJ8TSgwKKyMsskibAmhxeibtA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在创建 image 的 CLI 参数中我们用 –progress 让其显示文件上传的百分比 %，是不是比 Web UI更直观呢？</p>
<p>在 /opt/stack/data/glance/images/ 下查看新的 Image<br><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFw4ICM9axnNmF0hriaVdzGFSCgUvvRBK3EuJuoOFNbYavs1Jppa12wdtel2mblzHH4tgt682kqp4g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="计算Nova"><a href="#计算Nova" class="headerlink" title="计算Nova"></a>计算Nova</h1><p>Compute Service Nova 是 OpenStack 最核心的服务，负责维护和管理云环境的计算资源。OpenStack 作为 IaaS 的云操作系统，虚拟机生命周期管理也就是通过 Nova 来实现的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5FlecmqKgwxsIhShOn3DcoSGyyCKDnQINagzSrmpUHdBNDz5pROg4b8t2c9Bw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>在上图中可以看到，Nova 处于 Openstak 架构的中心，其他组件都为 Nova 提供支持： Glance 为 VM 提供 image ；Cinder 和 Swift 分别为 VM 提供块存储和对象存储； Neutron 为 VM 提供网络连接。Nova 架构如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5FlecmqHNp317xLg3wSRZdbM0zMbKzXmplOrWpVEvqNZvCm37LmcbbCPdLMFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>Nova 的架构比较复杂，包含很多组件。 这些组件以子服务（后台 deamon 进程）的形式运行，可以分为以下几类：</p>
<ol>
<li><strong>API</strong></li>
</ol>
<p><strong>nova-api</strong></p>
<p>接收和响应客户的 API 调用。 除了提供 OpenStack 自己的API，nova-api 还支持 Amazon EC2 API。 也就是说，如果客户以前使用 Amazon EC2，并且用 EC2 的 API 开发了些工具来管理虚机，那么如果现在要换成 OpenStack，这些工具可以无缝迁移到 OpenStack，因为 nova-api 兼容 EC2 API，无需做任何修改。</p>
<ol start="2">
<li><strong>Compute Core</strong></li>
</ol>
<p>**nova-scheduler<br>**</p>
<p>虚机调度服务，负责决定在哪个计算节点上运行虚机</p>
<p>**nova-compute<br>**</p>
<p>管理虚机的核心服务，通过调用 Hypervisor API 实现虚机生命周期管理</p>
<p><strong>Hypervisor</strong><br>计算节点上跑的虚拟化管理程序，虚机管理最底层的程序。 不同虚拟化技术提供自己的 Hypervisor。 常用的 Hypervisor 有 KVM，Xen， VMWare 等</p>
<p>**nova-conductor<br>**nova-compute 经常需要更新数据库，比如更新虚机的状态。 出于安全性和伸缩性的考虑，nova-compute 并不会直接访问数据库，而是将这个任务委托给 nova-conductor，这个我们后面详细讨论。</p>
<ol start="3">
<li><strong>Console Interface</strong></li>
</ol>
<p>**nova-console<br>**用户可以通过多种方式访问虚机的控制台：<br>nova-novncproxy，基于 Web 浏览器的 VNC 访问<br>nova-spicehtml5proxy，基于 HTML5 浏览器的 SPICE 访问<br>nova-xvpnvncproxy，基于 Java 客户端的 VNC 访问</p>
<p>**nova-consoleauth<br>**负责对访问虚机控制台请求提供 Token 认证</p>
<p>**nova-cert<br>**</p>
<p>提供 x509 证书支持</p>
<p><strong>Database</strong></p>
<p>Nova 会有一些数据需要存放到数据库中，一般使用 MySQL。数据库安装在控制节点上。 Nova 使用命名为 “nova” 的数据库。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5FlecmqXXgZK8iasQUn19266AU5OjrBEBia04XWiayibdSEt9HuyicicfWSMmiaphaVA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol start="4">
<li><strong>Message Queue</strong></li>
</ol>
<p>在前面我们了解到 Nova 包含众多的子服务，这些子服务之间需要相互协调和通信。为解耦各个子服务，Nova 通过 Message Queue 作为子服务的信息中转站。 所以在架构图上我们看到了子服务之间没有直接的连线，是通过 Message Queue 联系的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGJPebq3Rz7Ng3ibj5Flecmq1MnOd7sk1MQ9qaqGnblVDIO3AWldVC272H8moOq1jWOrXc9vKNEtLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>OpenStack 默认是用 RabbitMQ 作为 Message Queue。 MQ 是 OpenStack 的核心基础组件，我们后面也会详细介绍。</p>
<h3 id="Nova物理部署方案"><a href="#Nova物理部署方案" class="headerlink" title="Nova物理部署方案"></a>Nova物理部署方案</h3><p>前面大家已经看到 Nova 由很多子服务组成，我们也知道 OpenStack 是一个分布式系统，可以部署到若干节点上，那么接下来大家可能就会问：Nova 的这些服务在物理上应该如何部署呢？</p>
<p>对于 Nova，这些服务会部署在两类节点上：计算节点和控制节点。</p>
<p>计算节点上安装了 Hypervisor，上面运行虚拟机。 由此可知：</p>
<ol>
<li>只有 nova-compute 需要放在计算节点上。</li>
<li>其他子服务则是放在控制节点上的。</li>
</ol>
<p>下面我们可以看看实验环境的具体部署情况。 通过在计算节点和控制节点上运行 ps -elf|grep nova 来查看运行的 nova 子服务</p>
<p><strong>计算节点</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4T4YbLP6QicpCdZVb7E9rMQV42cQM5icDonQ52Ria5Wc9Pla3YBWqHdqeDg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>计算节点 devstack-compute1 上只运行了 nova-compute 子服务</p>
<p><strong>控制节点</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TGzZZyOaLQ0rKQ4z32uSOoZal6VPLVKMVAdhSS2hAurER56ctOjT30A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>控制节点 devstack-controller 上运行了若干 nova-* 子服务</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TDwBbic4NWnDw7lWXWuAsH5ibS5JP9dWR7q0oaVxCzKM1yD0IXNmJOicWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RabbitMQ 和 MySQL 也是放在控制节点上的。可能细心的同学已经发现我们的控制节点上也运行了 nova-compute。 这实际上也就意味着 devstack-controller 既是一个控制节点，同时也是一个计算节点，也可以在上面运行虚机。</p>
<p>这也向我们展示了 OpenStack 这种分布式架构部署上的灵活性： 可以将所有服务都放在一台物理机上，作为一个 All-in-One 的测试环境； 也可以将服务部署在多台物理机上，获得更好的性能和高可用。</p>
<p>另外，也可以用 nova service-list 查看 nova-* 子服务都分布在哪些节点上</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TnljsTN8FSxnMLQkHNM7azuDgZZQLoIGgSy4D8HxlLlCjKQuib7BBsiaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="从虚拟机创建流程看-nova-子服务如何协同工作"><a href="#从虚拟机创建流程看-nova-子服务如何协同工作" class="headerlink" title="从虚拟机创建流程看 nova-* 子服务如何协同工作"></a>从虚拟机创建流程看 nova-* 子服务如何协同工作</h3><p>从学习 Nova 的角度看，虚机创建是一个非常好的场景，涉及的 nova-* 子服务很全，下面是流程图。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFibI6JwibQfktJ1WaTjzzf4TRWKlXWqV4VregAMebcImDmjicJBaMskoSOz7Qxvn0tQUGpovezyusibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol>
<li><p>客户（可以是 OpenStack 最终用户，也可以是其他程序）向 API（nova-api）发送请求：“帮我创建一个虚机”</p>
</li>
<li><p>API 对请求做一些必要处理后，向 Messaging（RabbitMQ）发送了一条消息：“让 Scheduler 创建一个虚机”</p>
</li>
<li><p>Scheduler（nova-scheduler）从 Messaging 获取到 API 发给它的消息，然后执行调度算法，从若干计算节点中选出节点 A</p>
</li>
<li><p>Scheduler 向 Messaging 发送了一条消息：“在计算节点 A 上创建这个虚机”</p>
</li>
<li><p>计算节点 A 的 Compute（nova-compute）从 Messaging 中获取到 Scheduler 发给它的消息，然后在本节点的 Hypervisor 上启动虚机。</p>
</li>
<li><p>在虚机创建的过程中，Compute 如果需要查询或更新数据库信息，会通过 Messaging 向 Conductor（nova-conductor）发送消息，Conductor 负责数据库访问。</p>
</li>
</ol>
<p>以上是创建虚机最核心的步骤，当然省略了很多细节，我们会在后面的章节详细讨论。 这几个步骤向我们展示了 nova-* 子服务之间的协作的方式，也体现了 OpenStack 整个系统的分布式设计思想，掌握这种思想对我们深入理解 OpenStack 会非常有帮助。</p>
<h3 id="OpenStack通用设计思路"><a href="#OpenStack通用设计思路" class="headerlink" title="OpenStack通用设计思路"></a>OpenStack通用设计思路</h3><p><strong>API 前端服务</strong></p>
<p>每个 OpenStack 组件可能包含若干子服务，其中必定有一个 API 服务负责接收客户请求。</p>
<p>以 Nova 为例，nova-api 作为 Nova 组件对外的唯一窗口，向客户暴露 Nova 能够提供的功能。 当客户需要执行虚机相关的操作，能且只能向 nova-api 发送 REST 请求。 这里的客户包括终端用户、命令行和 OpenStack 其他组件。</p>
<p>设计 API 前端服务的好处在于：</p>
<ol>
<li>对外提供统一接口，隐藏实现细节</li>
<li>API 提供 REST 标准调用服务，便于与第三方系统集成</li>
<li>可以通过运行多个 API 服务实例轻松实现 API 的高可用，比如运行多个 nova-api 进程</li>
</ol>
<p><strong>Scheduler 调度服务</strong></p>
<p>对于某项操作，如果有多个实体都能够完成任务，那么通常会有一个 scheduler 负责从这些实体中挑选出一个最合适的来执行操作。</p>
<p>在前面的例子中，Nova 有多个计算节点。 当需要创建虚机时，nova-scheduler 会根据计算节点当时的资源使用情况选择一个最合适的计算节点来运行虚机。</p>
<p>调度服务好比是开发团队中的项目经理，当接到新的开发任务后，项目经理会评估任务的难度，考察团队成员目前的工作负荷和技能水平，然后将任务分配给最合适的开发人员。除了 Nova，块服务组件 Cinder 也有 scheduler 子服务，后面我们会详细讨论。</p>
<p><strong>Worker 工作服务</strong></p>
<p>调度服务只管分配任务，真正执行任务的是 Worker 工作服务。在 Nova 中，这个 Worker 就是 nova-compute 了。 将 Scheduler 和 Worker 从职能上进行划分使得 OpenStack 非常容易扩展：</p>
<ol>
<li><p>当计算资源不够了无法创建虚机时，可以增加计算节点（增加 Worker）</p>
</li>
<li><p>当客户的请求量太大调度不过来时，可以增加 Scheduler</p>
</li>
</ol>
<p><strong>Driver 框架</strong></p>
<p>OpenStack 作为开放的 Infrastracture as a Service 云操作系统，支持业界各种优秀的技术。这些技术可能是开源免费的，也可能是商业收费的。 这种开放的架构使得 OpenStack 能够在技术上保持先进性，具有很强的竞争力，同时又不会造成厂商锁定（Lock-in）。</p>
<p>那 OpenStack 的这种开放性体现在哪里呢？</p>
<p>一个重要的方面就是采用基于 Driver 的框架。以 Nova 为例，OpenStack 的计算节点支持多种 Hypervisor。 包括 KVM, Hyper-V, VMWare, Xen, Docker, LXC 等。Nova-compute 为这些 Hypervisor 定义了统一的接口，hypervisor 只需要实现这些接口，就可以 driver 的形式即插即用到 OpenStack 中。 下面是 nova driver 的架构示意图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXweGlUiaBQz6jNXOAe1QnB3V4OGqsVQkPDUJQHicvTlx1lMNNeMxXWuasQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 nova-compute 的配置文件 /etc/nova/nova.conf 中由 compute_driver 配置项指定该计算节点使用哪种 Hypervisor 的 driver</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXwY03evSaDhos36slFHU9jNC3ibs5jhgF8PKcCpvC3juHeqhyh29Wiaoibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">   </p>
<p>在我们的环境中因为是 KVM，所以配置的是 Libvirt 的 driver。</p>
<p>不知大家是否记得我们在学习 Glance 时谈到： OpenStack 支持多种 backend 来存放 image。 可以是本地文件系统，Cinder，Ceph，Swift 等。其实这也是一个 driver 架构。 只要符合 Glance 定义的规范，新的存储方式可以很方便的加入到 backend 支持列表中。在后面 Cinder 和 Neutron 中我们还会看到 driver 框架的应用。</p>
<p><strong>Messaging 服务</strong></p>
<p>在前面创建虚机的流程示意图中，我们看到 nova-* 子服务之间的调用严重依赖 Messaging。Messaging 是 nova-* 子服务交互的中枢。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXwZ1HkUPq0ctJUDhLOG6jibliaH2xXFdmdPUpFrE8PFjgzsfmFA9t7ECJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>以前没接触过分布式系统的同学可能会不太理解为什么不让 API 直接调用Scheduler，或是让Scheuler 直接调用 Compute，而是非要通过 Messaging 进行中转。 这里做一些解释。程序之间的调用通常分两种：同步调用和异步调用。</p>
<p><strong>同步调用</strong></p>
<p>API 直接调用 Scheduler 的接口是同步调用。 其特点是 API 发出请求后需要一直等待，直到 Scheduler 完成对 Compute 的调度，将结果返回给 API 后 API 才能够继续做后面的工作。</p>
<p><strong>异步调用</strong></p>
<p>API 通过 Messaging 间接调用 Scheduler 就是异步调用。 其特点是 API 发出请求后不需要等待，直接返回，继续做后面的工作。 Scheduler 从 Messaging 接收到请求后执行调度操作，完成后将结果也通过 Messaging 发送给 API。在 OpenStack 这类分布式系统中，通常采用异步调用的方式，其好处是：</p>
<ol>
<li><p>解耦各子服务。 子服务不需要知道其他服务在哪里运行，只需要发送消息给 Messaging 就能完成调用。</p>
</li>
<li><p>提高性能 异步调用使得调用者无需等待结果返回。这样可以继续执行更多的工作，提高系统总的吞吐量。</p>
</li>
<li><p>提高伸缩性 子服务可以根据需要进行扩展，启动更多的实例处理更多的请求，在提高可用性的同时也提高了整个系统的伸缩性。而且这种变化不会影响到其他子服务，也就是说变化对别人是透明的。</p>
</li>
</ol>
<p>在后面各章节，我们都能看到 Messaging 的应用。</p>
<p><strong>Database</strong></p>
<p>OpenStack 各组件需要维护自己的状态信息。比如 Nova 中有虚机的规格、状态，这些信息都是在数据库中维护的。 每个 OpenStack 组件在 MySQL 中有自己的数据库。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFp0CQbZfhvePDaiaLHApfXwxQp6seHuX8ibGeqqCnu0EKCqiacKNvmlJ149MrdbdPOe1GmwEC3yEQPQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p><strong>小结</strong></p>
<p>Nova 是 OpenStack 中最重要的组件，也是很典型的组件。Nova 充分体现了 OpenStack 的设计思路。 理解了这种思路，再来学习 OpenStack 的其他组件就能够举一反三，清晰容易很多。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UxQAxoSIhr3SOv0ISGTtYw">https://mp.weixin.qq.com/s/UxQAxoSIhr3SOv0ISGTtYw</a></p>
<p>我们在后面 Cinder 和 Neutron 的学习中还会回顾这些设计思路。</p>
<h1 id="存储Cinder"><a href="#存储Cinder" class="headerlink" title="存储Cinder"></a>存储Cinder</h1><h3 id="Cinder框架"><a href="#Cinder框架" class="headerlink" title="Cinder框架"></a>Cinder框架</h3><p>从本节开始我们学习 OpenStack 的 Block Storage Service，Cinder。</p>
<p><strong>理解 Block Storage</strong></p>
<p>操作系统获得存储空间的方式一般有两种：</p>
<ol>
<li><p>通过某种协议（SAS,SCSI,SAN,iSCSI 等）挂接裸硬盘，然后分区、格式化、创建文件系统；或者直接使用裸硬盘存储数据（数据库）</p>
</li>
<li><p>通过 NFS、CIFS 等 协议，mount 远程的文件系统</p>
</li>
</ol>
<p>第一种裸硬盘的方式叫做 Block Storage（块存储），每个裸硬盘通常也称作 Volume（卷） 第二种叫做文件系统存储。NAS 和 NFS 服务器，以及各种分布式文件系统提供的都是这种存储。</p>
<p><strong>理解 Block Storage Service</strong></p>
<p>Block Storage Servicet 提供对 volume 从创建到删除整个生命周期的管理。从 instance 的角度看，挂载的每一个 Volume 都是一块硬盘。OpenStack 提供 Block Storage Service 的是 Cinder，其具体功能是：</p>
<ol>
<li><p>提供 REST API 使用户能够查询和管理 volume、volume snapshot 以及 volume type</p>
</li>
<li><p>提供 scheduler 调度 volume 创建请求，合理优化存储资源的分配</p>
</li>
<li><p>通过 driver 架构支持多种 back-end（后端）存储方式，包括 LVM，NFS，Ceph 和其他诸如 EMC、IBM 等商业存储产品和方案</p>
</li>
</ol>
<p><strong>Cinder 架构</strong></p>
<p>下图是 cinder 的逻辑架构图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CokOFtGNmp736wqAWfJwx8AnC714u6LtvHucmGWDZgNmFwe4G8G1Mww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>Cinder 包含如下几个组件：</p>
<p>**cinder-api<br>**接收 API 请求，调用 cinder-volume 。</p>
<p>**cinder-volume<br>**管理 volume 的服务，与 volume provider 协调工作，管理 volume 的生命周期。运行 cinder-volume 服务的节点被称作为存储节点。</p>
<p>**cinder-scheduler<br>**scheduler 通过调度算法选择最合适的存储节点创建 volume。</p>
<p>**volume provider<br>**数据的存储设备，为 volume 提供物理存储空间。 cinder-volume 支持多种 volume provider，每种 volume provider 通过自己的 driver 与cinder-volume 协调工作。</p>
<p>**Message Queue<br>**Cinder 各个子服务通过消息队列实现进程间通信和相互协作。因为有了消息队列，子服务之间实现了解耦，这种松散的结构也是分布式系统的重要特征。</p>
<p><strong>Database Cinder</strong> </p>
<p>有一些数据需要存放到数据库中，一般使用 MySQL。数据库是安装在控制节点上的，比如在我们的实验环境中，可以访问名称为“cinder”的数据库。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CxMKsjeAZqnGWvOs48icEiam9KM9ISoHT9uTOFeLPkFKsZY9wErc96JCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p><strong>物理部署方案</strong></p>
<p>Cinder 的服务会部署在两类节点上，控制节点和存储节点。我们来看看控制节点 devstack-controller 上都运行了哪些 cinder-* 子服务。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7Cu6zMeoesOEYtxhAWLeNicpqd2C8KYqnrtpv7aCz8P0M6MtichO7n7Txg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>cinder-api 和 cinder-scheduler 部署在控制节点上，这个很合理。</p>
<p>至于 cinder-volume 也在控制节点上可能有些同学就会迷糊了：cinder-volume 不是应该部署在存储节点上吗？</p>
<p>要回答这个问题，首先要搞清楚一个事实： OpenStack 是分布式系统，其每个子服务都可以部署在任何地方，只要网络能够连通。无论是哪个节点，只要上面运行了 cinder-volume，它就是一个存储节点，当然，该节点上也可以运行其他 OpenStack服务。</p>
<p>cinder-volume 是一顶存储节点帽子，cinder-api 是一顶控制节点帽子。在我们的环境中，devstack-controller 同时戴上了这两顶帽子，所以它既是控制节点，又是存储节点。当然，我们也可以用一个专门的节点来运行 cinder-volume。</p>
<p>这再一次展示了 OpenStack 分布式架构部署上的灵活性： 可以将所有服务都放在一台物理机上，用作一个 All-in-One 的测试环境；而在生产环境中可以将服务部署在多台物理机上，获得更好的性能和高可用。</p>
<p>RabbitMQ 和 MySQL 通常放在控制节点上。另外，也可以用 cinder service list 查看 cinder-* 子服务都分布在哪些节点上</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CtOib4cKjOdhrG6PZdicOGic55SywOK57tWwpBB3dVEcmS0L6neVIpKsicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>还有一个问题：volume provider 放在那里？</p>
<p>一般来讲，volume provider 是独立的。cinder-volume 使用 driver 与 volume provider 通信并协调工作。所以只需要将 driver 与 cinder-volume 放到一起就可以了。在 cinder-volume 的源代码目录下有很多 driver，支持不同的 volume provider。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqHLd9PmsqE1ZNftI1TE2l7CLK2oSbyLhJKjzJwxibb4MCicP4tQZzcn7rNKzMK3Z6lLtlFWSSYQTWjg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>后面我们会以 LVM 和 NFS 这两种 volume provider 为例讨论 cinder-volume 的使用，其他 volume provider 可以查看 OpenStack 的 configuration 文档。</p>
<p>下一节我们将讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587767&idx=1&sn=e3535a2ccf793e5591d633cbd9d5879c&chksm=8d30812eba470838464262dc60bed1b50c4ad63342a7dae3a7b1af08ab4effcd463efbbe7209&scene=21#wechat_redirect">Cinder 的这些组件如何协调工作</a>。</p>
<h3 id="Cinder-设计思想"><a href="#Cinder-设计思想" class="headerlink" title="Cinder 设计思想"></a>Cinder 设计思想</h3><p>上一节介绍了<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587138&idx=1&sn=eedfae7ccae28a5081342b29035cb578&scene=21#wechat_redirect"> Cinder 的架构</a>，这节讨论 Cinder 个组件如何协同工作及其设计思想。</p>
<p><strong>从 volume 创建流程看 cinder-* 子服务如何协同工作</strong></p>
<p>对于 Cinder 学习来说，Volume 创建是一个非常好的场景，涉及各个 cinder-* 子服务，下面是流程图。<img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFDVXiaL6zITRP8Ol2r6gWEVQp6lA7mLyiaWPV9ORJicCAQOQcrNXvV1rWF5MbjkcgyrUO15eG7fxxKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ol>
<li><p>客户（可以是 OpenStack 最终用户，也可以是其他程序）向 API（cinder-api）发送请求：“帮我创建一个 volume”</p>
</li>
<li><p>API 对请求做一些必要处理后，向 Messaging（RabbitMQ）发送了一条消息：“让 Scheduler 创建一个 volume”</p>
</li>
<li><p>Scheduler（cinder-scheduler）从 Messaging 获取到 API 发给它的消息，然后执行调度算法，从若干计存储点中选出节点 A</p>
</li>
<li><p>Scheduler 向 Messaging 发送了一条消息：“让存储节点 A 创建这个 volume”</p>
</li>
<li><p>存储节点 A 的 Volume（cinder-volume）从 Messaging 中获取到 Scheduler 发给它的消息，然后通过 driver 在 volume provider 上创建 volume。</p>
</li>
</ol>
<p>上面是创建虚机最核心的几个步骤，当然省略了很多细节，我们会在后面的章节详细讨论。</p>
<p><strong>Cinder 的设计思想</strong></p>
<p>Cinder 延续了 Nova 的以及其他组件的设计思想。</p>
<p><strong>API 前端服</strong>务</p>
<p>cinder-api 作为 Cinder 组件对外的唯一窗口，向客户暴露 Cinder 能够提供的功能，当客户需要执行 volume 相关的操作，能且只能向 cinder-api 发送 REST 请求。这里的客户包括终端用户、命令行和 OpenStack 其他组件。</p>
<p>设计 API 前端服务的好处在于：</p>
<ol>
<li>对外提供统一接口，隐藏实现细节</li>
<li>API 提供 REST 标准调用服务，便于与第三方系统集成</li>
<li>可以通过运行多个 API 服务实例轻松实现 API 的高可用，比如运行多个 cinder-api 进程</li>
</ol>
<p><strong>Scheduler 调度服务</strong></p>
<p>Cinder 可以有多个存储节点，当需要创建 volume 时，cinder-scheduler 会根据存储节点的属性和资源使用情况选择一个最合适的节点来创建 volume。</p>
<p>调度服务就好比是一个开发团队中的项目经理，当接到新的开发任务时，项目经理会根据任务的难度，每个团队成员目前的工作负荷和技能水平，将任务分配给最合适的开发人员。</p>
<p><strong>Worker 工作服务</strong></p>
<p>调度服务只管分配任务，真正执行任务的是 Worker 工作服务。</p>
<p>在 Cinder 中，这个 Worker 就是 cinder-volume 了。这种 Scheduler 和 Worker 之间职能上的划分使得 OpenStack 非常容易扩展：当存储资源不够时可以增加存储节点（增加 Worker）。 当客户的请求量太大调度不过来时，可以增加 Scheduler。</p>
<p><strong>Driver 框架</strong></p>
<p>OpenStack 作为开放的 Infrastracture as a Service 云操作系统，支持业界各种优秀的技术，这些技术可能是开源免费的，也可能是商业收费的。</p>
<p>这种开放的架构使得 OpenStack 保持技术上的先进性，具有很强的竞争力，同时又不会造成厂商锁定（Lock-in）。 那 OpenStack 的这种开放性体现在哪里呢？一个重要的方面就是采用基于 Driver 的框架。</p>
<p>以 Cinder 为例，存储节点支持多种 volume provider，包括 LVM, NFS, Ceph, GlusterFS，以及 EMC, IBM 等商业存储系统。 cinder-volume 为这些 volume provider 定义了统一的 driver 接口，volume provider 只需要实现这些接口，就可以 driver 的形式即插即用到 OpenStack 中。下面是 cinder driver 的架构示意图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFDVXiaL6zITRP8Ol2r6gWEVO8ia9mZVXLQvqohgOhQZgb2eZLIOMrgmibzAlR8PPfxmAl9w8DAj813Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 cinder-volume 的配置文件 /etc/cinder/cinder.conf 中 volume_driver 配置项设置该存储节点使用哪种 volume provider 的 driver，下面的示例表示使用的是 LVM。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFDVXiaL6zITRP8Ol2r6gWEVvA8S0REdgtpFn7eH9QmZuAHjX8ibYDmgzicY4OuAIdXTVJGvc1Zaw2Mg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>下一节我们将详细讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587763&idx=1&sn=1374e3e2bcc453b782f0eb8a78f46ad6&chksm=8d30812aba47083cbe1f0aa93b3eff408590397eb2c88fe040eafd15b04888d0d1d116405d18&scene=21#wechat_redirect">Cinder 的每一个组件</a>。</p>
<h3 id="Cinder-的组件"><a href="#Cinder-的组件" class="headerlink" title="Cinder 的组件"></a>Cinder 的组件</h3><p>从本节开始，我们将详细讲解 Cinder 的各个子服务。</p>
<h4 id="cinder-api"><a href="#cinder-api" class="headerlink" title="cinder-api"></a>cinder-api</h4><p><strong>cinder-api</strong></p>
<p>cinder-api 是整个 Cinder 组件的门户，所有 cinder 的请求都首先由 cinder-api 处理。cinder-api 向外界暴露若干 HTTP REST API 接口。在 keystone 中我们可以查询 cinder-api 的 endponits。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWNgTGP6APlAdTUic8iaUfJicUTmC2wxlgbI4U5YE0oeqlGn5HWRgo2k9Mw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>客户端可以将请求发送到 endponits 指定的地址，向 cinder-api 请求操作。 当然，作为最终用户的我们不会直接发送 Rest API 请求。OpenStack CLI，Dashboard 和其他需要跟 Cinder 交换的组件会使用这些 API。</p>
<p>cinder-api 对接收到的 HTTP API 请求会做如下处理：</p>
<ol>
<li>检查客户端传人的参数是否合法有效</li>
<li>调用 cinder 其他子服务的处理客户端请求</li>
<li>将 cinder 其他子服务返回的结果序列号并返回给客户端</li>
</ol>
<p>cinder-api 接受哪些请求呢？简单的说，只要是 Volume 生命周期相关的操作，cinder-api 都可以响应。大部分操作都可以在 Dashboard 上看到。</p>
<p>打开 Volume 管理界面</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWcA3ibeM5ibYRUtyDHUnMPDYdp6GBCiaeMJyS5U28G00yrVPibC6JlapZLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>点击下拉箭头，列表中就是 cinder-api 可执行的操作。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWsWcjBTZ10HDTQLCrJa9oaKG519iaibkxiazIdxPnDb8F6YXI1u28vvKlQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>cinder-scheduler</strong></p>
<p>创建 Volume 时，cinder-scheduler 会基于容量、Volume Type 等条件选择出最合适的存储节点，然后让其创建 Volume。这个部分比较多，我们下一次单独讨论。</p>
<p><strong>cinder-volume</strong></p>
<p>cinder-volume 在存储节点上运行，OpenStack 对 Volume 的操作，最后都是交给 cinder-volume 来完成的。cinder-volume 自身并不管理真正的存储设备，存储设备是由 volume provider 管理的。cinder-volume 与 volume provider 一起实现 volume 生命周期的管理。</p>
<p><strong>通过 Driver 架构支持多种 Volume Provider</strong></p>
<p>接着的问题是：现在市面上有这么多块存储产品和方案（volume provider），cinder-volume 如何与它们配合呢？</p>
<p>这就是我们之前讨论过的 Driver 架构。 cinder-volume 为这些 volume provider 定义了统一的接口，volume provider 只需要实现这些接口，就可以 Driver 的形式即插即用到 OpenStack 系统中。下面是 Cinder Driver 的架构示意图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWMdvTzYEk3Wng4wGlD0jXkCM5ultVo687vFCEW5YHCQtAT9aJTJhgQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们可以在 /opt/stack/cinder/cinder/volume/drivers/ 目录下查看到 OpenStack 源代码中已经自带了很多 volume provider 的 Driver：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdW4AcbwbM5qKA2GPmohXPecWhicS4azKTp0piachMicCfOibotFogmyFjmnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>存储节点在配置文件 /etc/cinder/cinder.conf 中用 volume_driver 选项配置使用的driver：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWhtdibD5yEvCJq5oIs5AYbOKPOwpplIyibpQJKDZ0SQYSy4CXsVJgu8SQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里 LVM 是我们使用的 volume provider。</p>
<p><strong>定期向 OpenStack 报告计算节点的状态</strong></p>
<p>在前面 cinder-scheduler 会用到 CapacityFilter 和 CapacityWeigher，它们都是通过存储节点的空闲容量来做筛选。 那这里有个问题：Cinder 是如何得知每个存储节点的空闲容量信息的呢？</p>
<p>答案就是：<strong>cinder-volume 会定期向 Cinder 报告</strong>。</p>
<p>从 cinder-volume 的日志 /opt/stack/logs/c-vol.log 可以发现每隔一段时间，cinder-volume 就会报告当前存储节点的资源使用情况。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqGTic0yDaDlEt7iaao8xIeJdWIvR1gI2IuO4vUajEQdXodwLMGGuzYN0FibZuXVL1Hvc3eQSTriaiazrQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>因为在我们的实验环境中存储节点使用的是 LVM，所以在上面的日志看到存储节点通过“vgs”和”lvs”这两个命令获取 LVM 的容量使用信息。</p>
<p><strong>实现 volume 生命周期管理</strong></p>
<p>Cinder 对 volume 的生命周期的管理最终都是通过 cinder-volume 完成的，包括 volume 的 create、extend、attach、snapshot、delete 等，后面我们会详细讨论。下一节我们将详细讨论 cinder-scheduler 如何筛选 cinder-volume。</p>
<h4 id="cinder-schduler"><a href="#cinder-schduler" class="headerlink" title="cinder-schduler"></a>cinder-schduler</h4><p>上一节我们详细讨论了 cinder-api 和 cinder-volume，今天讨论另一个重要的 Cinder 组件 cinder-scheduler。</p>
<p>创建 Volume 时，cinder-scheduler 会基于容量、Volume Type 等条件选择出最合适的存储节点，然后让其创建 Volume。下面介绍 cinder-scheduler 是如何实现这个调度工作的。</p>
<p>在 /etc/cinder/cinder.conf 中，cinder 通过 scheduler_driver， scheduler_default_filters 和 scheduler_default_weighers 这三个参数来配置 cinder-scheduler。</p>
<p><strong>Filter scheduler</strong></p>
<p>Filter scheduler 是 cinder-scheduler 默认的调度器。</p>
<blockquote>
<p>scheduler_driver=cinder.scheduler.filter_scheduler.FilterScheduler</p>
</blockquote>
<p>与 Nova 一样，Cinder 也允许使用第三方 scheduler，配置 scheduler_driver 即可。</p>
<p>scheduler 调度过程如下：</p>
<ol>
<li>通过过滤器（filter）选择满足条件的存储节点（运行 cinder-volume）</li>
<li>通过权重计算（weighting）选择最优（权重值最大）的存储节点。</li>
</ol>
<p>可见，cinder-scheduler 的运行机制与 nova-scheduler 完全一样。</p>
<p><strong>Filter</strong></p>
<p>当 Filter scheduler 需要执行调度操作时，会让 filter 对存储节点进行判断，filter 返回 True 或者 False。cinder.conf 中 scheduler_default_filters 选项指定 filter scheduler 使用的 filter，默认值为：</p>
<blockquote>
<p>scheduler_default_filters = AvailabilityZoneFilter, CapacityFilter, CapabilitiesFilter</p>
</blockquote>
<p>Filter scheduler 将按照上面的顺序依次过滤：</p>
<p>AvailabilityZoneFilter</p>
<p>为提高容灾性和提供隔离服务，可以将存储节点和计算节点划分到不同的 Availability Zone 中。例如把一个机架上的机器划分在一个 Availability Zone 中。OpenStack 默认有一个命名为“Nova”的 Availability Zone，所有的节点初始都是放在“Nova”中。用户可以根据需要创建自己的 Availability Zone。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQ843WbfXuLQ6DRgZs2Q1exiahGWI7VxXLxwbAJZZdtAT32CEcBDqVIXA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>创建 Volume 时，需要指定 Volume 所属的 Availability Zone。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQw12TOdvw9kZoh3pXicxQgTU14hqBOlJBEW0eUeYT49DeCFjcqzFgFag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>cinder-scheduler 在做 filtering 时，会使用 AvailabilityZoneFilter 将不属于指定 Availability Zone 的存储节点过滤掉。</p>
<p>CapacityFilter</p>
<p>创建 Volume 时，用户会指定 Volume 的大小。CapacityFilter 的作用是将存储空间不能满足 Volume 创建需求的存储节点过滤掉。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQYaztxrefL4qKpgtTVVgB8ia2EKg3ic1hf6n6sIHNgxbIo3LqEGIn88Lw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>CapabilitiesFilter</p>
<p>不同的 Volume Provider 有自己的特性（Capabilities），比如是否支持 thin provision 等。Cinder 允许用户创建 Volume 时通过 Volume Type 指定需要的 Capabilities。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQV1bHaphZrryjz3qf68GepQ1dic0F2FVzhVWVFAibp0iavC7SCLsFNWO3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Volume Type 可以根据需要定义若干 Capabilities，详细描述 Volume 的属性。VolumeVolume Type 的作用与 Nova 的 flavor 类似。</p>
<p>Volume Type 在 Admin -&gt; System -&gt; Volume 菜单里管理</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQ0icjtiat2Tu6qj31O4ibZuYqQsrgSYH6G6bLeZvjfmgPG5XmRw3GiaGW0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>通过 Volume Type 的 Extra Specs 定义 Capabilities</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQl1yS1ZUIUKfMhBq0hQf4icezugxpVbZDj4DrTRLngahRYtMlibb6iaq8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Extra Specs 是用 Key-Value 的形式定义。 不同的 Volume Provider 支持的 Extra Specs 不同，需要参考 Volume Provider 的文档。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFq5oB4FnarfMMyOP87ibqrQn0Bttt8QrfiaibhlExOQic9mtjwSVibWqWwujMv7qDhFm6ics2EpztZwDcQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>上图所示的 Volume Type 只有一个 Extra Specs “volume_backend_name”，这是最重要也是必须的 Extra Specs。</p>
<p>cinder-volume 会在自己的配置文件 /etc/cinder/cinder.conf 中设置“volume_backend_name”这个参数，其作用是为存储节点的 Volume Provider 命名。这样，CapabilitiesFilter 就可以通过 Volume Type 的“volume_backend_name”筛选出指定的 Volume Provider。</p>
<p>不同的存储节点可以在各自的 cinder.conf 中配置相同的 volume_backend_name，这是允许的。因为虽然存储节点不同，但它们可能使用的是一种 Volume Provider。</p>
<p>如果在第一步 filtering 环节选出了多个存储节点，那么接下来的 weighting 环节会挑选出最合适的一个节点。</p>
<p><strong>Weighter</strong></p>
<p>Filter Scheduler 通过 scheduler_default_weighers 指定计算权重的 weigher，默认为 CapacityWeigher。</p>
<blockquote>
<p>scheduler_default_weighers = CapacityWeigher</p>
</blockquote>
<p>如命名所示，CapacityWeigher 基于存储节点的空闲容量计算权重值，空闲最多的胜出。下一节我们将开始通过各种场景学习 Cinder。</p>
<h1 id="网络Neutron"><a href="#网络Neutron" class="headerlink" title="网络Neutron"></a>网络Neutron</h1><h3 id="Neutron概述"><a href="#Neutron概述" class="headerlink" title="Neutron概述"></a>Neutron概述</h3><p>从今天开始，我们将学习 OpenStack 的 Networking Service，Neutron。</p>
<p>Neutron 的难度会比前面所有模块都大一些，内容也多一些。为了帮助大家更好的掌握 Neutorn，CloudMan 也会分析地更详细一些。</p>
<p><strong>Neutron 概述</strong></p>
<p>传统的网络管理方式很大程度上依赖于管理员手工配置和维护各种网络硬件设备；而云环境下的网络已经变得非常复杂，特别是在多租户场景里，用户随时都可能需要创建、修改和删除网络，网络的连通性和隔离不已经太可能通过手工配置来保证了。</p>
<p>如何快速响应业务的需求对网络管理提出了更高的要求。传统的网络管理方式已经很难胜任这项工作，而“软件定义网络（software-defined networking, SDN）”所具有的灵活性和自动化优势使其成为云时代网络管理的主流。</p>
<p>Neutron 的设计目标是实现“网络即服务（Networking as a Service）”。为了达到这一目标，在设计上遵循了基于 SDN 实现网络虚拟化的原则，在实现上充分利用了 Linux 系统上的各种网络相关的技术。</p>
<p>在这一章，我们将讨论 Neutron 的功能和它的各个组件，学习部署和配置 OpenStack 网络的不同方法，会涉及软件和硬件设备多个层面。</p>
<p><strong>Neutron 功能</strong></p>
<p>Neutron 为整个 OpenStack 环境提供网络支持，包括二层交换，三层路由，负载均衡，防火墙和 VPN 等。Neutron 提供了一个灵活的框架，通过配置，无论是开源还是商业软件都可以被用来实现这些功能。</p>
<p>二层交换 Switching</p>
<p>Nova 的 Instance 是通过虚拟交换机连接到虚拟二层网络的。Neutron 支持多种虚拟交换机，包括 Linux 原生的 Linux Bridge 和 Open vSwitch。 Open vSwitch（OVS）是一个开源的虚拟交换机，它支持标准的管理接口和协议。</p>
<p>利用 Linux Bridge 和 OVS，Neutron 除了可以创建传统的 VLAN 网络，还可以创建基于隧道技术的 Overlay 网络，比如 VxLAN 和 GRE（Linux Bridge 目前只支持 VxLAN）。在后面章节我们会学习如何使用和配置 Linux Bridge 和 Open vSwitch。</p>
<p>三层路由 Routing</p>
<p>Instance 可以配置不同网段的 IP，Neutron 的 router（虚拟路由器）实现 instance 跨网段通信。router 通过 IP forwarding，iptables 等技术来实现路由和 NAT。我们将在后面章节讨论如何在 Neutron 中配置 router 来实现 instance 之间，以及与外部网络的通信。</p>
<p>负载均衡 Load Balancing</p>
<p>Openstack 在 Grizzly 版本第一次引入了 Load-Balancing-as-a-Service（LBaaS），提供了将负载分发到多个 instance 的能力。LBaaS 支持多种负载均衡产品和方案，不同的实现以 Plugin 的形式集成到 Neutron，目前默认的 Plugin 是 HAProxy。我们会在后面章节学习 LBaaS 的使用和配置。</p>
<p>防火墙 Firewalling</p>
<p>Neutron 通过下面两种方式来保障 instance 和网络的安全性。</p>
<p>Security Group </p>
<p>通过 iptables 限制进出 instance 的网络包。</p>
<p>Firewall-as-a-Service<br>WaaS，限制进出虚拟路由器的网络包，也是通过 iptables 实现。</p>
<p>后面章节会详细讨论 Security 和 FWaaS。下一节我们会讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587694&idx=1&sn=7d844a30662b9af11de26d7f4322e9c9&chksm=8d3080f7ba4709e12ea3c32c314cb5b93c3e23d751cda63114234821f9946ef5c4d3a4880f25&scene=21#wechat_redirect">Neutron 网络涉及的一些基本概念</a>，便于后面深入学习。</p>
<h3 id="Neutron网络基本概念"><a href="#Neutron网络基本概念" class="headerlink" title="Neutron网络基本概念"></a>Neutron网络基本概念</h3><p>上次我们讨论了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587201&idx=1&sn=d35b7e5932adf85fdcb744e9d91d6f8d&scene=21#wechat_redirect">Neutron 提供的功能</a>，今天我们学习 Neutron 模块几个重要的概念。Neutron 管理的网络资源包括 Network，subnet 和 port，下面依次介绍。</p>
<p><strong>network</strong></p>
<p>network 是一个隔离的二层广播域。Neutron 支持多种类型的 network，包括 local, flat, VLAN, VxLAN 和 GRE。</p>
<p><strong>local</strong><br>local 网络与其他网络和节点隔离。local 网络中的 instance 只能与位于同一节点上同一网络的 instance 通信，local 网络主要用于单机测试。</p>
<p><strong>flat</strong><br>flat 网络是无 vlan tagging 的网络。flat 网络中的 instance 能与位于同一网络的 instance 通信，并且可以跨多个节点。</p>
<p><strong>vlan</strong><br>vlan 网络是具有 802.1q tagging 的网络。vlan 是一个二层的广播域，同一 vlan 中的 instance 可以通信，不同 vlan 只能通过 router 通信。vlan 网络可跨节点，是应用最广泛的网络类型。</p>
<p><strong>vxlan</strong><br>vxlan 是基于隧道技术的 overlay 网络。vxlan 网络通过唯一的 segmentation ID（也叫 VNI）与其他 vxlan 网络区分。vxlan 中数据包会通过 VNI 封装成 UDP 包进行传输。因为二层的包通过封装在三层传输，能够克服 vlan 和物理网络基础设施的限制。</p>
<p><strong>gre</strong><br>gre 是与 vxlan 类似的一种 overlay 网络。主要区别在于使用 IP 包而非 UDP 进行封装。</p>
<p>不同 network 之间在二层上是隔离的。</p>
<p>以 vlan 网络为例，network A 和 network B 会分配不同的 VLAN ID，这样就保证了 network A 中的广播包不会跑到 network B 中。当然，这里的隔离是指二层上的隔离，借助路由器不同 network 是可能在三层上通信的。</p>
<p>network 必须属于某个 Project（ Tenant 租户），Project 中可以创建多个 network。 network 与 Project 之间是 1对多 关系。</p>
<p><strong>subnet</strong></p>
<p>subnet 是一个 IPv4 或者 IPv6 地址段。instance 的 IP 从 subnet 中分配。每个 subnet 需要定义 IP 地址的范围和掩码。</p>
<p>network 与 subnet 是 1对多 关系。一个 subnet 只能属于某个 network；一个 network 可以有多个 subnet，这些 subnet 可以是不同的 IP 段，但不能重叠。下面的配置是有效的：</p>
<p>network A  subnet A-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>​          subnet A-b: 10.10.2.0/24  {“start”: “10.10.2.1”, “end”: “10.10.2.50”}</p>
<p>但下面的配置则无效，因为 subnet 有重叠</p>
<p>networkA   subnet A-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>​          subnet A-b: 10.10.1.0/24  {“start”: “10.10.1.51”, “end”: “10.10.1.100”}</p>
<p>这里不是判断 IP 是否有重叠，而是 subnet 的 CIDR 重叠（都是 10.10.1.0/24）。但是，如果 subnet 在不同的 network 中，CIDR 和 IP 都是可以重叠的，比如</p>
<p>network A  subnet A-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>networkB   subnet B-a: 10.10.1.0/24  {“start”: “10.10.1.1”, “end”: “10.10.1.50”}</p>
<p>这里大家不免会疑惑： 如果上面的IP地址是可以重叠的，那么就可能存在具有相同 IP 的两个 instance，这样会不会冲突？ 简单的回答是：不会！</p>
<p>具体原因： 因为 Neutron 的 router 是通过 Linux network namespace 实现的。network namespace 是一种网络的隔离机制。通过它，每个 router 有自己独立的路由表。上面的配置有两种结果：</p>
<ol>
<li><p>如果两个 subnet 是通过同一个 router 路由，根据 router 的配置，只有指定的一个 subnet 可被路由。</p>
</li>
<li><p>如果上面的两个 subnet 是通过不同 router 路由，因为 router 的路由表是独立的，所以两个 subnet 都可以被路由。</p>
</li>
</ol>
<p>这里只是先简单做个说明，我们会在后面三层路由的章节详细分析这种场景。</p>
<p><strong>port</strong></p>
<p>port 可以看做虚拟交换机上的一个端口。port 上定义了 MAC 地址和 IP 地址，当 instance 的虚拟网卡 VIF（Virtual Interface） 绑定到 port 时，port 会将 MAC 和 IP 分配给 VIF。</p>
<p>subnet 与 port 是 1对多 关系。一个 port 必须属于某个 subnet；一个 subnet 可以有多个 port。</p>
<p><strong>小节</strong></p>
<p>下面总结了 Project，Network，Subnet，Port 和 VIF 之间关系。</p>
<p>Project 1 : m Network 1 : m Subnet 1 : m Port 1 : 1 VIF m : 1 Instance</p>
<p>下一节我们讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587691&idx=1&sn=c71b110dade71c3e120ec6b2389b3e33&chksm=8d3080f2ba4709e44eb08c55223e141f7ed0e069ebd6f770b7770665e00ff72d48ce41596a0b&scene=21#wechat_redirect">Neutron 的架构</a>。</p>
<h3 id="Neutron的架构"><a href="#Neutron的架构" class="headerlink" title="Neutron的架构"></a>Neutron的架构</h3><p>前面我们讨论了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587204&idx=1&sn=9d4b36188bfd91a896d68062dad4ee83&scene=21#wechat_redirect">Neutron 的基本概念</a>，今天我们开始分析 Neutron 的架构。</p>
<p><strong>Neutron 架构</strong></p>
<p>与 OpenStack 的其他服务的设计思路一样，Neutron 也是采用分布式架构，由多个组件（子服务）共同对外提供网络服务。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEZ5ovWJOuB1iaq0vRiaplgJtus2jUWMVcnHbgjteEHz4rJoCsotcrR0C3hUoWiaC7DfpOqleG8lRVibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Neutron 由如下组件构成：</p>
<p>**Neutron Server<br>**对外提供 OpenStack 网络 API，接收请求，并调用 Plugin 处理请求。</p>
<p>**Plugin<br>**处理 Neutron Server 发来的请求，维护 OpenStack 逻辑网络状态， 并调用 Agent 处理请求。</p>
<p>**Agent<br>**处理 Plugin 的请求，负责在 network provider 上真正实现各种网络功能。</p>
<p>**network provider<br>**提供网络服务的虚拟或物理网络设备，例如 Linux Bridge，Open vSwitch 或者其他支持 Neutron 的物理交换机。</p>
<p>**Queue<br>**Neutron Server，Plugin 和 Agent 之间通过 Messaging Queue 通信和调用。</p>
<p>**Database<br>**存放 OpenStack 的网络状态信息，包括 Network, Subnet, Port, Router 等。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqEZ5ovWJOuB1iaq0vRiaplgJtEbDQkCyia1o8QZwqWOJgmmDlrbN454daWqqvaRjbKZqu117AjDscfZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Neutron 架构非常灵活，层次较多，目的是：</p>
<ol>
<li><p>为了支持各种现有或者将来会出现的优秀网络技术。</p>
</li>
<li><p>支持分布式部署，获得足够的扩展性。</p>
</li>
</ol>
<p>通常鱼和熊掌不能兼得，虽然获得了这些优势，但这样使得 Neutron 更加复杂，更不容易理解。 后面我们会详细讨论 Neutron 的各个组件，但在这之前，非常有必要先通过一个例子了解这些组件各自的职责以及是如何协同工作。</p>
<p>以创建一个 VLAN100 的 network 为例，假设 network provider 是 linux bridge， 流程如下：</p>
<blockquote>
<ol>
<li><p>Neutron Server 接收到创建 network 的请求，通过 Message Queue（RabbitMQ）通知已注册的 Linux Bridge Plugin。</p>
</li>
<li><p>Plugin 将要创建的 network 的信息（例如名称、VLAN ID等）保存到数据库中，并通过 Message Queue 通知运行在各节点上的 Agent。</p>
</li>
<li><p>Agent 收到消息后会在节点上的物理网卡（比如 eth2）上创建 VLAN 设备（比如 eth2.100），并创建 bridge （比如 brqXXX） 桥接 VLAN 设备。</p>
</li>
</ol>
</blockquote>
<p>关于 linux bridge 如何实现 VLAN 大家可以参考本教程“预备知识-&gt;网络虚拟化”的相关章节。这里进行几点说明：</p>
<ol>
<li><p>plugin 解决的是 What 的问题，即网络要配置成什么样子？而至于如何配置 How 的工作则交由 agent 完成。</p>
</li>
<li><p>plugin，agent 和 network provider 是配套使用的，比如上例中 network provider 是 linux bridge，那么就得使用 linux bridge 的 plungin 和 agent；如果 network provider 换成了 OVS 或者物理交换机，plugin 和 agent 也得替换。</p>
</li>
<li><p>plugin 的一个主要的职责是在数据库中维护 Neutron 网络的状态信息，这就造成一个问题：所有 network provider 的 plugin 都要编写一套非常类似的数据库访问代码。为了解决这个问题，Neutron 在 Havana 版本实现了一个 ML2（Modular Layer 2）plugin，对 plgin 的功能进行抽象和封装。有了 ML2 plugin，各种 network provider 无需开发自己的 plugin，只需要针对 ML2 开发相应的 driver 就可以了，工作量和难度都大大减少。ML2 会在后面详细讨论。</p>
</li>
<li><p>plugin 按照功能分为两类： core plugin 和 service plugin。core plugin 维护 Neutron 的 netowrk, subnet 和 port 相关资源的信息，与 core plugin 对应的 agent 包括 linux bridge, OVS 等； service plugin 提供 routing, firewall, load balance 等服务，也有相应的 agent。后面也会分别详细讨论。</p>
</li>
</ol>
<p>以上是Neutron的逻辑架构，下一节我们讨论 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587687&idx=1&sn=adf2078fa91f552a23dd406bf9c0d30d&chksm=8d3080feba4709e8fca066ec1371c51f9b3a89229cfeb81f886e6895f0c2509a29e840ab6d19&scene=21#wechat_redirect">Neutron 的物理部署方案</a>。</p>
<h3 id="Neutron-物理部署方案"><a href="#Neutron-物理部署方案" class="headerlink" title="Neutron 物理部署方案"></a>Neutron 物理部署方案</h3><p>前面我们讨论了 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587207&idx=1&sn=2ad3cff789378312144d41ca2e9c1dc9&scene=21#wechat_redirect">Neutron 的架构</a>，本节讨论 Neutron 的物理部署方案：不同节点部署不同的 Neutron 服务组件。</p>
<p><strong>方案1：控制节点 + 计算节点</strong></p>
<p>在这个部署方案中，OpenStack 由控制节点和计算节点组成。</p>
<p><strong>控制节点</strong><br>部署的服务包括：neutron server, core plugin 的 agent 和 service plugin 的 agent。</p>
<p><strong>计算节点</strong><br>部署 core plugin 的agent，负责提供二层网络功能。</p>
<p>这里有几点需要说明： </p>
<p>\1. core plugin 和 service plugin 已经集成到 neutron server，不需要运行独立的 plugin 服务。</p>
<p>\2. 控制节点和计算节点都需要部署 core plugin 的 agent，因为通过该 agent 控制节点与计算节点才能建立二层连接。</p>
<p>\3. 可以部署多个控制节点和计算节点。</p>
<p><img src="/2022/06/09/OpenStack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>方案2：控制节点 + 网络节点 + 计算节点</strong></p>
<p>在这个部署方案中，OpenStack 由控制节点，网络节点和计算节点组成。</p>
<p>**控制节点<br>**</p>
<p>部署 neutron server 服务。</p>
<p>**网络节点<br>**部署的服务包括：core plugin 的 agent 和 service plugin 的 agent。</p>
<p>**计算节点<br>**部署 core plugin 的agent，负责提供二层网络功能。</p>
<p>这个方案的要点是将所有的 agent 从控制节点分离出来，部署到独立的网络节点上。</p>
<ol>
<li><p>控制节点只负责通过 neutron server 响应 API 请求。</p>
</li>
<li><p>由独立的网络节点实现数据的交换，路由以及 load balance等高级网络服务。</p>
</li>
<li><p>可以通过增加网络节点承担更大的负载。</p>
</li>
<li><p>可以部署多个控制节点、网络节点和计算节点。</p>
</li>
</ol>
<p>该方案特别适合规模较大的 OpenStack 环境。</p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz/Hia4HVYXRicqHuicQalCOiaMzJkIfDGxicQibEt6Yiat5ia1Nae2zkDn7AnFDflibI8bHgibtV4EmGD8eXhycKbVU4FApZvg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="图片"></p>
<p>以上就是 Neutron 两种典型的部署方案，下一节我们开始讨论 Neutron 的各个服务组件。首先学习 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587683&idx=1&sn=3c5cadd759831abf596d53859cb64b9d&chksm=8d3080faba4709ec386d03890f7ccec74a9adfb69a943466626428b237d4a3929e372496e8db&scene=21#wechat_redirect">Neutron Server</a> 。</p>
<h3 id="Neutron-Server-分层模型"><a href="#Neutron-Server-分层模型" class="headerlink" title="Neutron Server 分层模型"></a>Neutron Server 分层模型</h3><p>本节开始讨论 Neutron 的各个服务组件，首先学习 Neutron Server 。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqG2kaGXyYgYWVaMZBrLruk6LYphLicwibym5k79oEPDPAlrVCY9aQ9bDiahZQ2YTNZ8Ee6XgXqnhSGKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>上图是 Neutron Server 的分层结构，至上而下依次为：</p>
<p>**Core API<br>**对外提供管理 network, subnet 和 port 的 RESTful API。</p>
<p>**Extension API<br>**对外提供管理 router, load balance, firewall 等资源 的 RESTful API。</p>
<p>**Commnon Service<br>**认证和校验 API 请求。</p>
<p>**Neutron Core<br>**Neutron server 的核心处理程序，通过调用相应的 Plugin 处理请求。</p>
<p>**Core Plugin API<br>**定义了 Core Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Core Plgin。</p>
<p>**Extension Plugin API<br>**定义了 Service Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Service Plgin。</p>
<p>**Core Plugin<br>**实现了 Core Plugin API，在数据库中维护 network, subnet 和 port 的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 network。</p>
<p>**Service Plugin<br>**实现了 Extension Plugin API，在数据库中维护 router, load balance, security group 等资源的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 router。</p>
<p>归纳起来，Neutron Server 包括两部分：<br>\1. 提供 API 服务。<br>\2. 运行 Plugin。</p>
<p>即 <strong>Neutron Server = API + Plugins</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqG2kaGXyYgYWVaMZBrLruk6fRic3xJzD7tJjhr2g0OXKJaOz6DNopZv0JiaibdzBBNcZ4GJsOHh8JpQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br>明白了 Neutron Server 的分层模型，我们就更容易理解 <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTM5MjUwMg==&mid=2653587682&idx=1&sn=bd57acc0560ce9bcdcc7781ed24067df&chksm=8d3080fbba4709ed1dd5ba820daa2c845d1aff1d4cd5670b74337df386f3fbf2544ab5fb65c0&scene=21#wechat_redirect">Neutron 是如何支持多种 network provider</a>。这一点我们放到下节详细讨论。</p>
<h1 id="如何使用-OpenStack-CLI"><a href="#如何使用-OpenStack-CLI" class="headerlink" title="如何使用 OpenStack CLI"></a>如何使用 OpenStack CLI</h1><p>OpenStack 服务都有自己的 CLI。</p>
<p>命令很好记，就是服务的名字，比如 Glance 就是 glance，Nova 就是 nova。</p>
<p>但 Keystone 比较特殊，现在是用 openstack 来代替老版的 keystone 命令。 比如查询用户列表，如果用 keystone user-list</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoZ0O7zQTVVic7H0DDiccziaL8ZD3yc8yicn8D7j02Rr9I1G3MxZ2tIGJkvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>会提示 keystone 已经 deprecated 了。 用 openstack 命令代替</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoY8lTica2iayAOzjcLnl7hcTKZMlXkg281SgwOxTFLvFAg4icLkJlREGQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>不同服务用的命令虽然不同，但这些命令使用方式却非常类似，可以举一反三。</p>
<p>\1. 执行命令之前，需要设置环境变量。</p>
<p>这些变量包含用户名、Project、密码等； 如果不设置，每次执行命令都必须设置相关的命令行参数</p>
<p>\2. 各个服务的命令都有增、删、改、查的操作</p>
<p>其格式是</p>
<blockquote>
<p>CMD <obj>-create [parm1] [parm2]…<br>CMD <obj>-delete [parm]<br>CMD <obj>-update [parm1] [parm2]…<br>CMD <obj>-list CMD <obj>-show [parm]</obj></obj></obj></obj></obj></p>
</blockquote>
<p>例如 glance 管理的是 image，那么:<br>CMD 就是 glance，obj 就是 image，对应的命令就有</p>
<blockquote>
<p>glance image-create<br>glance image-delete<br>glance image-update<br>glance image-list<br>glance image-show</p>
</blockquote>
<p>再比如 neutron 负责管理网络和子网，那么：<br>CMD 就是 neutron；obj 就是 net 和 subnet 对应的命令就有</p>
<p>网络相关操作</p>
<blockquote>
<p>neutron net-create<br>neutron net -delete<br>neutron net -update<br>neutron net -list<br>neutron net –show</p>
</blockquote>
<p>子网相关操作</p>
<blockquote>
<p>neutron subnet-create<br>neutron subnet -delete<br>neutron subnet -update<br>neutron subnet -list<br>neutron subnet–show</p>
</blockquote>
<p>有的命令 <obj> 可以省略，比如 nova 下面的操作都是针对 instance</obj></p>
<blockquote>
<p>nova boot<br>nova delete<br>nova list nova show</p>
</blockquote>
<p>\3. 每个对象都有 ID</p>
<p>delete，show 等操作都以 ID 为参数，例如</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxosDD7iaX5dVUBApKyE8J5Y6wzrJdoL8LRaicZUOibNGEsT4nwex8wtPia7g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>\4. 可用 help 查看命令的用法</p>
<p>除了 delete，show 等操作只需要 ID 一个参数，其他操作可能需要更多的参数，用 help 查看所需的参数，格式是</p>
<blockquote>
<p>CMD help [SUB-CMD]</p>
</blockquote>
<p>例如查看 glance 都有哪些 SUB-CMD</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoiaouoAy9x9HeoGbAlbxeZV1icICxlOggtu8TQDjYngjbQaCbDUwkrMMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>查看 glance image-update 的用法</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoC6wkrs2JreTTXg8acclN6D0QWgo1PBKibG9mXe2VkiaAJD0tUcibFsn4g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p><strong>如何 Troubleshooting</strong></p>
<p>OpenStack 排查问题的方法主要是通过日志，Service 都有自己单独的日志。Glance 主要有两个日志，glance_api.log 和 glance_registry.log，保存在 /opt/stack/logs 目录里。devstack 的 screen 窗口已经帮我们打开了这两个日志，可以直接查看</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxoHB1eic8Am009h7Yic2gice9UAZwjYickt0LGDBLPnfiawMPjyVQWzR24l6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>g-api 窗口显示 glance-api 日志，记录 REST API 调用情况。<br>g-reg 窗口显示 glance-registry 日志，记录 Glance 服务处理请求的过程以及数据库操作。</p>
<p>如果需要得到最详细的日志信息，可以在 /etc/glance/*.conf 中打开 debug 选项。 devstack 默认已经打开了 debug。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/Hia4HVYXRicqFnjmCfCyrnKejYc9C8sHxo4z8oFPdchEt1zJian8icia6mzphEE8FtzvicMflwHwh9PKLicpvsWprVFQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"> </p>
<p>在非 devstack 安装中，日志在 /var/log/glance/ 目录里。</p>
<p>packstack –allinone –os-neutron-l2-agent=openvswitch –os-neutron-ml2-mechanism-drivers=openvswitch –os-neutron-ml2-tenant-network-types=vxlan –os-neutron-ml2-type-drivers=vxlan,flat –provision-demo=n –os-neutron-ovs-bridge-mappings=extnet:br-ex –os-neutron-ovs-bridge-interfaces=br-ex:eno1 –keystone-admin-passwd=’cnlab.net’ –provision-demo=n  –nova-libvirt-virt-type=kvm –os-swift-storage-size=100G –cinder-volumes-size=500G</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/03/02/Octave%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/Octave%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Octave基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 14:52:47" itemprop="dateCreated datePublished" datetime="2022-03-02T14:52:47+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-23 09:31:02" itemprop="dateModified" datetime="2022-03-23T09:31:02+08:00">2022-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Basic-operation-基础操作"><a href="#Basic-operation-基础操作" class="headerlink" title="Basic operation 基础操作"></a>Basic operation 基础操作</h1><p>算数运算：加减乘除； ==；~=；</p>
<p>逻辑运算：&amp;&amp;   -AND；  ||   -OR； </p>
<p>字符串： EX： a = ‘Hello world!’</p>
<p>disp函数： EX： disp( sprintf(‘ %0.2f’ ),variable )  %保留variable小数点后两位</p>
<p>矩阵： A = [1 2；2 3；4 5]</p>
<p>V = 1: 0.2: 2     %会生成一个增量为0.2的从1到2的 1行_列的矩阵; 如果中间不填，默认增量是1；</p>
<p>ones函数：ones（3，2）  %生成一个3行两列的 值都是1的矩阵； 同理zeros（）也是</p>
<p>rand（m，n）函数：随机在0-1范围内生成m*n矩阵的值</p>
<p>randn（m，n）函数：随机生成的数符合高斯分布/正态分布</p>
<p>hist（）：绘制直方图</p>
<p>eye( n )  : 生成n阶单位矩阵</p>
<p>size( ) : 返回矩阵的大小，返回的也是一个1行2列的矩阵；</p>
<p>size（A，1 or 2）：返回矩阵的行或列</p>
<p>help命令： 如 help eye；就可以获得eye函数的用法</p>
<h1 id="Moving-Data-Around-移动数据过来"><a href="#Moving-Data-Around-移动数据过来" class="headerlink" title="Moving Data Around 移动数据过来"></a>Moving Data Around 移动数据过来</h1><p><strong>load file.dat</strong></p>
<p><strong>load ( ‘file.dat ‘ )</strong></p>
<p>who函数： 展示目前工作空间中的所有变量</p>
<p>whos函数：更详细的展示变量的size,bytes</p>
<p>clear(variable): 删除某个变量</p>
<p>save  filename.mat v; : 将v保存为filename.mat的名字</p>
<p>or save filename.txt v -ascii;</p>
<p>查看矩阵元素的值：</p>
<p>如 A=[1 2；3 4；5 6]</p>
<p>A（2，2） ans = 4;   A(2,:) ans= 3, 4      % “:”代表着某行或某列所有的元素</p>
<p>A([1 3] , :) ans = 1 2; 5 6        % 1,3行的所有列元素</p>
<p>也可利用这个单独给某列赋值：</p>
<p>A（：，2） = [12 ；11； 10]</p>
<p>A = [A, [11;22;33]]                   %Add  a new column vector</p>
<p>A（：） 可以把所有元素变成一个变量</p>
<p>[ A B] 将两个行相等的矩阵放一起</p>
<p>[A ; B] 将列相等的矩阵竖置</p>
<h1 id="Plotting-Data-绘制数据"><a href="#Plotting-Data-绘制数据" class="headerlink" title="Plotting Data 绘制数据"></a>Plotting Data 绘制数据</h1><p><strong>常用命令：</strong></p>
<p>plot（x,y(x)）; </p>
<p>xlabel ( ‘ ‘ );   ylabel ( ‘ ‘ ) ;</p>
<p>legend( ‘ ‘ , ‘ ‘ );</p>
<p>title( ‘ ‘ )</p>
<p>print -dpng ‘filename.png’;</p>
<p>figure(1): plot(t ,y1)</p>
<p>figure(2): plot(t,y2)</p>
<p>subplot(1,2,1);</p>
<p>polar(thera , r): 绘制极坐标</p>
<p>cart2pol: 将直角坐标系转化为极坐标系</p>
<p>pol2cart: 极坐标转化为直角坐标系          ex： [x，y] = pol2cart（theta，r）</p>
<blockquote>
<p>误差棒图： errorbar（x，y，error）</p>
</blockquote>
<p><strong>向量图形：</strong></p>
<ol>
<li>箭头图</li>
</ol>
<p>quiver(U,V)   U,V 都是二维矩阵；</p>
<ol start="2">
<li>罗盘图</li>
</ol>
<p>compass（x，y）   ； </p>
<p><strong>三维图形：</strong></p>
<p>plot3（x，y，z）；</p>
<p>mesh();</p>
<p>peaks();</p>
<p>meshgrid( ) 将一维变成二维</p>
<h3 id="图形修饰处理"><a href="#图形修饰处理" class="headerlink" title="图形修饰处理"></a>图形修饰处理</h3><ol>
<li>坐标轴处理   —-    daspect</li>
<li>mesh();   hidden on / off</li>
<li>视角处理： view(az/方位角, el/仰角)</li>
</ol>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p>F =  getframe( )</p>
<p>movie(F, num_)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/02/28/docker%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/docker%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Docker学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-28 20:12:35" itemprop="dateCreated datePublished" datetime="2022-02-28T20:12:35+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-26 15:14:47" itemprop="dateModified" datetime="2022-08-26T15:14:47+08:00">2022-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Docker教程：<a target="_blank" rel="noopener" href="https://docker-curriculum.com/">https://docker-curriculum.com/</a></p>
<p>K8S教程：<a target="_blank" rel="noopener" href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45">https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/" class="post-title-link" itemprop="url">厦门_脉冲星补习_2022年夏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-22 14:13:52" itemprop="dateCreated datePublished" datetime="2022-01-22T14:13:52+08:00">2022-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 16:00:48" itemprop="dateModified" datetime="2022-08-29T16:00:48+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Astronomy/" itemprop="url" rel="index"><span itemprop="name">Astronomy</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是脉冲星"><a href="#什么是脉冲星" class="headerlink" title="什么是脉冲星"></a>什么是脉冲星</h1><h2 id="中子星（Neutron-stars）"><a href="#中子星（Neutron-stars）" class="headerlink" title="中子星（Neutron stars）"></a>中子星（Neutron stars）</h2><p>​        从广义上讲，当一颗普通恒星耗尽其能量来源时，它会在自身引力的作用下坍缩。一颗具有正常物质密度的恒星最终会处于三种可能的状态之一：白矮星、中子星或黑洞。坍缩的程度取决于前身星的质量；质量最大的变成黑洞，质量最小的变成白矮星。中子星的前身具有有限的中间质量范围，大约为 8 到 20 个太阳质量（M = 2 × 1033 g）。根据恒星质量的统计分布，超过 95% 的恒星在没有进一步坍缩的情况下以白矮星的形式结束生命。、</p>
<p>​        朗道在 1932 年提出的一项建议导致巴德和兹威基在 1934 年提出第一个建议，即 <strong>中子星可能是普通恒星超新星坍缩的最终产物</strong>。</p>
<p>​        中子星就像一个巨大的原子核，密度与核物质相近。对于通常假设的参数（半径 10 km，质量 1.4 M），平均密度为 6.7×1014 gcm-3，而核物质的密度 ρs = 2.7×1014 gcm-3。</p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/2.png">  </p>
<h2 id="中子星的磁场"><a href="#中子星的磁场" class="headerlink" title="中子星的磁场"></a>中子星的磁场</h2><p>​        脉冲星是非常强磁化的中子星。</p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/WX20220812-142707@2x.png"> </p>
<h2 id="脉冲星信号特点"><a href="#脉冲星信号特点" class="headerlink" title="脉冲星信号特点"></a>脉冲星信号特点</h2><ul>
<li>脉冲星信号的周期和轮廓非常稳定<ul>
<li>单个脉冲变化但平均脉冲非常稳定，周期特别精确<ul>
<li>‘FFT找周期</li>
</ul>
</li>
</ul>
</li>
<li>脉冲信号波包因为星际介质而色散 <ul>
<li>脉冲星在各个频率上同时辐射信号，但星际介质电离气 体使低频信号延迟一些到达地球 .</li>
<li>消色散技术（也是排除干扰的方法）</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/6.png">   </p>
<h3 id="子脉冲漂移"><a href="#子脉冲漂移" class="headerlink" title="子脉冲漂移"></a>子脉冲漂移</h3><p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/7.png">  </p>
<h3 id="Pulsar-Nulling"><a href="#Pulsar-Nulling" class="headerlink" title="Pulsar Nulling"></a>Pulsar Nulling</h3><ul>
<li>长周期脉冲星容易发生 “缺脉冲” </li>
<li>个别脉冲星缺失率达 96%</li>
<li>脉冲缺失伴随脉冲波形改变</li>
</ul>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/8.png">  </p>
<h3 id="脉冲轮廓的基本特点"><a href="#脉冲轮廓的基本特点" class="headerlink" title="脉冲轮廓的基本特点"></a>脉冲轮廓的基本特点</h3><p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/9.png">   </p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/10.png">  </p>
<p>对于上述不同形状的脉冲说明：</p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/11.png">  </p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/12.png">  </p>
<h1 id="望远镜技术"><a href="#望远镜技术" class="headerlink" title="望远镜技术"></a>望远镜技术</h1><p>中子星和脉冲星的观测的特点：</p>
<p>(1) 信号弱，采集面积大，积分时间长。</p>
<p> (2) 物体的识别需要准确的位置和邻近来源的区分。 </p>
<p>(3) 脉冲源需要很高的定时精度，通常在 1 微秒左右。 </p>
<p>(4) 测量必须区分不需要的背景，无论是来自天文学的背景，例如来自银河系的无线电发射或宇宙射线，还是来自地面来源，尤其是人造无线电信号。</p>
<p>​        陆地大气对无线电波是透明的（除了发生分子吸收的短毫米波长和发生电离层折射和反射的长米波长）。因此射电望远镜可以建造在地面上，并且可以几乎无限地扩大尺寸，同时提供高灵敏度和高角度分辨率。 </p>
<p>​        X射线和伽马射线在大气中被吸收，只能使用天基望远镜才能直接探测到这种高能光子，而天基望远镜的望远镜孔径受限于运载火箭的能力，直径只有几米。</p>
<h2 id="射电望远镜"><a href="#射电望远镜" class="headerlink" title="射电望远镜"></a>射电望远镜</h2><p><strong>射电望远镜的基本组成</strong></p>
<ul>
<li>天线：用大面积反射面 聚焦电磁波</li>
<li>馈源：将电波变成电压信号</li>
<li>前端接收机：将信号放大和混频等处理</li>
<li>数字后端：将信号按科学需求进行数字化处理</li>
</ul>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/3.png">  </p>
<p><strong>系统噪声温度T<sub>sys</sub></strong></p>
<p>当射电望远镜指向没有射电源的天空背景，射电望远 镜还有功率输出。这个功率可等效为射电望远镜的系 统噪声温度 Tsys。它有多个方面的贡献:</p>
<p>T<sub>sys</sub>=T<sub>bg</sub>+T<sub>sky</sub>+T<sub>spill</sub>+T<sub>loss</sub> + T<sub>N</sub></p>
<ul>
<li>Tbg: 天空背景噪声温度(宇宙微波背景、银河系连续辐射 背景等);</li>
<li>T<sub>sky</sub>: 大气微波辐射</li>
<li>T<sub>spill</sub>：从射电望远镜旁瓣进入的地面辐射温度 </li>
<li>T<sub>loss</sub>： 馈源和输入到接收机前的波导损耗</li>
<li>T<sub>N</sub>：接收机噪声温度</li>
</ul>
<p><strong>射电望远镜的灵敏度</strong></p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/4.png">  </p>
<h3 id="标准的脉冲星搜寻方法"><a href="#标准的脉冲星搜寻方法" class="headerlink" title="标准的脉冲星搜寻方法"></a><strong>标准的脉冲星搜寻方法</strong></h3><p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/1.png">  </p>
<p><strong>脉冲星探测的信噪比</strong></p>
<p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/5.png">  </p>
<p>红外、光学和紫外望远镜</p>
<p>X 射线观测，伽马射线天基望远镜</p>
<h1 id="脉冲星色散DM与距离d"><a href="#脉冲星色散DM与距离d" class="headerlink" title="脉冲星色散DM与距离d"></a>脉冲星色散DM与距离d</h1><p><img src="/2022/01/22/%E8%84%89%E5%86%B2%E6%98%9F%E8%A1%A5%E4%B9%A0/13.png">  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2021/12/22/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/22/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">数据处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-22 13:54:16" itemprop="dateCreated datePublished" datetime="2021-12-22T13:54:16+08:00">2021-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 16:01:14" itemprop="dateModified" datetime="2022-08-29T16:01:14+08:00">2022-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2021/12/22/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/2021-12-2214-00-09.png"> </p>
<blockquote>
<p>数据处理的主要任务：</p>
<ol>
<li><p>Data cleaning</p>
<pre><code>Handle missing data, smooth noisy data, identify or remove outliers, and resolve inconsistencies
</code></pre>
</li>
<li><p>Data integration</p>
<p>​    Integration of multiple databases, data cubes, or files</p>
</li>
<li><p>Data reduction</p>
<p>​    Dimensionality reduction<br>​    Numerosity reduction<br>​    Data compression</p>
</li>
<li><p>Data transformation and data discretization</p>
<p>​    Normalization</p>
<p>​    Concept hierarchy generation</p>
</li>
</ol>
</blockquote>
<h1 id="Data-Cleaning"><a href="#Data-Cleaning" class="headerlink" title="Data Cleaning"></a>Data Cleaning</h1><ul>
<li> 生活中的数据通常“Dirty”，比如格式的错误，人和电脑的错误或是什么</li>
<li>Incomplete: lacking attribute values, lacking certain attributes of interest, or containing only aggregate data<ul>
<li>e.g., <em>Occupation</em> = “ ” (missing data)</li>
</ul>
</li>
<li>Noisy: containing noise, errors, or outliers<ul>
<li>e.g., <em>Salary</em> = “−10” (an error)</li>
</ul>
</li>
<li>Inconsistent: containing discrepancies in codes or names, <ul>
<li>e.g.,</li>
<li><em>Age</em> = “42”, <em>Birthday</em> = “03/07/2010”</li>
<li>Was rating “1, 2, 3”, now rating “A, B, C”</li>
<li>discrepancy between duplicate records</li>
</ul>
</li>
<li>Intentional (e.g., <em>disguised missing</em> data)<ul>
<li>Jan. 1 as everyone’s birthday?用户故意的输入不正确值（比如选用默认的生日）</li>
</ul>
</li>
</ul>
<h2 id="不完整数据（Incomplete-Data）"><a href="#不完整数据（Incomplete-Data）" class="headerlink" title="不完整数据（Incomplete Data）"></a>不完整数据（Incomplete Data）</h2><ul>
<li>Data is not always available<ul>
<li>E.g., many tuples have no recorded value for several attributes, such as customer income in sales data</li>
</ul>
</li>
<li>Missing data may be due to <ul>
<li>Equipment malfunction</li>
<li>Inconsistent with other recorded data and thus deleted</li>
<li>Data were not entered due to misunderstanding</li>
<li>Certain data may not be considered important at the time of entry</li>
<li>Did not register history or changes of the data</li>
</ul>
</li>
<li>Missing data may need to be inferred</li>
</ul>
<blockquote>
<p>How to deal with them ? 怎样处理缺失数据</p>
</blockquote>
<ul>
<li>Ignore the tuple: usually done when class label is missing (when doing classification)—not effective when the % of missing values per attribute varies considerably</li>
<li>Fill in the missing value manually: tedious + infeasible?</li>
<li>Fill in it automatically with<ul>
<li>a global constant : e.g., “unknown”, a new class?! </li>
<li>the attribute mean</li>
<li>the attribute mean for all samples belonging to the same class: smarter</li>
<li><strong>the most probable value: inference-based such as Bayesian formula or decision tree</strong>最可能值:基于推理的，如贝叶斯公式或决策树</li>
</ul>
</li>
</ul>
<h2 id="Noisy-Data"><a href="#Noisy-Data" class="headerlink" title="Noisy Data"></a>Noisy Data</h2><ul>
<li><strong>Noise:</strong> random error or variance in a measured variable (被测变量的随机误差或方差)</li>
<li><strong>Incorrect attribute values</strong> may be due to<ul>
<li>Faulty data collection instruments</li>
<li>Data entry problems</li>
<li>Data transmission problems</li>
<li>Technology limitation</li>
<li>Inconsistency in naming convention </li>
</ul>
</li>
<li><strong>Other data</strong> <strong>problems</strong><ul>
<li>Duplicate records</li>
<li>Incomplete data</li>
<li>Inconsistent data</li>
</ul>
</li>
</ul>
<blockquote>
<p>How to Handle Noisy Data? </p>
</blockquote>
<ul>
<li>Binning 分箱：按大小分箱，以各箱均值或中位值或边界值等代替箱内数据<ul>
<li>First sort data and partition into (equal-frequency) bins</li>
<li>Then one can <strong>smooth by bin means, smooth by bin median, smooth by bin boundaries</strong>, etc.</li>
</ul>
</li>
<li>Regression 回归<ul>
<li>Smooth by fitting the data into regression functions</li>
</ul>
</li>
<li>Clustering 聚类<ul>
<li>Detect and remove outliers</li>
</ul>
</li>
<li>Semi-supervised: Combined computer and human inspection  半监督<ul>
<li>Detect suspicious values and check by human (e.g., deal with possible outliers)</li>
</ul>
</li>
</ul>
<h2 id="数据清洗的过程"><a href="#数据清洗的过程" class="headerlink" title="数据清洗的过程"></a>数据清洗的过程</h2><ul>
<li><strong>Data discrepancy</strong> <strong>detection</strong> <strong>数据偏差检测</strong><ul>
<li>Use metadata (e.g., domain, range, dependency, distribution)</li>
<li>Check field overloading </li>
<li>Check uniqueness rule, consecutive rule and null rule</li>
<li>Use commercial tools<ul>
<li>Data scrubbing: use simple domain knowledge (e.g., postal code, spell-check) to detect errors and make corrections  数据清洗</li>
<li>Data auditing: by analyzing data to discover rules and relationship to detect violators (e.g., correlation and clustering to find outliers) 数据审计</li>
</ul>
</li>
</ul>
</li>
<li><strong>Data migration and</strong> <strong>integration</strong> <strong>数据迁移和集成</strong><ul>
<li>Data migration tools: allow transformations to be specified</li>
<li>ETL (Extraction/Transformation/Loading) tools: allow users to specify transformations through a graphical user interface</li>
</ul>
</li>
<li>Integration of the two processes （合并数据偏差和数据变换）<ul>
<li>Iterative and interactive (e.g., Potter’s Wheels)</li>
</ul>
</li>
</ul>
<h1 id="Data-Integration"><a href="#Data-Integration" class="headerlink" title="Data Integration"></a>Data Integration</h1><ul>
<li>Data integration 数据集成<ul>
<li>Combining data from multiple sources into a coherent store（将来自多个来源的数据合并到一个连贯的存储中）</li>
</ul>
</li>
<li>Schema integration: e.g., A.cust-id  B.cust-# 模式集成<ul>
<li>Integrate metadata from different sources</li>
</ul>
</li>
<li><strong>Entity</strong> <strong>identification:</strong>  <strong>实体识别</strong><ul>
<li>Identify real world entities from multiple data sources, e.g., Bill Clinton = William Clinton</li>
</ul>
</li>
<li>Detecting and resolving data value conflicts 检测和解决数值冲突<ul>
<li>For the same real world entity, attribute values from different sources are different</li>
<li>Possible reasons: different representations, different scales, e.g., metric vs. British units</li>
</ul>
</li>
</ul>
<h2 id="Handling-Redundancy-in-Integration"><a href="#Handling-Redundancy-in-Integration" class="headerlink" title="Handling Redundancy in Integration"></a>Handling Redundancy in Integration</h2><ul>
<li>Redundant data occur often when integration of multiple databases<ul>
<li><em>Object identification</em>: The same attribute or object may have different names in different databases<ul>
<li>对象标识:相同的属性或对象在不同的数据库中可能有不同的名称</li>
</ul>
</li>
<li><em>Derivable data:</em> One attribute may be a “derived” attribute in another table, e.g., annual revenue<ul>
<li>派生数据:一个属性可能是另一个表中的派生属性，例如年收入</li>
</ul>
</li>
</ul>
</li>
<li><strong>Redundant attributes may be able to be detected by</strong> <em><strong>correlation analysis</strong></em> <strong>and</strong> <em><strong>covariance analysis</strong></em>（通过相关分析和协方差分析可以发现冗余属性）</li>
<li>Careful integration of the data from multiple sources may help reduce/avoid redundancies and inconsistencies and improve mining speed and quality</li>
</ul>
<h2 id="相关性分析Correlation-Analysis-for-Categorical-Data"><a href="#相关性分析Correlation-Analysis-for-Categorical-Data" class="headerlink" title="相关性分析Correlation Analysis (for Categorical Data)"></a>相关性分析Correlation Analysis (for Categorical Data)</h2><ul>
<li>Null hypothesis: The two distributions are independent<ul>
<li>零假设:两个分布是独立的</li>
</ul>
</li>
<li>The cells that contribute the most to the Χ<sup>2</sup> value are those whose actual count is very different from the expected count<ul>
<li>The larger the Χ<sup>2</sup> value, the more likely the variables are related</li>
</ul>
</li>
<li>Note: Correlation does not imply causality 注:相关性并不意味着因果关系<ul>
<li># of hospitals and # of car-theft in a city are correlated</li>
<li>Both are causally linked to the third variable: population</li>
</ul>
</li>
</ul>
<h1 id="Data-Reduction-and-Transformation"><a href="#Data-Reduction-and-Transformation" class="headerlink" title="Data Reduction and Transformation"></a>Data Reduction and Transformation</h1><h2 id="Data-Reduction"><a href="#Data-Reduction" class="headerlink" title="Data Reduction"></a>Data Reduction</h2><ul>
<li><strong>Data reduction</strong>: <ul>
<li>Obtain a reduced representation of the data set <ul>
<li>much smaller in volume but yet produces <em>almost</em> the same analytical results</li>
</ul>
</li>
</ul>
</li>
<li>Why data reduction?—A database/data warehouse may store terabytes of data<ul>
<li>Complex analysis may take a very long time to run on the complete data set</li>
</ul>
</li>
<li><strong>Methods for data</strong> <strong>reduction</strong> (also <em>data size reduction</em> or <em>numerosity</em> <em>reduction</em>) <ul>
<li>Regression and Log-Linear Models</li>
<li>Histograms, clustering, sampling</li>
<li>Data cube aggregation</li>
<li>Data compression</li>
</ul>
</li>
</ul>
<blockquote>
<p>Data Reduction: <strong>Parametric vs. Non-Parametric Methods</strong></p>
</blockquote>
<ul>
<li>Reduce data volume by choosing alternative, <em>smaller forms</em> of data representation</li>
<li><strong>Parametric methods</strong> (e.g., regression)<ul>
<li>Assume the data fits some model, estimate model parameters, store only the parameters, and discard the data (except possible outliers)假设数据符合某个模型，估计模型参数，只存储参数，并丢弃数据(可能的离群值除外)</li>
<li>Ex.: Log-linear models—obtain value at a point in <em>m</em>-D space as the product on appropriate marginal subspaces 例如:对数线性模型获得m-D空间中某一点的值作为相应边际子空间上的乘积</li>
</ul>
</li>
<li><strong>Non-parametric</strong> methods <ul>
<li>Do not assume models</li>
<li>Major families: histograms, clustering, sampling, … </li>
</ul>
</li>
</ul>
<h3 id="参数化方法"><a href="#参数化方法" class="headerlink" title="参数化方法"></a>参数化方法</h3><h3 id="非参数化方法"><a href="#非参数化方法" class="headerlink" title="非参数化方法"></a>非参数化方法</h3><h2 id="Data-Transformation"><a href="#Data-Transformation" class="headerlink" title="Data Transformation"></a>Data Transformation</h2><ul>
<li>A function that maps the entire set of values of a given attribute to a new set of replacement values s.t. each old value can be identified with one of the new values  将给定属性的整个值集映射到一组新的替换值s.t的函数。每个旧值可以用一个新值来标识</li>
<li>Methods<ul>
<li>Smoothing: Remove noise from data</li>
<li>Attribute/feature construction<ul>
<li>New attributes constructed from the given ones</li>
</ul>
</li>
</ul>
</li>
<li>Aggregation: Summarization, data cube construction</li>
<li>Normalization: Scaled to fall within a smaller, specified range<ul>
<li>min-max normalization</li>
<li>z-score normalization</li>
<li>normalization by decimal scaling</li>
</ul>
</li>
<li>Discretization: Concept hierarchy climbing</li>
</ul>
<h3 id="Discretization（离散化）"><a href="#Discretization（离散化）" class="headerlink" title="Discretization（离散化）"></a>Discretization（离散化）</h3><ul>
<li>Three types of attributes<ul>
<li>Nominal—values from an unordered set, e.g., color, profession</li>
<li>Ordinal—values from an ordered set, e.g., military or academic rank </li>
<li>Numeric—real numbers, e.g., integer or real numbers</li>
</ul>
</li>
<li>Discretization: Divide the range of a continuous attribute into intervals<ul>
<li>Interval labels can then be used to replace actual data values </li>
<li>Reduce data size by discretization</li>
<li>Supervised vs. unsupervised</li>
<li>Split (top-down) vs. merge (bottom-up)</li>
<li>Discretization can be performed recursively on an attribute</li>
<li>Prepare for further analysis, e.g., classification</li>
</ul>
</li>
</ul>
<blockquote>
<p>离散化的方式</p>
</blockquote>
<ul>
<li>Binning <ul>
<li>Top-down split, unsupervised</li>
</ul>
</li>
<li>Histogram analysis<ul>
<li>Top-down split, unsupervised</li>
</ul>
</li>
<li>Clustering analysis <ul>
<li>Unsupervised, top-down split or bottom-up merge</li>
</ul>
</li>
<li>Decision-tree analysis<ul>
<li>Supervised, top-down split</li>
</ul>
</li>
<li>Correlation (e.g., 2) analysis <ul>
<li>Unsupervised, bottom-up merge</li>
</ul>
</li>
<li>Note: All the methods can be applied recursively</li>
</ul>
<h3 id="Concept-Hierarchy-Generation-概念分层"><a href="#Concept-Hierarchy-Generation-概念分层" class="headerlink" title="Concept Hierarchy Generation  概念分层"></a>Concept Hierarchy Generation  概念分层</h3><ul>
<li><strong>Concept hierarchy</strong> organizes concepts (i.e., attribute values) hierarchically and is usually associated with each dimension in a data warehouse概念层次按层次组织概念(即属性值)，通常与数据仓库中的每个维度相关联</li>
<li>Concept hierarchies facilitate drilling and rolling in data warehouses to view data in multiple granularity 概念层次结构便于在数据仓库中钻取和滚动，以便以多种粒度查看数据</li>
<li>Concept hierarchy formation: Recursively reduce the data by collecting and replacing low level concepts (such as numeric values for <em>age</em>) by higher level concepts (such as <em>youth, adult</em>, or <em>senior</em>) 概念层次结构的形成:通过收集和替换低级概念(如年龄的数值)，递归地减少数据(如青年、成人或老年人)</li>
<li>Concept hierarchies can be explicitly specified by domain experts and/or data warehouse designers  概念层次结构可以由领域专家和/或数据仓库设计者显式指定</li>
<li>Concept hierarchy can be automatically formed for both numeric and nominal data—For numeric data, use discretization methods shown  对于数值数据，可以使用所示的离散化方法</li>
</ul>
<h1 id="Dimensionality-Reduction"><a href="#Dimensionality-Reduction" class="headerlink" title="Dimensionality Reduction"></a>Dimensionality Reduction</h1><ul>
<li><strong>Curse of dimensionality</strong><ul>
<li>When dimensionality increases, data becomes increasingly sparse</li>
<li>Density and distance between points, which is critical to clustering, outlier analysis, becomes less meaningful</li>
<li>The possible combinations of subspaces will grow exponentially</li>
</ul>
</li>
<li><strong>Dimensionality reduction</strong><ul>
<li>Reducing the number of random variables under consideration, via obtaining a set of principal variables 通过获取一组主变量，减少考虑的随机变量的数量</li>
</ul>
</li>
<li><strong>Advantages of dimensionality reduction</strong><ul>
<li>Avoid the curse of dimensionality</li>
<li>Help eliminate irrelevant features and reduce noise</li>
<li>Reduce time and space required in data mining</li>
<li>Allow easier visualization</li>
</ul>
</li>
</ul>
<blockquote>
<p>Dimensionality Reduction Techniques</p>
</blockquote>
<ul>
<li>Dimensionality reduction methodologies<ul>
<li><strong>Feature selection</strong>: Find a subset of the original variables (or features, attributes)</li>
<li><strong>Feature extraction</strong>: Transform the data in the high-dimensional space to a space of fewer dimensions</li>
</ul>
</li>
<li>Some typical dimensionality methods<ul>
<li>Principal Component Analysis</li>
<li>Supervised and nonlinear techniques <ul>
<li>Feature subset selection</li>
<li>Feature creation</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Principal-Component-Analysis-PCA"><a href="#Principal-Component-Analysis-PCA" class="headerlink" title="Principal Component Analysis (PCA)"></a>Principal Component Analysis (PCA)</h2><ul>
<li>PCA: A statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called <em><strong>principal</strong></em> <em><strong>components</strong></em><ul>
<li>主成分分析(PCA):一种统计方法，它利用正交变换将一组可能相关变量的观测值转换为一组线性不相关变量的值，称为主成分</li>
</ul>
</li>
<li>The original data are projected onto a much smaller space, resulting in dimensionality reduction将原始数据投影到一个小得多的空间，从而进行降维</li>
<li>Method: Find the eigenvectors of the covariance matrix, and these eigenvectors define the new space  方法:求协方差矩阵的特征向量，用这些特征向量定义新空间</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jiayi8991.github.io/2021/12/21/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiayi Liang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JiayiSpace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/21/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">基于遗传算法的随机优化搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-21 22:25:00" itemprop="dateCreated datePublished" datetime="2021-12-21T22:25:00+08:00">2021-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 16:01:24" itemprop="dateModified" datetime="2022-08-29T16:01:24+08:00">2022-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h1 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="个体与种群"><a href="#个体与种群" class="headerlink" title="个体与种群"></a>个体与种群</h2><ul>
<li>个体(individual/candidate) 就是模拟生物个体而对问题中的对象（一般就是问题的解）的一种称呼，一个个体也就是搜索空间中的一个点</li>
<li>种群(population) 就是模拟生物种群而由若干个体组成的群体, 它一般是整个搜索空间的一个很小的子集。<ul>
<li>生活例子：杂交水稻。</li>
</ul>
</li>
</ul>
<h2 id="适应度和适应度函数"><a href="#适应度和适应度函数" class="headerlink" title="适应度和适应度函数"></a>适应度和适应度函数</h2><ul>
<li>   适应度(fitness)就是借鉴生物个体对环境的适应程度,而对问题中的个体对象所设计的表征其优劣的一种测度。</li>
<li>   适应度函数(fitness function)就是问题中的 全体个体与其适应度之间的一个对应关系。它一般是一个实值函数。该函数就是遗传算法中<strong>指导搜索的评价函数（函数值越大越好）</strong>。 </li>
</ul>
<h2 id="染色体和基因"><a href="#染色体和基因" class="headerlink" title="染色体和基因"></a>染色体和基因</h2><ul>
<li><p>染色体（chromosome）就是问题中个体的某种字符串形式的编码表示。字符串中的字符也就称为基因（gene）。</p>
</li>
<li><p>  例如：</p>
</li>
</ul>
<p>  ​      个体     染色体</p>
<p>  ​       9  —-  1001</p>
<p>  ​      （2，5，6）—- 010 101 110</p>
<h2 id="遗传操作"><a href="#遗传操作" class="headerlink" title="遗传操作"></a>遗传操作</h2><ul>
<li>亦称遗传算子(genetic operator)，就是关于染色体的运算。遗传算法中有三种遗传操作: </li>
<li>   选择-复制(selection-reproduction)</li>
<li>   交叉(crossover，亦称交换、交配或杂交)</li>
<li>   变异(mutation，亦称突变)</li>
</ul>
<h3 id="选择-复制"><a href="#选择-复制" class="headerlink" title="选择-复制"></a>选择-复制</h3><ul>
<li>通常做法是：对于一个规模为<em>N</em>的种群<em>S</em>,按每个染色体x<sub>i</sub>∈<em>S</em>的选择概率<em>P</em>(x<sub>i</sub>)所决定的选中机会, 分<em>N</em>次从<em>S</em>中随机选定<em>N</em>个染色体, 并进行复制。    </li>
</ul>
<p><img src="/2021/12/21/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/2021-12-2717-14-14.png"> </p>
<h3 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h3><ul>
<li><p> 交叉 就是互换两个染色体某些位上的基因。</p>
</li>
<li><p>​    例如, 设染色体 <em>s</em>1=01001011, <em>s</em>2=10010101, 交换其后4位基因, 即</p>
<ul>
<li><img src="/2021/12/21/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/2021-12-2717-10-45.png"></li>
<li><em>s</em>1′=01000101,  <em>s</em>2′=10011011</li>
<li>可以看做是原染色体<em>s</em>1和<em>s</em>2的子代染色体</li>
</ul>
</li>
</ul>
<h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><ul>
<li><p><strong>变异</strong> 就是改变染色体某个(些)位上的基因。</p>
</li>
<li><p>​    例如,  设染色体 <em>s</em>=11001101将其第三位上的0变为1, 即</p>
<p>​       <em>s</em>=11001101 <strong>→</strong>11101101= <em>s</em>′</p>
</li>
<li><p>​    <em>s</em>′也可以看做是原染色体<em>s</em>的子代染色体</p>
</li>
</ul>
<h1 id="基本遗传算法"><a href="#基本遗传算法" class="headerlink" title="基本遗传算法"></a>基本遗传算法</h1><p><img src="/2021/12/21/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/2021-12-2717-15-13.png"> </p>
<ul>
<li><p>算法中的一些控制参数：</p>
<ul>
<li>  <strong>种群规模</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </li>
<li>  <strong>最大换代数</strong></li>
<li>  <strong>交叉率</strong>(crossover rate)就是参加交叉运算的染色体个数占全体染色体总数的比例，记为<em>P</em>c,取值范围一般为0.4～0.99</li>
<li>  <strong>变异率</strong>(mutation rate)是指发生变异的基因位数所占全体染色体的基因总位数的比例，记为<em>P</em>m，取值范围一般为0.0001～0.1</li>
</ul>
</li>
<li><blockquote>
<p>基本遗传算法</p>
</blockquote>
</li>
<li><p> 步1 在搜索空间<em>U</em>上定义一个适应度函数<em>f</em>(<em>x</em>)，给定种群规模<em>N</em>，交叉率<em>P</em>c和变异率<em>P</em>m，代数<em>T</em>；</p>
</li>
<li><p> 步2 随机产生<em>U</em>中的<em>N</em>个个体<em>s</em>1, <em>s</em>2, …, <em>s</em>N，组成初始种群<em>S</em>={<em>s</em>1, <em>s</em>2, …, <em>s</em>N}，置代数计数器<em>t</em>=1；</p>
</li>
<li><p> 步3 计算<em>S</em>中每个个体的适应度f() ；</p>
</li>
<li><p> 步4 若终止条件满足，则取<em>S</em>中适应度最大的个体作为所求结果，算法结束。</p>
</li>
<li><p> 步5 按选择概率<em>P</em>(<em>x**i</em>)所决定的选中机会，每次从<em>S</em>中随机选定1个个体并将其染色体复制，共做<em>N</em>次，然后将复制所得的<em>N</em>个染色体组成群体<em>S</em>1；</p>
</li>
<li><p> 步6 按交叉率<em>P</em>c所决定的参加交叉的染色体数<em>c</em>，从<em>S</em>1中随机确定<em>c</em>个染色体，配对进行交叉操作，并用产生的新染色体代替原染色体，得群体<em>S</em>2；</p>
</li>
<li><p> 步7 按变异率<em>P</em>m所决定的变异次数<em>m</em>，从<em>S</em>2中随机确定<em>m</em>个染色体，分别进行变异操作，并用产生的新染色体代替原染色体，得群体<em>S</em>3；</p>
</li>
<li><p>步8 将群体<em>S</em>3作为新一代种群，即用<em>S</em>3代替<em>S</em>，<em>t</em> = <em>t</em>+1，转步3；</p>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如：利用遗传算法求解区间［0,31］上的二次函数<em>y</em>=x<sup>2</sup>的最大值。</p>
<p>分析：</p>
<ul>
<li>原问题可转化为在区间［0, 31］中搜索能使y取最大值的点<em>a</em>的问题。那么，［0, 31］ 中的点<em>x</em>就是个体, 函数值<em>f</em>(<em>x</em>)恰好就可以作为<em>x</em>的适应度，区间［0, 31］就是一个(解)空间 。这样, 只要能给出个体<em>x</em>的适当染色体编码, 该问题就可以用遗传算法来解决。</li>
</ul>
<p>解：</p>
<ul>
<li><p>(1) 设定种群规模,编码染色体，产生初始种群。</p>
</li>
<li><p>  将种群规模设定为4；用5位二进制数编码染色体；取下列个体组成初始种群<em>S</em>1:</p>
</li>
<li><p>​           <em>s</em>1= 13 (01101), <em>s</em>2= 24 (11000)</p>
</li>
<li><p>​           <em>s</em>3= 8 (01000),  <em>s</em>4= 19 (10011) </p>
</li>
<li><p>(2) 定义适应度函数,</p>
</li>
<li><p>​        取适应度函数：<em>f</em> (<em>x</em>)=<em>x</em><sup>2</sup></p>
</li>
<li><p>(3) 计算各代种群中的各个体的适应度, 并对其染色体进行遗传操作,直到适应度最高的个体(即31（11111）)出现为止。</p>
<p>首先计算种群<em>S</em>1中各个体</p>
<p>​        <em>s</em>1= 13(01101),  <em>s</em>2= 24(11000)           </p>
<p>​        <em>s</em>3= 8(01000),   <em>s</em>4= 19(10011)</p>
<p>的适应度<em>f</em> (<em>s<sub>i</sub></em>) 。</p>
<p>   容易求得</p>
<p>​           <em>f</em> (<em>s</em>1) = <em>f</em>(13) = 132 = 169</p>
<p>​            <em>f</em> (<em>s</em>2) = <em>f</em>(24) = 242 = 576</p>
<p>​            <em>f</em> (<em>s</em>3) = <em>f</em>(8) = 82 = 64</p>
<p>​            <em>f</em> (<em>s</em>4) = <em>f</em>(19) = 192 = 361</p>
<ul>
<li><p>再计算种群<em>S</em>1中各个体的选择概率</p>
<ul>
<li><p>选择概率的计算公式为<br>$$<br>P（xi）= f(xi)/ f（x）的和<br>$$</p>
<ul>
<li>由此可求得</li>
<li>​            <em>P</em>(<em>s</em>1) = <em>P</em>(13) = 0.14</li>
<li>​            <em>P</em>(<em>s</em>2) = <em>P</em>(24) = 0.49 </li>
<li>​            <em>P</em>(<em>s</em>3) = <em>P</em>(8) = 0.06</li>
<li>​            <em>P</em>(<em>s</em>4) = <em>P</em>(19) = 0.31</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/2021/12/21/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%8F%E6%9C%BA%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/2021-12-2719-07-55.png"> </p>
</li>
<li><p>在算法中赌轮选择法可用下面的子过程来模拟: ① 在［0, 1］区间内产生一个均匀分布的随机数<em>r</em>。</p>
</li>
<li><p> ② 若<em>r</em>≤<em>q</em>1,则染色体<em>x</em>1被选中。</p>
</li>
<li><p>③ 若<em>q<sub>k-1</sub></em>&lt; r <em>≤*q<sub>k</sub> (2≤</em>k<em>≤</em>N*), 则染色体<em>x<sub>k</sub>被选中。 其中的</em>q<sub>i</sub>称为染色体<em>x<sub>i</sub> (<em>i</em>=1, 2, …, <em>n</em>)的*<em>积累概率</em></em>, 其计算公式为<br>$$<br>q i = P(x)到i的和<br>$$</p>
</li>
</ul>
<blockquote>
<p>第一轮</p>
</blockquote>
<p>  设从区间［0, 1］中产生4个随机数如下: </p>
<p>  ​        <em>r</em>1 = 0.450126,  <em>r</em>2 = 0.110347 </p>
<p>  ​        <em>r</em>3 = 0.572496,  <em>r</em>4 = 0.98503</p>
<table>
<thead>
<tr>
<th>染色体</th>
<th>适应度</th>
<th>选择概率</th>
<th>积累概率</th>
<th>选中次数</th>
</tr>
</thead>
<tbody><tr>
<td><em>s</em>1=01101(13)</td>
<td>169</td>
<td>0.14</td>
<td>0.14</td>
<td>1</td>
</tr>
<tr>
<td><em>s</em>2=11000(24)</td>
<td>576</td>
<td>0.49</td>
<td>0.63</td>
<td>2</td>
</tr>
<tr>
<td><em>s</em>3=01000(8)</td>
<td>64</td>
<td>0.06</td>
<td>0.69</td>
<td>0</td>
</tr>
<tr>
<td><em>s</em>4=10011(19)</td>
<td>361</td>
<td>0.31</td>
<td>1.00</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>适应度函数 y = x^2，选择概率：赌轮选择法</li>
<li>积累概率：积累选择概率，根据积累概率区间选择染色体</li>
</ul>
</blockquote>
<ul>
<li>于是，经复制得群体：</li>
<li><em>s</em>1<em>’</em> =11000（24）, <em>s</em>2<em>’</em> =01101（13） </li>
<li><em>s</em>3<em>’</em> =11000（24）, <em>s</em>4<em>’</em> =10011（19）</li>
</ul>
</li>
<li><p>交叉</p>
</li>
<li><p> 设交叉率<em>p**c</em>=100%，即<em>S</em>1中的全体染色体都参加交叉运算。</p>
</li>
<li><p>s1’ =11000（24）, s2’ =01101（13） </p>
</li>
<li><p>s3’ =11000（24）, s4’ =10011（19）</p>
</li>
<li><p>​    设<em>s</em>1<em>’</em>与<em>s</em>2<em>’</em>配对，<em>s</em>3<em>’</em>与<em>s</em>4<em>’</em>配对。分别交换后两位基因，得新染色体：</p>
</li>
<li><p>  <em>s</em>1<em>’’</em>=11001（25）, <em>s</em>2<em>’’</em>=01100（12）</p>
</li>
<li><p><em>s</em>3<em>’’</em>=11011（27）, <em>s</em>4<em>’’</em>=10000（16）</p>
</li>
<li><p>变异</p>
</li>
<li><p>​    设变异率<em>p**m</em>=0.001。</p>
</li>
<li><p>​    这样，群体<em>S</em>1中共有</p>
</li>
<li><p>​                5×4×0.001=0.02    位基因可以变异。</p>
</li>
<li><p>​     0.02位显然不足1位，所以本轮遗传操作不做变异。</p>
<blockquote>
<p>第二轮</p>
</blockquote>
</li>
<li><p>于是，得到第二代种群<em>S</em>2：</p>
</li>
<li><p>​    <em>s</em>1=11001（25）, <em>s</em>2=01100（12）</p>
</li>
<li><p>​     <em>s</em>3=11011（27）, <em>s</em>4=10000（16）</p>
</li>
<li><p>如果从区间［0, 1］中产生4个随机数如下: </p>
</li>
<li><p>​        <em>r</em>1 = 0.450126,  <em>r</em>2 = 0.110347 </p>
</li>
<li><p>​        <em>r</em>3 = 0.572496,  <em>r</em>4 = 0.98503 </p>
</li>
<li><table>
<thead>
<tr>
<th>染色体</th>
<th>适应度</th>
<th>选择概率</th>
<th>积累概率</th>
<th>选中次数</th>
</tr>
</thead>
<tbody><tr>
<td><em>s</em>1=11001(25)</td>
<td>625</td>
<td>0.36</td>
<td>0.36</td>
<td>1</td>
</tr>
<tr>
<td><em>s</em>2=01100(12)</td>
<td>144</td>
<td>0.08</td>
<td>0.44</td>
<td>0</td>
</tr>
<tr>
<td><em>s</em>3=11011(27)</td>
<td>729</td>
<td>0.41</td>
<td>0.85</td>
<td>2</td>
</tr>
<tr>
<td><em>s</em>4=10000(16)</td>
<td>256</td>
<td>0.15</td>
<td>1.00</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>假设这一轮选择-复制操作中，种群<em>S</em>2中的</li>
<li><strong>4个染色体都被选中（小概率事件发生了）</strong>，则得到群体： </li>
<li> <em>s</em>1<em>’</em>=11001（25）, <em>s</em>2<em>’</em>= 01100（12）</li>
<li> <em>s</em>3<em>’</em>=11011（27）, <em>s</em>4<em>’</em>= 10000（16）</li>
<li>做交叉运算，让<em>s</em>1<em>’</em>与<em>s</em>2<em>’</em>，<em>s</em>3<em>’</em>与<em>s</em>4<em>’</em> 分别交换后三位基因，得 </li>
<li>   <em>s</em>1<em>’’</em> =11100（28）, <em>s</em>2<em>’’</em> = 01001（9）</li>
<li>   <em>s</em>3<em>’’</em> =11000（24）, <em>s</em>4<em>’’</em> = 10011（19）</li>
<li>这一轮仍然不会发生变异。</li>
</ul>
<blockquote>
<p>第三轮</p>
</blockquote>
<ul>
<li><p>于是，得第三代种群<em>S</em>3：</p>
</li>
<li><p> <em>s</em>1=11100（28）, <em>s</em>2=01001（9）</p>
</li>
<li><p> <em>s</em>3=11000（24）, <em>s</em>4=10011（19）</p>
</li>
<li><table>
<thead>
<tr>
<th>染色体</th>
<th>适应度</th>
<th>选择概率</th>
<th>积累概率</th>
<th>估计的选中次数</th>
</tr>
</thead>
<tbody><tr>
<td><em>s</em>1=11100(28)</td>
<td>784</td>
<td>0.44</td>
<td>0.44</td>
<td>2</td>
</tr>
<tr>
<td><em>s</em>2=01001(9)</td>
<td>81</td>
<td>0.04</td>
<td>0.48</td>
<td>0</td>
</tr>
<tr>
<td><em>s</em>3=11000(24)</td>
<td>576</td>
<td>0.32</td>
<td>0.80</td>
<td>1</td>
</tr>
<tr>
<td><em>s</em>4=10011(19)</td>
<td>361</td>
<td>0.20</td>
<td>1.00</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>设这一轮的选择-复制结果为：</li>
<li>​       <em>s</em>1<em>’</em>=11100（28）, <em>s</em>2<em>’</em>=11100（28）</li>
<li>​       <em>s</em>3<em>’</em>=11000（24）, <em>s</em>4<em>’</em>=10011（19） </li>
<li>做交叉运算，让<em>s</em>1<em>’</em>与<em>s</em>4<em>’</em>，<em>s</em>2<em>’</em>与<em>s</em>3<em>’</em> 分别交换后两位基因，得 </li>
<li><em>s</em>1<em>’’</em>=11111（31）, <em>s</em>2<em>’’</em>=11100（28）</li>
<li><em>s</em>3<em>’’</em>=11000（24）, <em>s</em>4<em>’’</em>=10000（16） </li>
</ul>
</li>
</ul>
<blockquote>
<p>第四轮</p>
</blockquote>
<ul>
<li>于是，得第四代种群<em>S</em>4： </li>
<li>​     <em>s</em>1=11111（31）, <em>s</em>2=11100（28）</li>
<li>​     <em>s</em>3=11000（24）, <em>s</em>4=10000（16） </li>
<li>显然，在这一代种群中已经出现了适应度最高的染色体<em>s</em>1=11111。于是，遗传操作终止，将染色体“11111”作为最终结果输出。</li>
<li> 然后，将染色体“11111”解码为表现型，即得所求的最优解：31。</li>
<li> 将31代入函数<em>y</em>=<em>x</em>2中，即得原问题的解，即函数<em>y</em>=<em>x</em>2的最大值为961。</li>
</ul>
</li>
</ul>
<h1 id="遗传算法的特点和优势"><a href="#遗传算法的特点和优势" class="headerlink" title="遗传算法的特点和优势"></a>遗传算法的特点和优势</h1><h2 id="遗传算法的主要特点"><a href="#遗传算法的主要特点" class="headerlink" title="遗传算法的主要特点"></a>遗传算法的主要特点</h2><ul>
<li> 遗传算法一般是直接在解空间搜索, 而不像图搜索那样一般是在问题空间搜索, 最后才找到解。 </li>
<li> 遗传算法的搜索随机地始于搜索空间的一个点集, 而不像图搜索那样固定地始于搜索空间的初始节点或终止节点, 所以遗传算法是一种随机搜索算法。</li>
<li>遗传算法总是在寻找优解, 而不像图搜索那样并非总是要求优解, 而一般是设法尽快找到解, 所以遗传算法又是一种优化搜索算法。</li>
<li> 遗传算法的搜索过程是从空间的一个点集(种群)到另一个点集(种群)的搜索,而不像图搜索那样一般是从空间的一个点到另一个点地搜索。 因而它实际是一种并行搜索, 适合大规模并行计算,而且这种种群到种群的搜索有能力跳出局部最优解。 </li>
<li>遗传算法的适应性强, 除需知适应度函数外, 几乎不需要其他的先验知识。 </li>
<li> 遗传算法长于全局搜索, 它不受搜索空间的限制性假设的约束,不要求连续性, 能以很大的概率从离散的、多极值的、 含有噪声的高维问题中找到全局最优解（但是不能保证一定找到最优解）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiayi Liang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiayi Liang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiayi Liang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
